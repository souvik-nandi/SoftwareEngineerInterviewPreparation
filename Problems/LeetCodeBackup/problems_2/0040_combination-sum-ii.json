{
    "id": "40",
    "question": {
        "questionId": "40",
        "questionFrontendId": "40",
        "boundTopicId": null,
        "title": "Combination Sum II",
        "titleSlug": "combination-sum-ii",
        "content": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sum to <code>target</code>.</p>\n\n<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>\n\n<p><strong>Note:</strong>&nbsp;The solution set must not contain duplicate combinations.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8\n<strong>Output:</strong> \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,5,2,1,2], target = 5\n<strong>Output:</strong> \n[\n[1,2,2],\n[5]\n]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 6019,
        "dislikes": 153,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[10,1,2,7,6,1,5]\n8\n[2,5,2,1,2]\n5",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Reddit\", \"slug\": \"reddit\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum2(candidates, target)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func combinationSum2(candidates []int, target int) [][]int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def combinationSum2(candidates: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun combinationSum2(candidates: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum2($candidates, $target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function combinationSum2(candidates: number[], target: number): number[][] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (combination-sum2 candidates target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec combination_sum2(Candidates :: [integer()], Target :: integer()) -> [[integer()]].\ncombination_sum2(Candidates, Target) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec combination_sum2(candidates :: [integer], target :: integer) :: [[integer]]\n  def combination_sum2(candidates, target) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"595.4K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 595419, \"totalSubmissionRaw\": 1128037, \"acRate\": \"52.8%\"}",
        "hints": [],
        "solution": {
            "id": "1090",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[10,1,2,7,6,1,5]\n8",
        "metaData": "{\n  \"name\": \"combinationSum2\",\n  \"params\": [\n    {\n      \"name\": \"candidates\",\n      \"type\": \"integer[]\"\n    },\n    {\n      \"name\": \"target\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"list<list<integer>>\",\n    \"dealloc\": true\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1090",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Overview\n\nAs one might figure from the title of this problem, this is an extention or variation of an earlier problem called [39. Combination Sum](https://leetcode.com/problems/combination-sum/solution/).\nTherefore, it would be helpful if one starts from the previous problem before tackling this one.\n\nThere are a series of problems on the theme of _combination sum_, as one will find out later.\nThese problems differ on the conditions such as whether there are duplicate numbers in the input list or whether a number can be used multiple times in a combination.\nDespite of all the differences, the key algorithm to solve the _combination sum_ problems remains the same, which is called [_backtracking_](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/).\n\nIn this article, we will present several approaches which are all based on the _backtracking_ algorithm.\n\n\n---\n#### Approach 1: Backtracking with Counters\n\n**Intuition**\n\n>As a reminder, [backtracking](https://en.wikipedia.org/wiki/Backtracking) is a general algorithm for finding all (or some) solutions to some computational problems. The idea is that it **_incrementally_** builds candidates to the solutions, and abandons a candidate (\"backtrack\") as soon as it determines that the candidate cannot lead to a final solution.\n\nIn our problem, we could _incrementally_ build the combination by adding numbers one at a time,\nand once we find the current combination is not valid, we _backtrack_ (by abondoning the last number we added to the combination) and try another candidate.\n\nAs we mentioned before, this problem is an extention of an earlier problem called [39. Combination Sum](https://leetcode.com/problems/combination-sum/solution/).\nAs it turns out, we could build the solutions upon the solutions to the problem of [39. Combination Sum](https://leetcode.com/problems/combination-sum/solution/), by incorporating the differences between the problems.\n\nThere are two differences between this problem and the earlier problem:\n\n- In this problem, each number in the input is **not** unique. The implication of this difference is that we need some mechanism to avoid generating **duplicate** combinations.\n\n- In this problem, each number can be used only **once**. The implication of this difference is that once a number is chosen as a candidate in the combination, it will not appear again as a candidate later.\n\nThere are several ways to adapt the solutions of [39. Combination Sum](https://leetcode.com/problems/combination-sum/solution/) to solve this problem.\n\n>In this approach, we will present a solution with the concept of **counter**.\nRather than treating each number as a candidate, we treat groups of unique numbers as candidates.\n\nTo demonstrate the idea, we showcase how it works with a concrete example in the following graph:\n\n![counter demo](../Figures/40/40_counter.png)\n\nAs one can see from the above graph, if we treat each appearance of the number `2` as a candidate, then we would generate multiple instances of the same combination of `[2, 2]`.\nFor instance, the first and second appearances of the number `2` will lead to the same combination as the second and the third appearances of the number `2`.\n\n>However, we could count the appearance of each unique number.\nAnd then we can use the generated _counter_ table during the construction of the combination.\n\nFor instance, starting from the empty combination, we first pick the number `2` as the first candidate into the combination.\nIn the counter table, we then update the count of the number `2`, which remains 2 instances rather than 3.\nIn the next step, again we pick another instance of the number `2` into the combination.\nWith this pick, we reach the desired target number which is `4`.\n\n>As one can see, with the counter table, at each step, we could ensure that each combination we generate would be **unique** at the end.\n\n\n**Algorithm**\n\nHere are a few steps on how we can implement the above intuition:\n\n- First of all, we build a counter table out of the given list of numbers.\n\n- We would then use this counter table during our _backtracking_ process, which we define as the function `backtrack(comb, remain, curr, candidate_groups, results)`.\nIn order to keep the **state** of each backtracking step, we use quite a few parameters in the function, which we elaborate as follows:\n\n    - `comb`: the combination we built so far at each step.\n    - `remain`: the remaining sum that we need to fill, in order to reach the target sum.\n    - `curr`: the cursor that points to the current group of number that we are using from the counter table.\n    - `counter`: the current counter table.\n    - `results`: the final combinations that have the target sum.\n\n- At each invocation of the backtracking function, we first check if we reach the target sum (_i.e._ `sum(comb) = target`), and if we should stop the exploration simply because the sum of current combination goes **beyond** the desired target.\n\n- If there is still some remaining sum to fill, we will then iterate through the current counter table to pick the next candidate.\n    - Once we pick a candidate, we then continue the exploration by invocating the `backtrack()` function with the __updated__ states.\n    - **More importantly**, at the end of each exploration, we need to **revert** the state we updated before, in order to start off a clean slate for the next exploration.\n    It is due to this _backtracking_ operation, the algorithm got its name.\n\n<iframe src=\"https://leetcode.com/playground/hdyvUaH7/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"hdyvUaH7\"></iframe>\n\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the size of the input array.\n\n- Time Complexity: $$\\mathcal{O}(2^N)$$\n\n    - In the worst case, our algorithm will *exhaust* all possible combinations from the input array.\n    Again, in the worst case, let us assume that each number is unique.\n    The number of combination for an array of size $$N$$ would be $$2^N$$, _i.e._ each number is either included or excluded in a combination.\n\n    - Additionally, it takes $$\\mathcal{O}(N)$$ time to build a counter table out of the input array.\n\n    - Therefore, the overall time complexity of the algorithm is dominated by the backtracking process, which is $$\\mathcal{O}(2^N)$$.\n\n- Space Complexity: $$\\mathcal{O}(N)$$\n\n    - We first build a counter table, which in the worst case will consume $$\\mathcal{O}(N)$$ space.\n\n    - We use the variable `comb` to keep track of the current combination we build, which requires again $$\\mathcal{O}(N)$$ space.\n\n    - In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack.\n    In the worst case, the stack will pile up to $$\\mathcal{O}(N)$$ space.\n\n    - To sum up, the overall space complexity of the algorithm is $$\\mathcal{O}(N) + \\mathcal{O}(N) + \\mathcal{O}(N) = \\mathcal{O}(N)$$.\n\n    - **_Note:_** we did not take into account the space needed to hold the final results of combination in the above analysis.\n\n\n---\n#### Approach 2: Backtracking with Index\n\n**Intuition**\n\nThere is another way to adapt the solution of [39. Combination Sum](https://leetcode.com/problems/combination-sum/solution/).\n\n>Rather than building a counter table to group the numbers together explicitly, we could **_sort_** the input, which could also group all the same numbers together.\n\nSimilar to the solution of [39. Combination Sum](https://leetcode.com/problems/combination-sum/solution/), we iterate through the _sorted_ input array, via backtracking to build the combinations.\n\nIn addition, we need to do some tricks with the **index** of the iteration, in order to avoid generating duplicated combinations.\n\nWe demonstrate the idea with the same example in the previous approach, _i.e._ `input = [2, 5, 2, 2]`.\n\n![index demo](../Figures/40/40_index_demo.png)\n\n- As we can see from the above graph, once we sort the input array, the occurrance of each unique number would be adjacent to each other.\n\n- In the above graph, we show the moment we start to process the group of number `2`, with the iteration **_index_** pointed to the beginning of the group.\n\n- Next, we need to move the _index_ forward, in order to choose the next number to be added to the combination.\nMore importantly, we need to **_skip_** certain positions, in order to avoid the generation of duplicated combinations.\nWe skip the position if the following two condtions are met:\n\n    - 1). `next_curr > curr`: we will pick the number at the current `curr` position into the combination, regardless the other conditions.\n    _This is important, since the iteration should allow us to select multiple instances of a unique number into the combination._\n\n    - 2). `candidates[next_curr] == candidates[next_curr-1]`: we will skip the occurances all repetitive numbers **in-between**, _e.g._ we skip the second and third occurance of number `2` in this round of backtracking.\n\n>The combined effects of the above sorting and iterating operations are equivalent to the previous approach with counter table.\n\n\n**Algorithm**\n\nIt would be clearer to see how the above tricks with index play out in the algorithm.\n\n- Similiar to the previous approach, we implement the backtracking process with the function named `backtrack(comb, remain, curr, results)`, but with less parameters, compared to the previous approach.\n\n- The bulk of the function remains the same as the solution of [39. Combination Sum](https://leetcode.com/problems/combination-sum/solution/), except the specific conditions on the index as we discussed before.\n\n- In addition, we optimize the backtracking a bit by adopting the measure of **_early stopping_**, _i.e._ once the sum of current combination exceeds the target, we can stop the exploration for the rest of the numbers.\nBecause all the numbers are positve, as specified in the problem, the sum of combination will increase monotonically.\nIt is needless to explore more combinations whose sum goes beyond the desired target.\n\n<iframe src=\"https://leetcode.com/playground/dpb8oACq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"dpb8oACq\"></iframe>\n\n\n\n**Complexity Analysis**\n\n\nLet $$N$$ be the size of the input array.\n\n- Time Complexity: $$\\mathcal{O}(2^N)$$\n\n    - In the worst case, our algorithm will *exhaust* all possible combinations from the input array, which in total amounts to   $$2^N$$ as we discussed before.\n\n    - The sorting will take $$\\mathcal{O}(N \\log N)$$.\n\n    - To sum up, the overall time complexity of the algorithm is dominated by the backtracking process, which is $$\\mathcal{O}(2^N)$$.\n\n\n- Space Complexity: $$\\mathcal{O}(N)$$\n\n    - We use the variable `comb` to keep track of the current combination we build, which requires $$\\mathcal{O}(N)$$ space.\n\n    - In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack.\n    In the worst case, the stack will pile up to $$\\mathcal{O}(N)$$ space.\n\n    - To sum up, the overall space complexity of the algorithm is $$\\mathcal{O}(N) + \\mathcal{O}(N) = \\mathcal{O}(N)$$.\n\n    - **_Note:_** we did not take into account the space needed to hold the final results of combination in the above analysis.\n\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1045",
            "count": 116,
            "average": "2.810",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "combination-sum-ii",
    "playgroundData": {
        "hdyvUaH7": {
            "playground": {
                "testcaseInput": "",
                "name": "combination-sum-ii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "dpb8oACq": {
            "playground": {
                "testcaseInput": "",
                "name": "combination-sum-ii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}