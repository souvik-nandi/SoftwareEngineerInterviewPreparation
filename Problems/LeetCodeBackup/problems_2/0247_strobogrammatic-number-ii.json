{
    "id": "247",
    "question": {
        "questionId": "247",
        "questionFrontendId": "247",
        "boundTopicId": null,
        "title": "Strobogrammatic Number II",
        "titleSlug": "strobogrammatic-number-ii",
        "content": "<p>Given an integer <code>n</code>, return all the <strong>strobogrammatic numbers</strong> that are of length <code>n</code>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>A <strong>strobogrammatic number</strong> is a number that looks the same when rotated <code>180</code> degrees (looked at upside down).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 2\n<strong>Output:</strong> [\"11\",\"69\",\"88\",\"96\"]\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [\"0\",\"1\",\"8\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 803,
        "dislikes": 206,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Strobogrammatic Number\", \"titleSlug\": \"strobogrammatic-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Strobogrammatic Number III\", \"titleSlug\": \"strobogrammatic-number-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum of k-Mirror Numbers\", \"titleSlug\": \"sum-of-k-mirror-numbers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "2\n1",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Recursion",
                "slug": "recursion",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> findStrobogrammatic(int n) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public List<String> findStrobogrammatic(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def findStrobogrammatic(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def findStrobogrammatic(self, n: int) -> List[str]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** findStrobogrammatic(int n, int* returnSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public IList<string> FindStrobogrammatic(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar findStrobogrammatic = function(n) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @return {String[]}\ndef find_strobogrammatic(n)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func findStrobogrammatic(_ n: Int) -> [String] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func findStrobogrammatic(n int) []string {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def findStrobogrammatic(n: Int): List[String] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun findStrobogrammatic(n: Int): List<String> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn find_strobogrammatic(n: i32) -> Vec<String> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String[]\n     */\n    function findStrobogrammatic($n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function findStrobogrammatic(n: number): string[] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (find-strobogrammatic n)\n  (-> exact-integer? (listof string?))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec find_strobogrammatic(N :: integer()) -> [unicode:unicode_binary()].\nfind_strobogrammatic(N) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec find_strobogrammatic(n :: integer) :: [String.t]\n  def find_strobogrammatic(n) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"122K\", \"totalSubmission\": \"238.4K\", \"totalAcceptedRaw\": 122050, \"totalSubmissionRaw\": 238366, \"acRate\": \"51.2%\"}",
        "hints": [
            "Try to use recursion and notice that it should recurse with <i>n</i> - 2 instead of <i>n</i> - 1."
        ],
        "solution": {
            "id": "1305",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": "ac",
        "sampleTestCase": "2",
        "metaData": "{\r\n  \"name\": \"findStrobogrammatic\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"n\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"list<string>\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "861",
            "date": "2022-03-08",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1305",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nWe need to return all strobogrammatic numbers of length $$N$$.          \nA strobogrammatic number is a number that looks the same when rotated $$180 \\degree$$ (looked at upside down).\n\nThere are two possibilities, the strobogrammatic number can have:             \n- An even number of digits: Then each digit will swap and rotate with some other digit.\n- Or, an odd number of digits: Then all digits will swap and rotate with some other digit except the center one which will remain at the same place but rotate $$180 \\degree$$.\n\nWe can visualize the rotation process using the following slideshow.\n\n!?!../Documents/247/slideshow1.json:960,540!?!\n\n<br />\n\n**First, let's see which digits can be used in strobogrammatic numbers.**      \n\nTwo types of digits are useful here:          \n- One, the digits which after rotation of $$180 \\degree$$ remains the same, like 0, 1 (here 1 is a straight line only), and 8.\n- Other is, the digits which after rotation converts into a different digit, like 6 changes to 9 and vice versa. \n\n<img src=\"../Figures/247/Slide7.PNG\" width=\"960\" alt=\"digits\">    <br />                  \n\n**Second, let's see which digits can occupy which places in the strobogrammatic number.**       \n\n- As demonstrated in the slideshow, when the length is odd, the middle digit remains at the same position. Thus this digit must be something that remains the same when rotated `(e.g. 0, 1, 8)`.\n\n- And when two positions interchange, we can use both types of digits, either we put two digits which change into one another `(e.g. 6 and 9)`, or we put two same digits which remain same when rotated `(e.g. 8 and 8)`.\n\n<br />\n\n---\n\n#### Approach 1: Recursion\n\n**Intuition**\n\nNow, we know which digits can be used so let's try solving some sample cases.      \nWe will try sample cases for $$N$$ equals $$1$$ up to $$N$$ equals $$4$$ which might be a bit lengthy, but by observing these sample cases, we should be able to come up with a recursive relation for this problem.\n\n\n**If the length of the number is $$1$$:**     \nThe digit will remain at the same position and rotate $$180 \\degree$$.    \nThus, the numbers can only be, `$$0$$`, `$$1$$`, and `$$8$$`.\n\n<br />\n\n**If the length is $$2$$:**       \nWe have two positions (say indices 0 and 1), which will interchange.\n\nSo we can use,\n- Either two same digits which remain the same after rotation, `$$11$$` and `$$88$$`.        \n    Take note that we can't use `$$0$$` here because `$$00$$` is not a 2 digit number. So we can't place `$$0$$` at the $$0^{th}$$ index of any number, except for the number `$$0$$` itself.\n\n- Or, two digits that change into one another, `$$69$$` and `$$96$$`.\n\nThus, 2-digit strobogrammatic numbers will be, `$$11$$`, `$$69$$`, `$$88$$`, and `$$96$$`.\n\n<br />\n\n**If the length is $$3$$:**       \nWe have three positions (say indices 0, 1, and 2) and out of these three positions, index 0 and index 2 will interchange, but index 1 will remain in the same place.       \n\nSuppose we have all of the 1-digit strobogrammatic numbers. To find the 3-digit strobogrammatic numbers, we just need to append one extra digit at the beginning and at the end which are reversible. Here, reversible means it will keep the number strobogrammatic.\nWe know that we can use both types of digits (those that change into each other or remain the same after rotation) for this position. But keep in mind that we can't append `$$0$$` at the beginning.\n```\n=> '0' + (1-digit strobogrammatic numbers) + '0'\n'0' + '0' + '0' = '000'  (1-digit number) (not valid)\n'0' + '1' + '0' = '010' (2-digit number) (not valid)\n'0' + '8' + '0' = '080' (2-digit number) (not valid)\n\n=> '1' + (1-digit strobogrammatic numbers) + '1'\n'1' + '0' + '1' = '101'\n'1' + '1' + '1' = '111'\n'1' + '8' + '1' = '181'\n\n=> '6' + (1-digit strobogrammatic numbers) + '9'\n'6' + '0' + '9' = '609'\n'6' + '1' + '9' = '619'\n'6' + '8' + '9' = '689'\n\n=> '8' + (1-digit strobogrammatic numbers) + '8'\n'8' + '0' + '8' = '808'\n'8' + '1' + '8' = '818'\n'8' + '8' + '8' = '888'\n\n=> '9' + (1-digit strobogrammatic numbers) + '6'\n'9' + '0' + '6' = '906'\n'9' + '1' + '6' = '916'\n'9' + '8' + '6' = '986'\n```\n\nThus, these are all of the 3-digit strobogrammatic numbers: `$$101$$`, `$$111$$`, `$$181$$`, `$$609$$`, `$$619$$`, `$$689$$`, `$$808$$`, `$$818$$`, `$$888$$`, `$$906$$`, `$$916$$`, and `$$986$$`.\n\n<br />\n\n**If the length is $$4$$:**       \nWe have four positions (say indices 0, 1, 2, and 3), and out of these four positions, (index 0, index 3) and (index 1, index 2) will interchange.            \n\nSuppose we have all of the 2-digit strobogrammatic numbers. To find the 4-digit strobogrammatic numbers, we just need to append one extra digit at the beginning and the end which are reversible (just like previously discussed).\n        \nBut here, in 2-digit strobogrammatic numbers, we can include `$$00$$` because after appending a nonzero digit to the beginning and the end, '$$00$$' becomes a valid 4-digit number.\n\n```\n=> '1' + (2-digit strobogrammatic numbers) + '1'\n'1' + '00' + '1' = '1001'\n'1' + '11' + '1' = '1111'\n'1' + '69' + '1' = '1691'\n'1' + '88' + '1' = '1881'\n'1' + '96' + '1' = '1961'\n\n=> '6' + (2-digit strobogrammatic numbers) + '9'\n'6' + '00' + '9' = '6009'\n'6' + '11' + '9' = '6119'\n'6' + '69' + '9' = '6699'\n'6' + '88' + '9' = '6889'\n'6' + '96' + '9' = '6969'\n\n=> '8' + (2-digit strobogrammatic numbers) + '8'\n'8' + '00' + '8' = '8008'\n'8' + '11' + '8' = '8118'\n'8' + '69' + '8' = '8698'\n'8' + '88' + '8' = '8888'\n'8' + '96' + '8' = '8968'\n\n=> '9' + (2-digit strobogrammatic numbers) + '6'\n'9' + '00' + '6' = '9006'\n'9' + '11' + '6' = '9116'\n'9' + '69' + '6' = '9696'\n'9' + '88' + '6' = '9886'\n'9' + '96' + '6' = '9966'\n```\n\nThus, 4-digit strobogrammatic numbers will be, `$$1001$$`, `$$1111$$`, `$$1691$$`, `$$1881$$`, `$$1961$$`, `$$6009$$`, `$$6119$$`, `$$6699$$`, `$$6889$$`, `$$6969$$`, `$$8008$$`, `$$8118$$`, `$$8698$$`, `$$8888$$`, `$$8968$$`, `$$9006$$`, `$$9116$$`, `$$9696$$`, `$$9886$$`, and `$$9966$$`.\n\n<br />\n\nFollowing this pattern, we can conclude that to find all strobogrammatic numbers with N-digits, we first need to find all strobogrammatic numbers with (N - 2) digits and then append reversible digits to the beginning and the end.\n\nNow, instead of strobogrammatic numbers of length N, we need to find strobogrammatic numbers of length N - 2.        \nThis is the same problem but with a smaller input. So we can approach this problem using **recursion**.\n\n> If you are not familiar with recursion, you can check out our [Recursion Explore Card](https://leetcode.com/explore/featured/card/recursion-i/).\n\n```\ngenerateStroboNumbers(N) = List(\"digit1\" + \"number\" + \"digit2\"\n                                for each number in generateStroboNumbers(N - 2)\n                                for each (digit1, digit2) in reversiblePairs\n                               )\n```\nThis will be our recursive logic, which is called as **recurrence relation**.\n\n\nNow, to terminate the recursive calls, we need to think about base cases. A base case is some input for which we can determine the result without making further recursive calls. \nWith each recursive call, we decrease `$$N$$` by `$$2$$`. Therefore, if `$$N$$` is initially even, we will make recursive calls until `$$N$$` is `$$0$$`. Otherwise, if `$$N$$` is odd, we will make recursive calls until `$$N$$` is `$$1$$`.\nWe can determine the result for input `$$N = 0$$` and input `$$N = 1$$` without using recursion (as shown above). Thus, we can make our base cases `generateStroboNumbers(0) = ['']` and `generateStroboNumbers(1) = ['0', '1', '8']`.\n\nAnd the empty string can be considered as a 0-digit strobogrammatic number.\n\n> **Note:** We need to take `N == 0` as our base case, not `N == 2`, because `2-digit` numbers will not consider `'00'` as a valid number. Thus, if we generate 4-digit numbers using `N == 2` as the base case, we will skip some numbers. However, if we start with `N == 0`, we will have an option to generate `'00'` as a valid number because we know the current position is not the first digit of the 4-digit number, so we can append `0`.\n\n\n**Algorithm**\n\n1. Initialize a data structure `reversiblePairs`, which contains all pairs of reversible digits.\n\n2. Call and return the recursive function, `generateStroboNumbers(n, finalLength)`, where the first argument indicates that the current call will generate all n-digit strobogrammatic numbers. The second argument indicates the length of the final strobogrammatic numbers that we will generate and will be used to check if we can add '0' to the beginning and end of a number. \n\n3. Create a function `generateStroboNumbers(n, finalLength)` which will return all strobogrammatic numbers of n-digits:\n    - Check for base cases, if `n == 0` return an array with an empty string `[\"\"]`, otherwise if `n == 1` return `[\"0\", \"1\", \"8\"]`.\n    - Call `generateStroboNumbers(n - 2, finalLength)` to get all the strobogrammatic numbers of (n-2) digits and store them in `subAns`.\n    - Initialize an empty array `currStroboNums` to store strobogrammatic numbers of n-digits.\n    - For each number in `prevStroboNums` we append all `reversiblePairs` at the beginning and the end except when the current reversible pair is `'00'` and `n == finalLength` (because we can't append `'0'` at the beginning of a number) and push this new number in `ans`.\n    - At the end of the function, return all the strobogrammatic numbers, i.e. `currStroboNums`.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/68GkZVEm/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"68GkZVEm\"></iframe>\n\n\n**Complexity Analysis**\n\nHere, $$N$$ is the length of strobogrammatic numbers we need to find.         \n\nLet's try visualizing the recursion tree for our approach. Our recursive function makes another recursive call and with each recursive call we decrease `$$N$$` by `$$2$$`.          \nIn series, $$[$$ `$$N$$`, `$$N-2$$`, `$$N-4$$`, `$$N-6$$`, `$$ ..... $$`, `$$0$$` $$]$$ using arithmetic progression (AP) formula we can say we have `$$N / 2$$` elements.             \nHence, in our recursion tree, we will have at most `$$N / 2$$` levels. \n\n* Time complexity: $$N \\cdot 5^{\\lfloor N/2 \\rfloor + 1}$$.      \n\n  - In each recursive level, we iterate over all `prevStroboNums` strings and append $$5$$ pairs of characters to each one of them; thus, we increase `currStroboNums` array size by a factor of $$5$$ with each level. Except for the last level, where it increases by a factor of $$4$$ because we omit $$0$$.\n\n    <img src=\"../Figures/247/Slide8.PNG\" width=\"960\" alt=\"recursion tree\">      <br /> \n\n  - So, when $$N$$ is even total iterations done will be, $$ 5 + 5^{2} + 5^{3} + .... + 5^{(N/2) - 1}  + 4 \\cdot 5^{(N/2) - 1} \\approx \\bf{5^{N/2}} $$.\n\n  - Similarly, when $$N$$ is odd we start with $$3$$ strings, and append $$5$$ pairs of characters to each string in each level except the last level. So, here total iterations done will be, $$ 3 \\cdot 5 + 3 \\cdot 5^{2} + 3 \\cdot 5^{3} + .... + 3 \\cdot 5^{(N-3)/2} + 3 \\cdot 4 \\cdot 5^{(N-3)/2} \\approx 5^{((N-1)/2) + 1} = \\bf{5^{\\lfloor N/2 \\rfloor + 1}} $$.\n\n  - And appending of a character at the end of a string takes $$O(1)$$ time, but appending at the beginning takes $$O(N)$$ time. Thus, we will perform the $$O(N)$$ operation in each iteration.\n  - Thus, the overall time taken will be $$N \\cdot 5^{\\lfloor N/2 \\rfloor + 1}$$.\n\n\n\n* Space complexity: $$O(N \\cdot 5^{\\lfloor N/2 \\rfloor})$$.       \n\n  - We make at most $$N/2$$ recursive calls. Thus, the call stack will use $$O(N/2)$$ space.\n\n  - `currStroboNums` is the output array, thus in the last recursion, it will not be considered as auxiliary space. However, in earlier recursions `currStroboNums` array will be considered as auxiliary space.\n\n  - We store at most $$\\bf{5^{(N/2) - 1}}$$ strings when $$N$$ is even, otherwise $$3 \\cdot 5^{((N-1)/2) - 1} \\approx \\bf{5^{\\lfloor N/2 \\rfloor}} $$ when $$N$$ is odd in our `currStroboNums` array and each string is of length $$N-2$$.\n\n  - Thus, overall space used will be $$(N-2) \\cdot 5^{\\lfloor N/2 \\rfloor} + N/2 \\approx N \\cdot 5^{\\lfloor N/2 \\rfloor}$$.\n\n---\n\n<br />\n\n\n\n#### Approach 2: Iteration (Level Order Traversal)\n\n**Intuition**\n\nWe can also implement the above approach iteratively by using a queue instead of recursion. This process will be the same as doing a level order traversal. While traversing all elements of one level, we will push the next level's elements into the queue and repeat this process for $$ \\lfloor N/2 \\rfloor $$ levels.\n\nThis process can be visualized using the following image. Here, we can see the first level has 1-digit strobogrammatic numbers. Then in the next level, after appending reversible digits, we get 3-digit strobogrammatic numbers, then 5-digit strobogrammatic numbers, and so on.\n\n\n<img src=\"../Figures/247/Slide9.PNG\" width=\"960\" alt=\"level order tree\">       \n\n<img src=\"../Figures/247/Slide10.PNG\" width=\"960\" alt=\"queue levels\">    <br /> \n\nWe keep all strobogrammatic numbers of (N-2) digits in the queue and then append all reversible pairs to all the numbers in the queue to get strobogrammatic numbers of N digits.\n\nWe also know we can't append the `'00'` pair at the beginning of the number.        \nSo here, we will use one variable, `currStringsLength`, which will denote the length of the strobogrammatic numbers in the current level. When `currStringsLength` equals `$$N$$`, the added number will be in the first position; thus, we cannot append `'0'`.\n\n**Algorithm**\n\n1. Initialize:\n    - `reversiblePairs` as a data structure that stores all pairs of reversible digits.\n    - `q` as a queue for doing level order traversal.        \n    In javascript and python, we will use an array as a queue for easier implementation.\n    - `currStringsLength` as 0 if `n` is even or 1 if `n` is odd, to denote the number of digits in each string, in the current level strobogrammatic numbers.\n\n2. If `n` is even, we push `[\"\"]` in the queue, and initialize `currStringsLength` with `0`, because `n` will decrease till `0`. Thus for this case, our starting case will be 0-digit strobogrammatic numbers.         \n  Otherwise, if `n` is odd, we push `[\"0\", \"1\", \"8\"]` in the queue and initialize `currStringsLength` with `1`, because for odd `n` the starting case will be 1-digit strobogrammatic numbers.         \n\n3. We will iterate over one whole level stored in the queue until `currStringsLength` becomes equal to `n`.\n    - In each level, we will append two characters, thus increasing `currStringsLength` by `2`.\n    - For each number in the current level (present in the queue) we pop it and, append all `reversiblePairs` at the beginning and the end except when the current reversible pair is `'00'` and `currStringsLength == n` (because we can't append `'0'` at the beginning of a number) and push this new number in the `queue` again.\n\n4. After traversing all levels, the queue will contain all n digit strobogrammatic numbers, thus we push them in a `stroboNums` array and return it.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/6YpYdxgt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"6YpYdxgt\"></iframe>\n\n\n**Complexity Analysis**\n\nHere, $$N$$ is the length of strobogrammatic numbers we need to find.\n\nWe start with strings of length `0` or `1` and go until they are $$N$$ digits long. At each level, we increment the string length by `2`. Thus, we must traverse $$N/2$$ levels.\n\n* Time complexity: $$O(N \\cdot 5^{\\lfloor N/2 \\rfloor + 1})$$.           \n  - In each level we iterate over all queue elements and append $$5$$ pairs of characters to each one of them; thus, we increment our queue size by 5 times (approximately) with each level.\n\n  - So, when $$N$$ is even we start with $$1$$ empty string and the total number of elements traversed using the queue will be, $$ 1 + 5 + 5^{2} + 5^{3} + .... + 5^{(N/2) - 1}  + 4 \\cdot 5^{(N/2) - 1} \\approx \\bf{5^{N/2 + 1}} $$.\n\n  - Similarly, when $$N$$ is odd we start with $$3$$ strings. So, here the total number of elements traversed will be, $$ 3 + 3 \\cdot 5 + 3 \\cdot 5^{2} + 3 \\cdot 5^{3} + .... + 3 \\cdot 5^{(N-3)/2} + 3 \\cdot 4 \\cdot 5^{(N-3)/2} \\approx 5^{(N-1)/2 + 1} = \\bf{5^{\\lfloor N/2 \\rfloor + 1}} $$.\n\n  - And appending of a character at the end of a string takes $$O(1)$$ time, but appending at the beginning takes $$O(N)$$ time. Thus, we will perform the $$O(N)$$ operation in each iteration.\n  - Thus, the overall time taken will be $$N \\cdot 5^{\\lfloor N/2 \\rfloor + 1}$$.\n\n\n\n* Space complexity: $$O(N \\cdot 5^{\\lfloor N/2 \\rfloor})$$.          \n\n  - In the last level, we store at most $$4 \\cdot 5^{(N/2) - 1} \\approx \\bf{5^{N/2}}$$ strings when $$N$$ is even, otherwise $$3 \\cdot 4 \\cdot 5^{(N-3)/2} \\approx 5^{(N-1)/2} = \\bf{5^{\\lfloor N/2 \\rfloor}} $$ strings when $$N$$ is odd in the queue and each string is of length $$N$$.\n\n  - Thus, overall space used will be $$N \\cdot 5^{\\lfloor N/2 \\rfloor} + N/2 \\approx N \\cdot 5^{\\lfloor N/2 \\rfloor}$$.\n\n  > **Note:** In javascript and python, in the last iteration the arrary is the output array thus it will not be considered in auxiliary space. But still the overall order of the complexity remains the same.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1310",
            "count": 20,
            "average": "4.950",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "strobogrammatic-number-ii",
    "playgroundData": {
        "68GkZVEm": {
            "playground": {
                "testcaseInput": "",
                "name": "strobogrammatic-number-ii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "6YpYdxgt": {
            "playground": {
                "testcaseInput": "",
                "name": "strobogrammatic-number-ii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}