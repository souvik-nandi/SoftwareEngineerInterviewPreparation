{
    "id": "1125",
    "question": {
        "questionId": "1125",
        "questionFrontendId": "1166",
        "boundTopicId": null,
        "title": "Design File System",
        "titleSlug": "design-file-system",
        "content": "<p>You are asked to design a file system&nbsp;that allows you to create new paths and associate them with different values.</p>\n\n<p>The format of a path is&nbsp;one or more concatenated strings of the form:&nbsp;<code>/</code> followed by one or more lowercase English letters. For example, &quot;<code>/leetcode&quot;</code>&nbsp;and &quot;<code>/leetcode/problems&quot;</code>&nbsp;are valid paths while an empty&nbsp;string <code>&quot;&quot;</code> and <code>&quot;/&quot;</code>&nbsp;are not.</p>\n\n<p>Implement the&nbsp;<code>FileSystem</code> class:</p>\n\n<ul>\n\t<li><code>bool createPath(string path, int value)</code>&nbsp;Creates a new <code>path</code> and associates a <code>value</code> to it if possible and returns <code>true</code>.&nbsp;Returns <code>false</code>&nbsp;if the path <strong>already exists</strong> or its parent path <strong>doesn&#39;t exist</strong>.</li>\n\t<li><code>int get(string path)</code>&nbsp;Returns the value associated with <code>path</code> or returns&nbsp;<code>-1</code>&nbsp;if the path doesn&#39;t exist.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \n[&quot;FileSystem&quot;,&quot;createPath&quot;,&quot;get&quot;]\n[[],[&quot;/a&quot;,1],[&quot;/a&quot;]]\n<strong>Output:</strong> \n[null,true,1]\n<strong>Explanation:</strong> \nFileSystem fileSystem = new FileSystem();\n\nfileSystem.createPath(&quot;/a&quot;, 1); // return true\nfileSystem.get(&quot;/a&quot;); // return 1\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \n[&quot;FileSystem&quot;,&quot;createPath&quot;,&quot;createPath&quot;,&quot;get&quot;,&quot;createPath&quot;,&quot;get&quot;]\n[[],[&quot;/leet&quot;,1],[&quot;/leet/code&quot;,2],[&quot;/leet/code&quot;],[&quot;/c/d&quot;,1],[&quot;/c&quot;]]\n<strong>Output:</strong> \n[null,true,true,2,false,-1]\n<strong>Explanation:</strong> \nFileSystem fileSystem = new FileSystem();\n\nfileSystem.createPath(&quot;/leet&quot;, 1); // return true\nfileSystem.createPath(&quot;/leet/code&quot;, 2); // return true\nfileSystem.get(&quot;/leet/code&quot;); // return 2\nfileSystem.createPath(&quot;/c/d&quot;, 1); // return false because the parent path &quot;/c&quot; doesn&#39;t exist.\nfileSystem.get(&quot;/c&quot;); // return -1 because this path doesn&#39;t exist.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of&nbsp;calls to the two functions&nbsp;is less than or equal to <code>10<sup>4</sup></code> in total.</li>\n\t<li><code>2 &lt;= path.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= value &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 383,
        "dislikes": 39,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[\"FileSystem\",\"createPath\",\"get\"]\n[[],[\"/a\",1],[\"/a\"]]\n[\"FileSystem\",\"createPath\",\"createPath\",\"get\",\"createPath\",\"get\"]\n[[],[\"/leet\",1],[\"/leet/code\",2],[\"/leet/code\"],[\"/c/d\",1],[\"/c\"]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Design",
                "slug": "design",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Trie",
                "slug": "trie",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"DoorDash\", \"slug\": \"doordash\", \"timesEncountered\": 17}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Coinbase\", \"slug\": \"coinbase\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}], \"3\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class FileSystem {\npublic:\n    FileSystem() {\n        \n    }\n    \n    bool createPath(string path, int value) {\n        \n    }\n    \n    int get(string path) {\n        \n    }\n};\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem* obj = new FileSystem();\n * bool param_1 = obj->createPath(path,value);\n * int param_2 = obj->get(path);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public boolean createPath(String path, int value) {\n        \n    }\n    \n    public int get(String path) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * boolean param_1 = obj.createPath(path,value);\n * int param_2 = obj.get(path);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class FileSystem(object):\n\n    def __init__(self):\n        \n\n    def createPath(self, path, value):\n        \"\"\"\n        :type path: str\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def get(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.createPath(path,value)\n# param_2 = obj.get(path)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class FileSystem:\n\n    def __init__(self):\n        \n\n    def createPath(self, path: str, value: int) -> bool:\n        \n\n    def get(self, path: str) -> int:\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.createPath(path,value)\n# param_2 = obj.get(path)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n\ntypedef struct {\n    \n} FileSystem;\n\n\nFileSystem* fileSystemCreate() {\n    \n}\n\nbool fileSystemCreatePath(FileSystem* obj, char * path, int value) {\n  \n}\n\nint fileSystemGet(FileSystem* obj, char * path) {\n  \n}\n\nvoid fileSystemFree(FileSystem* obj) {\n    \n}\n\n/**\n * Your FileSystem struct will be instantiated and called as such:\n * FileSystem* obj = fileSystemCreate();\n * bool param_1 = fileSystemCreatePath(obj, path, value);\n \n * int param_2 = fileSystemGet(obj, path);\n \n * fileSystemFree(obj);\n*/",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public bool CreatePath(string path, int value) {\n        \n    }\n    \n    public int Get(string path) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * bool param_1 = obj.CreatePath(path,value);\n * int param_2 = obj.Get(path);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "\nvar FileSystem = function() {\n    \n};\n\n/** \n * @param {string} path \n * @param {number} value\n * @return {boolean}\n */\nFileSystem.prototype.createPath = function(path, value) {\n    \n};\n\n/** \n * @param {string} path\n * @return {number}\n */\nFileSystem.prototype.get = function(path) {\n    \n};\n\n/** \n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "class FileSystem\n    def initialize()\n        \n    end\n\n\n=begin\n    :type path: String\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def create_path(path, value)\n        \n    end\n\n\n=begin\n    :type path: String\n    :rtype: Integer\n=end\n    def get(path)\n        \n    end\n\n\nend\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem.new()\n# param_1 = obj.create_path(path, value)\n# param_2 = obj.get(path)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "\nclass FileSystem {\n\n    init() {\n        \n    }\n    \n    func createPath(_ path: String, _ value: Int) -> Bool {\n        \n    }\n    \n    func get(_ path: String) -> Int {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem()\n * let ret_1: Bool = obj.createPath(path, value)\n * let ret_2: Int = obj.get(path)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "type FileSystem struct {\n    \n}\n\n\nfunc Constructor() FileSystem {\n    \n}\n\n\nfunc (this *FileSystem) CreatePath(path string, value int) bool {\n    \n}\n\n\nfunc (this *FileSystem) Get(path string) int {\n    \n}\n\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.CreatePath(path,value);\n * param_2 := obj.Get(path);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "class FileSystem() {\n\n    def createPath(path: String, value: Int): Boolean = {\n        \n    }\n\n    def get(path: String): Int = {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class FileSystem() {\n\n    fun createPath(path: String, value: Int): Boolean {\n        \n    }\n\n    fun get(path: String): Int {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "struct FileSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl FileSystem {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn create_path(&self, path: String, value: i32) -> bool {\n        \n    }\n    \n    fn get(&self, path: String) -> i32 {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem::new();\n * let ret_1: bool = obj.create_path(path, value);\n * let ret_2: i32 = obj.get(path);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class FileSystem {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @param Integer $value\n     * @return Boolean\n     */\n    function createPath($path, $value) {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @return Integer\n     */\n    function get($path) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * $obj = FileSystem();\n * $ret_1 = $obj->createPath($path, $value);\n * $ret_2 = $obj->get($path);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "class FileSystem {\n    constructor() {\n\n    }\n\n    createPath(path: string, value: number): boolean {\n\n    }\n\n    get(path: string): number {\n\n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define file-system%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; create-path : string? exact-integer? -> boolean?\n    (define/public (create-path path value)\n\n      )\n    ; get : string? -> exact-integer?\n    (define/public (get path)\n\n      )))\n\n;; Your file-system% object will be instantiated and called as such:\n;; (define obj (new file-system%))\n;; (define param_1 (send obj create-path path value))\n;; (define param_2 (send obj get path))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec file_system_init_() -> any().\nfile_system_init_() ->\n  .\n\n-spec file_system_create_path(Path :: unicode:unicode_binary(), Value :: integer()) -> boolean().\nfile_system_create_path(Path, Value) ->\n  .\n\n-spec file_system_get(Path :: unicode:unicode_binary()) -> integer().\nfile_system_get(Path) ->\n  .\n\n\n%% Your functions will be called as such:\n%% file_system_init_(),\n%% Param_1 = file_system_create_path(Path, Value),\n%% Param_2 = file_system_get(Path),\n\n%% file_system_init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule FileSystem do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec create_path(path :: String.t, value :: integer) :: boolean\n  def create_path(path, value) do\n\n  end\n\n  @spec get(path :: String.t) :: integer\n  def get(path) do\n\n  end\nend\n\n# Your functions will be called as such:\n# FileSystem.init_()\n# param_1 = FileSystem.create_path(path, value)\n# param_2 = FileSystem.get(path)\n\n# FileSystem.init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"30.8K\", \"totalSubmission\": \"49.6K\", \"totalAcceptedRaw\": 30756, \"totalSubmissionRaw\": 49644, \"acRate\": \"62.0%\"}",
        "hints": [
            "What if you think of a tree hierarchy for the files?.",
            "A path is a node in the tree.",
            "Use a hash table to store the valid paths along with their values."
        ],
        "solution": {
            "id": "1094",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"FileSystem\",\"createPath\",\"get\"]\n[[],[\"/a\",1],[\"/a\"]]",
        "metaData": "{\n  \"classname\": \"FileSystem\",\n  \"maxbytesperline\": 400000,\n  \"constructor\": {\n    \"params\": []\n  },\n  \"methods\": [\n    {\n      \"name\": \"createPath\",\n      \"params\": [\n        {\n          \"type\": \"string\",\n          \"name\": \"path\"\n        },\n        {\n          \"type\": \"integer\",\n          \"name\": \"value\"\n        }\n      ],\n      \"return\": {\n        \"type\": \"boolean\"\n      }\n    },\n    {\n      \"name\": \"get\",\n      \"params\": [\n        {\n          \"type\": \"string\",\n          \"name\": \"path\"\n        }\n      ],\n      \"return\": {\n        \"type\": \"integer\"\n      }\n    }\n  ],\n  \"systemdesign\": true,\n  \"params\": [\n    {\n      \"name\": \"inputs\",\n      \"type\": \"integer[]\"\n    },\n    {\n      \"name\": \"inputs\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"list<String>\",\n    \"dealloc\": true\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "898",
            "date": "2022-04-22",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1094",
        "content": "[TOC]\n\n## Solution\n---\n\n#### Approach 1: Dictionary for storing paths\n\n**Intuition**\n\nThis first approach is pretty much a simulation-based approach for solving this problem. We call it a simulation-based approach because it doesn't use any fancy data-structure for storing the paths and pretty much, we do what the problem asks us to do for both the functions. We simply need a key-value data structure with some additional processing to verify the validity of a path being added. Naturally, a `HashMap` or a `dictionary` seems to be a good data structure to go with.\n\nLet's look at a visual representation of how a HashMap would look as we keep on adding more paths to it. The following represents the state of the file system after adding the following paths: `/a`, `/a/b`, `/a/b/c`, and `/a/b/e`.\n\n![HashMap](../Figures/1166/img1.png)\n{:align=\"center\"}\n\n*Figure 1. A HashMap containing the various paths in the file system and their keys.*\n{:align=\"center\"}\n\nRetrieving the value corresponding to a path is relatively simple because the path itself represents a key in the HashMap. However, for adding a new path, we can simply retrieve the `parent path` e.g. `/a/b` is the parent path for `/a/b/c` and similarly for `/a/b/e`, and then check if the parent path exists in the HashMap as a key or not.\n\n **Algorithm**\n \n 1. Initialize a dictionary or a `HashMap` called `paths` that will have the key as the `path` input to our `create` function and the value would be the `value` passed to the function.\n 2. For our `create` function, we have three steps that we need to do:\n     1. Step-1 is that we do a basic verification of the path being valid or not. Here we check if the path is empty, or `\"/\"` or if the path already exists in our dictionary. If any of these conditions are met, we simply return `false`.\n     2. The second step is to obtain the parent path of the provided `path` and check its presence in the dictionary. If the parent path doesn't exist, then we simply return false. Else, we move on. \n         \n     > Note that checking for just the parent is enough because the presence of the parent path ensures that the grandparent (and other ancestors by this logic) would also exist in the dictionary.\n         \n     3. Finally, we insert the provided `path` and `value` into the dictionary and return true.\n         \n 3. For the `get` function, we simply return a default value of `-1` if the `path` doesn't exist inside the dictionary. Else, we return the actual value.\n\n<iframe src=\"https://leetcode.com/playground/dcKzjYK3/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"dcKzjYK3\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(M)$$, where $M$ is the length of `path`. All the time is actually consumed by the operation that gives us the `parent` path. We first spend $$\\mathcal{O}(M)$$ on finding the last `\"/\"` of the path and then another $$\\mathcal{O}(M)$$ to obtain the parent string. Searching and addition into a HashMap/dictionary takes an ammortized $$\\mathcal{O}(1)$$ time.\n* Space Complexity: $$\\mathcal{O}(K)$$ where $$K$$ represents the number of unique paths that we add.\n<br/>\n<br/>\n---\n\n#### Approach 2: Trie based approach\n\n**Intuition**\n\nThere is another great data structure which we can use for approaching this particular problem and that is the `Trie` data structure. In order to read more about this data structure and other use cases, please refer to our [Explore Card](https://leetcode.com/explore/learn/card/trie/) for the same. A problem that we see with our previous problem is that for adding a path of length `M`, we need to add all of its $$\\frac{M \\times (M - 1)}{2}$$ ancestors which would end up occupying a lot of space in our HashMap based solution since each of these ancestors would occupy a key in the dictionary. \n\n> We can instead make use of a Trie here because the common prefixes for various strings can be represented by a common branch in the Trie and that ends up saving a lot of space. Additionally, sub-paths along a branch can also be represented easily without cloning the Trie branch. For example all the ancestors of /a/b/c/d/e i.e. /a, /a/b, /a/b/c, /a/b/c/d can be marked on the single branch representing the path /a/b/c/d/e and that is a lot of space saving for this problem.\n\nHere's how a Trie would look like after we have added the following paths to it: `/a`, `/a/b`, `/a/b/c`, `/a/b/e`, `/a/e`.\n\n![HashMap](../Figures/1166/img2.png)\n{:align=\"center\"}\n\n*Figure 2. A Trie representation showing the various paths we added to the File System.*\n{:align=\"center\"}\n\n **Algorithm**\n \n 1. The basic data structure that is used for representing a Trie is a dictionary. The dictionary and other potential flags/data values can be a part of a custom `TreeNode` data structure. For this problem, we will have a `TrieNode` data structure that will contain three things\n         1. The string representing the path name.\n         2. The value corresponding to this path. \n         3. And finally, a dictionary representing the outgoing connections to other `TrieNodes`.\n 2. The root of our trie will be a `TrieNode` containing the empty string.\n 3. *Create()* ~\n     1. First, we will split the given path into various components using `/` as the delimiter. So for the path `/a/b/c`, we will have four components namely ` `, `a`, `b`, and `c`.\n            \n         ![HashMap](../Figures/1166/img3.png)\n\n         *Figure 3. Let's consider an example Trie.*\n            \n     2. Initialize a `TrieNode` called `curr` which will be equal to the root node of the trie. Note that we always start at the root node and then go down based on the various path components.\n \n         ![HashMap](../Figures/1166/img4.png)\n\n         *Figure 4. Initialize the \"curr\" node.*\n \n     3. We will iterate over all of these components and for each of them, we will do the following:\n         1. Check if the component exists in `curr`'s dictionary . If it doesn't we return false unless it is the last component of the path in which case we add it to the current dictionary.\n         2. If the current component exists in the `curr` node, we obtain the value which will be another `TrieNode` and update `curr` to be equal to that node. \n         3. Eventually, we will process the last component of the path. If that exists in the trie as well, we return `false` in accordance with the problem statement. Else, we add it to the trie by creating a new node with path as `path` and value as `value` i.e. the input parameters.\n     \n             ![HashMap](../Figures/1166/img5.png)\n\n             *Figure 5. Add the last component to the Trie.*\n     \n4. *Get()* ~\n    1. To check if a path exists in the trie, we need to verify if all its components, along with the proper connections exist in the trie.\n    2. Split the given path into various components using `/` as the delimiter.\n    3. Initialize a `TrieNode` called `curr` which will be equal to the root node of the trie.\n    4. We will iterate over all of these components and for each of them, we will do the following:\n        1. Check if the component exists in `curr`'s dictionary .\n        2. If the current component exists in the `curr` node, we obtain the value which will be another `TrieNode` and update `curr` to be equal to that node. \n        3. If it doesn't exist, we return `false`.\n    5. Return `true`. \n\n<iframe src=\"https://leetcode.com/playground/W92H8uAq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"W92H8uAq\"></iframe>\n\n**Complexity Analysis**\n\nBefore we get into the complexity analysis, let's see why one might prefer the Trie approach. The main advantage of the trie based approach is that we are able to save on space. All the paths sharing common prefixes can be represented by a common branch in the tree. The disadvantage however is that the `get` operation no longer remains $$O(1)$$.\n\n* Time Complexity:\n    - `create` ~ It takes $$O(T)$$ to add a path to the trie if it contains $$T$$ components.\n    - `get` ~ It takes $$O(T)$$ to find a path in the trie if it contains $$T$$ components.\n* Space Complexity:\n    - `create` ~ Lets look at the worst case space complexity. In the worst case, none of the paths will have any common prefixes. We are not considering the ancestors of a larger path here. In such a case, each unique path will end up taking a different branch in the trie. Also, for a path containing $$T$$ components, there will be $$T$$ nodes in the trie.\n    - `get` ~ $$O(1)$$.\n\n<br/>\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1049",
            "count": 25,
            "average": "4.720",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "design-file-system",
    "playgroundData": {
        "dcKzjYK3": {
            "playground": {
                "testcaseInput": "",
                "name": "design-file-system-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "W92H8uAq": {
            "playground": {
                "testcaseInput": "",
                "name": "design-file-system-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}