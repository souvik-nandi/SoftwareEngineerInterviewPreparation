{
    "id": "1808",
    "question": {
        "questionId": "1808",
        "questionFrontendId": "1690",
        "boundTopicId": null,
        "title": "Stone Game VII",
        "titleSlug": "stone-game-vii",
        "content": "<p>Alice and Bob take turns playing a game, with <strong>Alice starting first</strong>.</p>\n\n<p>There are <code>n</code> stones arranged in a row. On each player&#39;s turn, they can <strong>remove</strong> either the leftmost stone or the rightmost stone from the row and receive points equal to the <strong>sum</strong> of the remaining stones&#39; values in the row. The winner is the one with the higher score when there are no stones left to remove.</p>\n\n<p>Bob found that he will always lose this game (poor Bob, he always loses), so he decided to <strong>minimize the score&#39;s difference</strong>. Alice&#39;s goal is to <strong>maximize the difference</strong> in the score.</p>\n\n<p>Given an array of integers <code>stones</code> where <code>stones[i]</code> represents the value of the <code>i<sup>th</sup></code> stone <strong>from the left</strong>, return <em>the <strong>difference</strong> in Alice and Bob&#39;s score if they both play <strong>optimally</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> stones = [5,3,1,4,2]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \n- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].\n- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].\n- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].\n- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].\n- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].\nThe score difference is 18 - 12 = 6.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> stones = [7,90,5,1,100,10,10,2]\n<strong>Output:</strong> 122</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 712,
        "dislikes": 130,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Stone Game\", \"titleSlug\": \"stone-game\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Stone Game II\", \"titleSlug\": \"stone-game-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Stone Game III\", \"titleSlug\": \"stone-game-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Stone Game IV\", \"titleSlug\": \"stone-game-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Stone Game V\", \"titleSlug\": \"stone-game-v\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Stone Game VI\", \"titleSlug\": \"stone-game-vi\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Score from Performing Multiplication Operations\", \"titleSlug\": \"maximum-score-from-performing-multiplication-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Stone Game VIII\", \"titleSlug\": \"stone-game-viii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Stone Game IX\", \"titleSlug\": \"stone-game-ix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[5,3,1,4,2]\n[7,90,5,1,100,10,10,2]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Math",
                "slug": "math",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Game Theory",
                "slug": "game-theory",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Dunzo\", \"slug\": \"dunzo\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int stoneGameVII(vector<int>& stones) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int stoneGameVII(int[] stones) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def stoneGameVII(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def stoneGameVII(self, stones: List[int]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint stoneGameVII(int* stones, int stonesSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int StoneGameVII(int[] stones) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} stones\n * @return {number}\n */\nvar stoneGameVII = function(stones) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} stones\n# @return {Integer}\ndef stone_game_vii(stones)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func stoneGameVII(_ stones: [Int]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func stoneGameVII(stones []int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def stoneGameVII(stones: Array[Int]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun stoneGameVII(stones: IntArray): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn stone_game_vii(stones: Vec<i32>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $stones\n     * @return Integer\n     */\n    function stoneGameVII($stones) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function stoneGameVII(stones: number[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"27.3K\", \"totalSubmission\": \"46.4K\", \"totalAcceptedRaw\": 27293, \"totalSubmissionRaw\": 46387, \"acRate\": \"58.8%\"}",
        "hints": [
            "The constraints are small enough for an N^2 solution.",
            "Try using dynamic programming."
        ],
        "solution": {
            "id": "1080",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[5,3,1,4,2]",
        "metaData": "{\n  \"name\": \"stoneGameVII\",\n  \"params\": [\n    {\n      \"name\": \"stones\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1080",
        "content": "[TOC]\n\n## Solution\n---\n\n#### Overview ####\n\nThere are multiple variations of this problem [Stone Game I](https://leetcode.com/problems/stone-game/), [Stone Game II](https://leetcode.com/problems/stone-game-ii/), etc. In this problem, there are $$2$$ players, _Alice_ and _Bob_, each player having a different goal. _Alice_ wants to maximize her score difference with _Bob_ and _Bob_ wants to minimize his score difference with _Alice_.\n\nEach player tries to make the best choice and play optimally. _Alice_ wants to know what would be _Bob_'s score if she makes a particular choice and vice versa. Hence, this problem cannot be implemented greedily. This is a perfect problem to understand the concepts of _Dynamic Programming_. We would recommend the reader to read all the approaches to understand how a recursive problem can be implemented using _Dynamic Programming_ paradigms.\n\n---\n\n#### Approach 1: Brute Force Using Recursion\n\n**Intuition**\n\nThe naive solution to solve the problem would be that at every point when either of the players Alice or Bob have to make a choice, they know what would be the best choice.\n\n- For Alice, the best choice would be the one that makes her win with maximum score.\n\n- For Bob, the best choice would be the one that makes him loose with the minimum difference in score with Alice.\n\nAt every turn, the players could remove either the first stone (leftmost) or the last stone (rightmost). The players must know what would be their score on picking up either of the stones.\n\nLet's take an example, array = `[5, 3, 1]`. Here's how each of the players will make a choice.\n\n![img](../Documents/5627/problemOverview.svg)\n\n- Alice knows that Bob is trying to be as close as possible to her.\n\n> Alice :   _\" If I remove $$5$$, I will get score $$4$$ (3 + 1). From the remaining stones $$[3, 1]$$, Bob will remove $$1$$ and get the score $$3$$. Then the difference between our scores would be $$1$$._\n>\n>_And If I remove $$1$$, I will get a score of $$8$$ (5 + 3). From the remaining stones $$[5, 3]$$, Bob will remove $$3$$ and get the score $$5$$. Then the difference between our scores would be $$3$$\"_\n\nBased on her analysis, Alice removes $$1$$ and gains a score of $$8$$.\n\n- Now the remaining stone are $$[5,3]$$. Bob has to remove $$3$$, to get the score $$5$$ and minimize the difference with Alice.\n\n> Fun fact: Alice had already predicated what choice Bob is going to make.\n\nLet's understand how can we implement the above idea.\n\n**Algorithm**\n\nIf we look at the problem, for each player to know the best choice, it must solve the game till the end and find the score for each choice.\n\n_Step 1:_\n\nGiven an array `stones`, starting at index `start` and ending at index `end`, if either player removes first stone at index `start` i.e `stones[start]` the score obtained would be sum of stone values from `stones[start + 1]` to `stones[end]`. Let the score obtained by removing the first stone be `scoreRemoveFirst`, given by,\n\n```\nscoreRemoveFirst = sum(stones[start + 1] to stones[end])\n```\n\nSimilarly, the score obtained on removing last stone at index `end` i.e stone[end] would be given by,\n\n```\nscoreRemoveLast = sum(stones[start] to stones[end - 1])\n```\n\n> Note: Instead of finding the sum every time for a given range, we could pre-calculate the prefix sum till every index. Example, `prefixSum[i]` would be sum of all the values in array `stone` from index $$0$$ to $$i$$. Now, to calculate the sum of all the values from index $$1$$ to $$i$$, we could simply calculate as `prefixSum[i] - prefixSum[0]`.\n\n![img](../Documents/5627/prefixSumIdea.svg)\n\n\n_Step 2:_\n\nNow, we know what score a player would obtain on removing either first or last stone. But we cannot be greedy here and just take the maximum score out of these. We must know the difference in score with the opponent player for both choices. How would we know the total difference with the opponent until now?\n\nLet each player return the difference in stone values after making their choice. Every player would subtract the difference returned by an opponent player from their current score to get the total difference.\n\n- For Bob, he will try to return the maximum negative value. So that the difference between his and Alice's score is minimum.\n\n- For Alice, she will try to return the maximum positive value. So that the difference between her and Bob's score is maximum.\n\nLet `findDifference(start, end, alice)` return the difference in score for a player in array `stones`, starting at index `start` and ending at index `end`.`alice` is a boolean variable that would be `true` for Alice and `false` for Bob.\nEach player would recursively calculate the difference that another player would return.\n\n-  Bob's goal is to return the maximum negative value.\n> Bob's difference = Alice's difference - Current Score\n\n_Note: Since we are finding the maximum of negative values, we would use min()_\n\n```\n   findDifference(start, end, false) = min(\n   // if Bob removes first stone\n   findDifference(start + 1, end, true) - scoreRemoveFirst\n   // if Bob removes last stone\n   findDifference(start , end - 1, true) - scoreRemoveLast\n  )\n```\n\n-  Alice's goal is to return the maximum positive value.\n> Alice's difference = Bob's Difference + Current Score\n\n_Note: Since Bob's difference would be a negative value, we would add the Current Score of Alice to find the maximum positive difference._\n\n```\n   findDifference(start, end, false) = max(\n   // if Alice removes first stone\n   findDifference(start + 1, end, false) + scoreRemoveFirst\n   // if Alice removes last stone\n   findDifference(start , end - 1, false) + scoreRemoveLast\n  )\n```\n\n_Base Case_\n\nAs we are recursively calculating the difference for each of the players, we must terminate our search at a certain point i.e at the base case. In our search, we would reach a point when there is a single element in the array, that is, the `start` and `end` index would be the same. The player would remove that stone and obtain the `0` difference in that case.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/7iy4abEo/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"7iy4abEo\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of array `stones`.\n\n- Time Complexity : $$\\mathcal{O}(2^{n})$$. We fill the array `prefixSum` of size `n` by iterating `n` times. The time complexity would be $$\\mathcal{O}(n)$$.\n\n   For every array element in `stones`, there are 2 choices, either we remove it or keep it. Thus, the recursive tree takes the form of binary tree having roughly $$2^{n}$$ nodes. The time complexity would be $$\\mathcal{O}(2^{n})$$.\n\n  This would give us total time complexity as $$\\mathcal{O}(n) + \\mathcal{O}(2^{n}) =  \\mathcal{O}(2^{n})$$.\n\n   _This approach is exhaustive and results in Time Limit Exceeded (TLE)_\n\n- Space Complexity: $$\\mathcal{O}(n)$$, as we build an array `prefixSum` of size $$n$$.\n\n---\n\n#### Approach 2: Top Down Dynamic Programming - Memoization\n\n**Intuition**\n\nIn the above approach, we observe that the same subproblem is computed and solved multiple times. Can we optimize that?\n\nOf course !! If you are familiar with [Dynamic Programming](https://en.wikipedia.org/wiki/Dynamic_programming), you would know that this problem has [Overlapping Subproblems](https://en.wikipedia.org/wiki/Overlapping_subproblems)\n. Alice calculates the difference that Bob would return and vice versa. If both players store these calculated values, it could be used in the future if a difference for the same values is required.\n\n**Algorithm**\n\nThe algorithm is the same as _Approach 1_ with an additional step. We could store the results of our computation for the first time and use them later. This technique of computing once and returning the stored value is called [Memoization](https://en.wikipedia.org/wiki/Memoization). We use a two-dimensional array $$\\text{memo}$$ and follow the following steps in each recursive call for `findDifference(start, end, alice)`:\n\n- Check if difference for the given range $$\\text{start}..\\text{end}$$ is present in $$\\text{memo}$$ to see if we can avoid computing the answer and return the result stored in $$\\text{memo}$$.\n- Save the results of any calculations to $$\\text{memo}$$.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/dqBhkrHY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"dqBhkrHY\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of array `stones`.\n\n- Time Complexity : $$\\mathcal{O}(n^{2})$$. For all possible subarrays in array `stones`, we calculate it's result only once. Since there are $$n^{2}$$ possible subarrays for an array of length $$n$$, the time complexity would be $$\\mathcal{O}(n^{2})$$.\n\n- Space Complexity: $$\\mathcal{O}(n^{2})$$. We use an array `memo` of size $$n \\cdot n$$ and `prefixSum` of size $$n$$. This gives us space complexity as $$\\mathcal{O}(n^{2}) + \\mathcal{O}(n) =  \\mathcal{O}(n^{2})$$.\n\n---\n\n#### Approach 3: Optimised Memoization Approach\n\n**Intuition**\n\nThere is another way of thinking about the problem,\n\n_Both Bob and Alice are trying to maximize their score. Alice is trying to get the maximum score so that she has a maximum difference from Bob's score. Bob is also trying to get the maximum score so that he is as close to Alice as possible._\n\nIf both players want to maximize their score, they must return the maximum difference to the other player. To calculate the current difference, each player would subtract the difference returned by the opponent from the current score.\n\n> The more is the difference returned by the current player, the lesser is the score for the opponent and the higher is the score of the current player.\n\nSo, the difference calculations of Alice and Bob can be given by,\n> If the current player is Bob,\n>\n> Difference = Current Score - Difference returned by Alice\n>\n> If the current player is Alice,\n>\n> Difference = Current Score - Difference returned by Bob\n\n**Algorithm**\n\nThe algorithm is similar to _Approach 2_. Now, that both players have a common goal, that is, to return _maximum difference_ value to the opponent. We don't care who is the current player. Each of the players will perform the following steps.\n\n- Calculate the current score after removing the first or last stone given by `scoreRemoveFirst` and `scoreRemoveLast` respectively. The calculations of these scores are the same as in _Approach 1_.\n\n- Find the maximum difference for the opponent player to minimize their total score. The difference can be calculated recursively as follows,\n\n```\n   findDifference(start, end) = max(\n   // if player removes first stone\n   scoreRemoveFirst - findDifference(start + 1, end)\n   // if player removes last stone\n   scoreRemoveLast - findDifference(start , end - 1)\n  )\n```\n\n- At the end, the total difference for removing a stone from array `stones` starting at index `0` and ending at index `n - 1` would be returned.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/jVM3TB33/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"jVM3TB33\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of array `stones`.\n\n- Time Complexity : $$\\mathcal{O}(n^{2})$$. For all possible subarray in array `stones`, we calculate it's result only once. Since there are $$n^{2}$$ possible subarrays for an array of length $$n$$, the time complexity would be $$\\mathcal{O}(n^{2})$$.\n\n- Space Complexity: $$\\mathcal{O}(n^{2})$$. We use an array `memo` of size $$n \\cdot n$$ and `prefixSum` of size $$n$$. This gives us space complexity as $$\\mathcal{O}(n^{2}) + \\mathcal{O}(n) =  \\mathcal{O}(n^{2})$$.\n\n---\n\n#### Approach 4: Bottom Up Dynamic Programming - Tabulation\n\n**Intuition**\n\nThis is another approach to solve Dynamic Programming problems. We can use the iterative approach and store the result of subproblems in a bottom-up fashion also known as _Tabulation_.\n\nInstead of recursively finding the solution for the original problem, we would start by finding the solution starting from the smallest subproblem and iteratively move towards a larger subproblem.\n\nExample, to find the result for given array `stones` = `[5, 3, 1, 4]`,\n- The smallest subproblem would be when the `stones` array has a single element. So we will find the result for subarrays of length $$1$$- `[5]`, `[3]`, `[1]`, `[4]`.\n- Now, we would progress towards finding result for subarrays of length $$2$$ -`[5, 3]`, `[3, 1]`, `[1, 4]`. It must be noted that at this point we could use the results from previous calculations.  \n\n  For example, to calculate the result for subarray `[5, 3]`, we could use the result calculated for subarrays `[5]` and `[3]`.\n\n   In this way, we could calculate the results of subarrays for each length. At last we would calculate the result for the length of $$4$$ which would be the final result.  \n\nLet's look at the algorithm in detail.\n\n**Algorithm**\n\nWe maintain a 2D array. For the `stones` array starting at index `start` and ending at index `end`, `dp[start][end]` would store the difference obtained after making the best choice by any of the players.\n\n- We would build the `prefixSum` as we did in previous approaches, to obtain the current score.\n\n- We know that if the index `start` is equal to index `end`, there must be a single element in array `stones` and the difference obtained would be $$0$$. Thus, we must start by finding results for subarrays of the length of $$2$$. We must stop when we find a result for subarray of size $$n$$, where $$n$$ is the length of array `stones`.\n\n- As we want to find the result for subarrays with length $$i$$, then $$i+1$$ and so on, we must traverse the array diagonally. The outer loop will iterate for each `length` and the inner loop will find the result of subarrays of size `length`.\n\n- At the end, we must return the result for the `stones` array, starting at index `0` and ending at `n-1`.\n\nThe following figure illustrates the idea for the given array `stones = [5, 3, 1, 4, 2]`.\n\n![img](../Documents/5627/dpTabulation.svg)\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/ZAtqVTT3/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"ZAtqVTT3\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of array `stones`.\n\n- Time Complexity : $$\\mathcal{O}(n^{2})$$, as we iterate over a 2D array of size $$n \\cdot n$$.\n\n- Space Complexity: $$\\mathcal{O}(n^{2})$$, as we use an array `dp` of size $$n \\cdot n$$ and `prefixSum` of size $$n$$. This gives us space complexity as $$\\mathcal{O}(n^{2}) + \\mathcal{O}(n) =  \\mathcal{O}(n^{2})$$.\n\n---\n\n#### Approach 5: Another Approach using Tabulation\n\n**Intuition**\n\nThere is another way of solving the problem using _Tabulation_. This is just a different way of traversing and filling the 2D array. Instead of traversing diagonally to find the results of subarrays for each length, we would fix our `start` index at a certain point. And now the `end` index would incrementally add an element to the subarray and find the results.\n\nFor example, for array = `[5, 3, 2, 1]`, we could fix our start index at `[5]`, end index would incrementally calculate the result for subarrays `[5, 3]`, `[5, 3, 2]`  and `[5, 3, 2, 1]`.\n\nHowever, it must be noted that for calculating the result for `[5, 3]`, we must know the result for `[3]` as well. Similarly, to get the result for `[5, 3, 2]`, we must know the result for `[3, 2]` and `[2]`. The trick to solving this problem is by iterating from backward.\n\n**Algorithm**\n\nWe maintain a 2D array. For the stones array starting at index `start` and ending at index `end`, `dp[start][end]` would store the difference obtained after making the best choice by any of the players.\n\n- We would build the `prefixSum` as we did in previous approaches, to obtain the current score.\n\n- We know that if the index `start` is equal to index `end`, there must be a single element in array `stones` and the difference obtained would be $$0$$. Thus, we must start by finding results for subarrays of the length of $$2$$. Thus we begin by fixing the `start` index at the `n-2` position and decrement until it reaches the $$0^{th}$$ index.  And `end` begins from `start + 1` index and increment until it reaches $$n^{th}$$ index.\n\n- The outer loop fixes the `start` index and the inner loop fixes the `end` index. For every subarray starting at index `start` and ending at index `end`, we would calculate the difference as in _Approach 4_.\n\n- At the end, we must return the result for the `stones` array, starting at index `0` and ending at `n-1`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/UDK9KsPt/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"UDK9KsPt\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of array `stones`.\n\n- Time Complexity : $$\\mathcal{O}(n^{2})$$, as we iterate over a 2D array of size $$n \\cdot n$$.\n\n- Space Complexity: $$\\mathcal{O}(n^{2})$$, as we use an array `dp` of size $$n \\cdot n$$ and `prefixSum` of size $$n$$. This gives us space complexity as $$\\mathcal{O}(n^{2}) + \\mathcal{O}(n) =  \\mathcal{O}(n^{2})$$.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1035",
            "count": 36,
            "average": "3.861",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "stone-game-vii",
    "playgroundData": {
        "7iy4abEo": {
            "playground": {
                "testcaseInput": "",
                "name": "stone-game-vii-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "dqBhkrHY": {
            "playground": {
                "testcaseInput": "",
                "name": "stone-game-vii-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "jVM3TB33": {
            "playground": {
                "testcaseInput": "",
                "name": "stone-game-vii-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "ZAtqVTT3": {
            "playground": {
                "testcaseInput": "",
                "name": "stone-game-vii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "UDK9KsPt": {
            "playground": {
                "testcaseInput": "",
                "name": "stone-game-vii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}