{
    "id": "207",
    "question": {
        "questionId": "207",
        "questionFrontendId": "207",
        "boundTopicId": null,
        "title": "Course Schedule",
        "titleSlug": "course-schedule",
        "content": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 10218,
        "dislikes": 409,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Course Schedule II\", \"titleSlug\": \"course-schedule-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Graph Valid Tree\", \"titleSlug\": \"graph-valid-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Height Trees\", \"titleSlug\": \"minimum-height-trees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Course Schedule III\", \"titleSlug\": \"course-schedule-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "2\n[[1,0]]\n2\n[[1,0],[0,1]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Graph",
                "slug": "graph",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Topological Sort",
                "slug": "topological-sort",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 34}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 9}, {\"taggedByAdmin\": false, \"name\": \"tiktok\", \"slug\": \"tiktok\", \"timesEncountered\": 9}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 8}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 4}, {\"taggedByAdmin\": true, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Qualtrics\", \"slug\": \"qualtrics\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Wayfair\", \"slug\": \"wayfair\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Twitch\", \"slug\": \"twitch\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Intuit\", \"slug\": \"intuit\", \"timesEncountered\": 8}, {\"taggedByAdmin\": false, \"name\": \"Karat\", \"slug\": \"karat\", \"timesEncountered\": 8}, {\"taggedByAdmin\": false, \"name\": \"Roblox\", \"slug\": \"roblox\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"DoorDash\", \"slug\": \"doordash\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Splunk\", \"slug\": \"splunk\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Zillow\", \"slug\": \"zillow\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"JPMorgan\", \"slug\": \"jpmorgan\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"C3 IoT\", \"slug\": \"c3-iot\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Tesla\", \"slug\": \"tesla\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Yelp\", \"slug\": \"yelp\", \"timesEncountered\": 0}, {\"taggedByAdmin\": true, \"name\": \"Zenefits\", \"slug\": \"zenefits\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Twilio\", \"slug\": \"twilio\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Robinhood\", \"slug\": \"robinhood\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Wish\", \"slug\": \"wish\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"HBO\", \"slug\": \"hbo\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Nvidia\", \"slug\": \"nvidia\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nbool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nvar canFinish = function(numCourses, prerequisites) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} num_courses\n# @param {Integer[][]} prerequisites\n# @return {Boolean}\ndef can_finish(num_courses, prerequisites)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func canFinish(numCourses int, prerequisites [][]int) bool {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $numCourses\n     * @param Integer[][] $prerequisites\n     * @return Boolean\n     */\n    function canFinish($numCourses, $prerequisites) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function canFinish(numCourses: number, prerequisites: number[][]): boolean {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (can-finish numCourses prerequisites)\n  (-> exact-integer? (listof (listof exact-integer?)) boolean?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec can_finish(NumCourses :: integer(), Prerequisites :: [[integer()]]) -> boolean().\ncan_finish(NumCourses, Prerequisites) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec can_finish(num_courses :: integer, prerequisites :: [[integer]]) :: boolean\n  def can_finish(num_courses, prerequisites) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"930.9K\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 930886, \"totalSubmissionRaw\": 2059817, \"acRate\": \"45.2%\"}",
        "hints": [
            "This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
            "<a href=\"https://class.coursera.org/algo-003/lecture/52\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.",
            "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
        ],
        "solution": {
            "id": "888",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "2\n[[1,0]]",
        "metaData": "{\r\n  \"name\": \"canFinish\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"numCourses\",\r\n      \"type\": \"integer\"\r\n    },\r\n    {\r\n      \"name\": \"prerequisites\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "888",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Approach 1: Backtracking\n\n**Intuition**\n\nThe problem could be modeled as yet another *__graph traversal__* problem, where each course can be represented as a _vertex_ in a graph and the dependency between the courses can be modeled as a directed edge between two vertex.\n\n>And the problem to determine if one could build a valid schedule of courses that satisfies all the dependencies (_i.e._ _**constraints**_) would be equivalent to determine if the corresponding graph is a **DAG** (_Directed Acyclic Graph_), _i.e._ there is no cycle existed in the graph.\n\n![pic](../Figures/207/207_graph.png)\n\nA typical strategy for graph traversal problems would be [backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/) or simply DFS (depth-first search).\n\nHere let us start with the backtracking algorithm, which arguably might be more intuitive.\n\n>As a reminder, [backtracking](https://en.wikipedia.org/wiki/Backtracking) is a general algorithm that is often applied to solve the [constraint satisfaction problems](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem), which incrementally builds candidates to the solutions, and abandons a candidate (_i.e._ backtracks) as soon as it determines that the candidate would not lead to a valid solution.\n\nThe general idea here is that we could enumerate each course (vertex), to check if it could form cyclic dependencies (_i.e._ a cyclic path) starting from this course.\n\nThe check of cyclic dependencies for each course could be done via *__backtracking__*, where we incrementally follow the dependencies until either there is no more dependency or we come across a previously visited course along the path.\n\n\n**Algorithm**\n\nThe overall structure of the algorithm is simple, which consists of three main steps: \n\n- Step 1). we build a graph data structure from the given list of course dependencies. Here we adopt the adjacency list data structure as shown below to represent the graph, which can be implemented via hashmap or dictionary. Each entry in the adjacency list represents a node which consists of a node index and a list of neighbors nodes that follow from the node.\n![pic](../Figures/207/207_adjacency_list.png)\n<br/>\n- Step 2). we then enumerate each node (course) in the constructed graph, to check if we could form a dependency cycle starting from the node. \n<br/>\n- Step 3). we perform the cyclic check via backtracking, where we **_breadcrumb_** our path (_i.e._ mark the nodes we visited) to detect if we come across a previously visited node (hence a cycle detected). We also remove the breadcrumbs for each iteration.\n\n!?!../Documents/207_LIS.json:1000,383!?!\n\n<br>\n\n**Implementation**\n\n> **Note:** This approach is included because it is an intuitive starting point, and it will provide a better foundation for understanding the following approaches. However, due to its time complexity, it is not expected to pass all test cases. \n\n<iframe src=\"https://leetcode.com/playground/aX4MGcTF/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"aX4MGcTF\"></iframe>\n\n\n\n**Complexity**\n\n- Time Complexity: $$\\mathcal{O}(|E| + |V| ^ 2)$$ where $$|E|$$ is the number of dependencies, $$|V|$$ is the number of courses and $$d$$ is the maximum length of acyclic paths in the graph.\n    <br/>\n    - First of all, it would take us $$|E|$$ steps to build a graph in the first step.\n    <br/>\n    - For a single round of backtracking, in the worst case where all the nodes chained up in a line, it would take us maximum $$|V|$$ steps to terminate the backtracking.\n    ![pic](../Figures/207/207_chain.png)\n    <br/>\n    - Again, follow the above worst scenario where all nodes are chained up in a line, it would take us in total $$\\sum_{i=1}^{|V|}{i} = \\frac{(1+|V|)\\cdot|V|}{2}$$ steps to finish the check for all nodes.\n    <br/>\n    - As a result, the overall time complexity of the algorithm would be $$\\mathcal{O}(|E| + |V| ^ 2)$$.\n<br/>\n<br/>\n\n- Space Complexity: $$\\mathcal{O}(|E| + |V|)$$, with the same denotation as in the above time complexity.\n    </br>\n    - We built a graph data structure in the algorithm, which would consume $$|E| + |V|$$ space.\n    <br/>\n    - In addition, during the backtracking process, we employed a sort of bitmap (`path`) to keep track of all visited nodes, which consumes $$|V|$$ space.\n    <br/>\n    - Finally, since we implement the function in recursion, which would incur additional memory consumption on call stack. In the worst case where all nodes are chained up in a line, the recursion would pile up $$|V|$$ times.\n    <br/>\n    - Hence the overall space complexity of the algorithm would be $$\\mathcal{O}(|E| + 3\\cdot|V|) = \\mathcal{O}(|E| + |V|) $$.\n<br/>\n<br/>\n\n---\n#### Approach 2: Postorder DFS (Depth-First Search)\n\n**Intuition**\n\nAs one might notice that, with the above backtracking algorithm, we would visit certain nodes multiple times, which is not the most efficient way.\n\n![pic](../Figures/207/207_chain.png)\n\nFor instance, in the above graph where the nodes are chained up in a line, the backtracking algorithm would end up of being a nested two-level iteration over the nodes, which we could rewrite as the following pseudo code:\n\n```python\nfor i in range(0, len(nodes)):\n    # start from the current node to check if a cycle might be formed.\n    for j in range(i, len(nodes)):\n        isCyclic(nodes[j], courseDict, path)\n```\n\nOne might wonder that if there is a better algorithm that visits each node once and only once. And the answer is yes.\n\n_In the above example, for the first node in the chain, once we've done the check that there would be no cycle formed starting from this node, we don't have to do the same check for all the nodes in the downstream._\n\n>The rationale is that given a node, if the subgraph formed by all descendant nodes from this node has no cycle, then adding this node to the subgraph would not form a cycle either. \n\nFrom the perspective of graph traversal, the above rationale could be implemented with the strategy of **postorder DFS** (depth-first search), in which strategy we visit a node's descendant nodes before the node itself. \n\n**Algorithm**\n\nWe could implement the postorder DFS based on the above backtracking algorithm, by simply adding another bitmap (_i.e._ `checked[node_index]`) which indicates whether we have done the cyclic check starting from a particular node.\n\nHere are the breakdowns of the algorithm, where the first 2 steps are the same as in the previous backtracking algorithm.\n\n- Step 1). We build a graph data structure from the given list of course dependencies.\n<br/>\n- Step 2). We then enumerate each node (course) in the constructed graph, to check if we could form a dependency cycle starting from the node.\n<br/>\n- Step 3.1). We check if the current node has been *checked* before, otherwise we enumerate through its child nodes via backtracking, where we **_breadcrumb_** our path (_i.e._ mark the nodes we visited) to detect if we come across a previously visited node (hence a cycle detected). We also remove the breadcrumbs for each iteration.\n<br/>\n- Step 3.2). Once we visited all the child nodes (_i.e._ postorder), we mark the current node as `checked`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/cYVanVVi/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"cYVanVVi\"></iframe>\n\nNote, one could also use a single bitmap with 3 states such as  `not_visited`, `visited`, `checked`, rather than having two bitmaps as we did in the algorithm, though we argue that it might be clearer to have two separated bitmaps.\n\n**Complexity**\n\n- Time Complexity: $$\\mathcal{O}(|E| + |V|)$$ where $$|V|$$ is the number of courses, and $$|E|$$ is the number of dependencies.\n<br/>\n    - As in the previous algorithm, it would take us $$|E|$$ time complexity to build a graph in the first step.\n    <br/>\n    - Since we perform a postorder DFS traversal in the graph, we visit each vertex and each edge once and only once in the worst case, _i.e._ $$|E| + |V|$$.\n<br/>\n<br/>\n\n- Space Complexity: $$\\mathcal{O}(|E| + |V|)$$, with the same denotation as in the above time complexity.\n    </br>\n    - We built a graph data structure in the algorithm, which would consume $$|E| + |V|$$ space.\n    <br/>\n    - In addition, during the backtracking process, we employed two bitmaps (`path` and `visited`) to keep track of the visited path and the status of check respectively, which consumes $$2 \\cdot |V|$$ space.\n    <br/>\n    - Finally, since we implement the function in recursion, which would incur additional memory consumption on call stack. In the worst case where all nodes chained up in a line, the recursion would pile up $$|V|$$ times.\n    <br/>\n    - Hence the overall space complexity of the algorithm would be $$\\mathcal{O}(|E| + 4\\cdot|V|) = \\mathcal{O}(|E| + |V|)$$.\n<br/>\n<br/>\n\n---\n#### Approach 3: Topological Sort\n\n**Intuition**\n\nActually, the problem is also known as [topological sort](https://en.wikipedia.org/wiki/Topological_sorting) problem, which is to find a global order for all nodes in a DAG (_Directed Acyclic Graph_) with regarding to their dependencies.\n\nA linear algorithm was first proposed by [Arthur Kahn](https://en.wikipedia.org/wiki/Topological_sorting) in 1962, in his paper of [\"Topological order of large networks\"](https://dl.acm.org/doi/10.1145/368996.369025). The algorithm returns a topological order if there is any. Here we quote the pseudo code of the Kahn's algorithm from wikipedia as follows:\n\n```python\nL = Empty list that will contain the sorted elements\nS = Set of all nodes with no incoming edge\n\nwhile S is non-empty do\n    remove a node n from S\n    add n to tail of L\n    for each node m with an edge e from n to m do\n        remove edge e from the graph\n        if m has no other incoming edges then\n            insert m into S\n\nif graph has edges then\n    return error   (graph has at least one cycle)\nelse \n    return L   (a topologically sorted order)\n```\n\nTo better understand the above algorithm, we summarize a few points here:\n\n- In order to find a global order, we can start from those nodes which do not have any prerequisites (_i.e._ indegree of node is zero), we then incrementally add new nodes to the global order, following the dependencies (edges).\n<br/>\n- Once we follow an edge, we then remove it from the graph.\n<br/>\n- With the removal of edges, there would more nodes appearing without any prerequisite dependency, in addition to the initial list in the first step.\n<br/>\n- The algorithm would terminate when we can no longer remove edges from the graph. There are two possible outcomes:\n    <br/>\n    - 1). If there are still some edges left in the graph, then these edges must have formed certain cycles, which is similar to the deadlock situation. It is due to these cyclic dependencies that we cannot remove them during the above processes.\n    <br/>\n    - 2). Otherwise, _i.e._ we have removed all the edges from the graph, and we got ourselves a topological order of the graph.\n    <br/>\n\n**Algorithm**\n\nFollowing the above intuition and pseudo code, here we list some sample implementations.\n\n!?!../Documents/207_RES.json:1000,353!?!\n\n<br>\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/9j6H52Hu/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9j6H52Hu\"></iframe>\n\nNote that we could use different types of containers, such as Queue, Stack or Set, to keep track of the nodes that have no incoming dependency, _i.e._ `indegree = 0`. Depending on the type of container, the resulting topological order would be different, though they are all valid.\n\n\n**Complexity**\n\n- Time Complexity: $$\\mathcal{O}(|E| + |V|)$$ where $$|V|$$ is the number of courses, and $$|E|$$ is the number of dependencies.\n<br/>\n    - As in the previous algorithm, it would take us $$|E|$$ time complexity to build a graph in the first step.\n    <br/>\n    - Similar with the above postorder DFS traversal, we would visit each vertex and each edge once and only once in the worst case, _i.e._ $$|E| + |V|$$.\n    <br/>\n    - As a result, the overall time complexity of the algorithm would be $$\\mathcal{O}(2\\cdot|E| + |V|) = \\mathcal{O}(|E| + |V|)$$.\n<br/>\n<br/>\n\n- Space Complexity: $$\\mathcal{O}(|E| + |V|)$$, with the same denotation as in the above time complexity.\n    </br>\n    - We built a graph data structure in the algorithm, which would consume $$|E| + |V|$$ space.\n    <br/>\n    - In addition, we use a container to keep track of the courses that have no prerequisite, and the size of the container would be bounded by $$|V|$$.\n    <br/>\n    - As a result, the overall space complexity of the algorithm would be $$\\mathcal{O}(|E| + 2\\cdot|V|) = \\mathcal{O}(|E| + |V|)$$.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "846",
            "count": 136,
            "average": "3.816",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "course-schedule",
    "playgroundData": {
        "aX4MGcTF": {
            "playground": {
                "testcaseInput": "",
                "name": "course-schedule-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "cYVanVVi": {
            "playground": {
                "testcaseInput": "",
                "name": "course-schedule-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "9j6H52Hu": {
            "playground": {
                "testcaseInput": "",
                "name": "course-schedule-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}