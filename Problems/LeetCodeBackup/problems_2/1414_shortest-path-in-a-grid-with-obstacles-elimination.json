{
    "id": "1414",
    "question": {
        "questionId": "1414",
        "questionFrontendId": "1293",
        "boundTopicId": null,
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "content": "<p>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacle). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.</p>\n\n<p>Return <em>the minimum number of <strong>steps</strong> to walk from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code><em> given that you can eliminate <strong>at most</strong> </em><code>k</code><em> obstacles</em>. If it is not possible to find such walk return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg\" style=\"width: 244px; height: 405px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2).\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> We need to eliminate at least two obstacles to find such a walk.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 40</code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 2502,
        "dislikes": 44,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Shortest Path to Get Food\", \"titleSlug\": \"shortest-path-to-get-food\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Obstacle Removal to Reach Corner\", \"titleSlug\": \"minimum-obstacle-removal-to-reach-corner\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]]\n1\n[[0,1,1],[1,1,1],[1,0,0]]\n1",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 84}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Pinterest\", \"slug\": \"pinterest\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"tiktok\", \"slug\": \"tiktok\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 3}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int shortestPath(vector<vector<int>>& grid, int k) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int shortestPath(int[][] grid, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def shortestPath(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint shortestPath(int** grid, int gridSize, int* gridColSize, int k){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int ShortestPath(int[][] grid, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar shortestPath = function(grid, k) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} grid\n# @param {Integer} k\n# @return {Integer}\ndef shortest_path(grid, k)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func shortestPath(_ grid: [[Int]], _ k: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func shortestPath(grid [][]int, k int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def shortestPath(grid: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun shortestPath(grid: Array<IntArray>, k: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn shortest_path(grid: Vec<Vec<i32>>, k: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $k\n     * @return Integer\n     */\n    function shortestPath($grid, $k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function shortestPath(grid: number[][], k: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (shortest-path grid k)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec shortest_path(Grid :: [[integer()]], K :: integer()) -> integer().\nshortest_path(Grid, K) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec shortest_path(grid :: [[integer]], k :: integer) :: integer\n  def shortest_path(grid, k) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"114K\", \"totalSubmission\": \"261.5K\", \"totalAcceptedRaw\": 114005, \"totalSubmissionRaw\": 261549, \"acRate\": \"43.6%\"}",
        "hints": [
            "Use BFS.",
            "BFS on (x,y,r) x,y is coordinate, r is remain number of obstacles you can remove."
        ],
        "solution": {
            "id": "1165",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": "ac",
        "sampleTestCase": "[[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]]\n1",
        "metaData": "{\n  \"name\": \"shortestPath\",\n  \"params\": [\n    {\n      \"name\": \"grid\",\n      \"type\": \"integer[][]\"\n    },\n    {\n      \"type\": \"integer\",\n      \"name\": \"k\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1165",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Overview\n\nLike many grid search problems where the goal is to find the shortest path, the key to solve this problem is to apply the Breadth-First Search algorithm, as opposed to the Depth-First Search (DFS) algorithm.\nIn this article, we will start with a classic BFS solution.\nThen on top of BFS, we will introduce a heuristic (greedy) strategy to speed up the algorithm, which eventually transforms our classic BFS algorithm into another classic algorithm called the [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\n---\n#### Approach 1: BFS (Breadth-First Search)\n\n**Intuition**\n\nIn this problem, we must traverse the grid to reach a *target* cell, while the grid contains some obstacles.\nIf the problem ends here, one could probably tell that this is a classic grid search problem, _e.g._ the problem of [1730. Shortest Path to Get Food](https://leetcode.com/problems/shortest-path-to-get-food/) fits the bill exactly.\n\nHowever, the particularity of this problem is that one can eliminate obstacles to a certain extent.\nThis constraint complicates our problem.\nFirst of all, if there were no limit on how many obstacles we can eliminate, then the shortest distance to reach the target cell would be the [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry) between the starting cell and the target cell.\nLikewise, if the quota to eliminate the obstacles is greater than the Manhattan distance, then the shortest distance is guaranteed to be the Manhattan distance.\nHowever, we do have a limit on the number of obstacles that we can eliminate along the way.\nAs a result, rather than taking a *straightforward* path to reach the target, we have to take some _detour_ in certain cases, which implies that we need to **explore** all possible directions while respecting the constraint.\n\n>By *exploring*, we refer to the BFS strategy, rather than DFS.\nThe BFS algorithm works like detecting an object with sonar.\nA sound wave propagages in all directions with equal speed.\nAt any given moment, all the objects that the sound wave reaches have the same distance to the source of the sound.\nOn the other hand, as soon as the sound wave reaches the object, the path is guaranteed to be the **shortest**, since the distance is proportional to the time, the more time it takes, the longer the distance is.\n\n![BFS demo](../Figures/1293/1293_bfs.png)\n\nGiven the above intuition of the BFS algorithm, we can rest assured that as soon as we reach the target, the path that leads to the target is the shortest.\nThis is also the rationale for why we should employ the BFS strategy rather than DFS.\n\n**Algorithm**\n\nIn the canonical implementation of the BFS algorithm, we would employ a **queue** data structure to maintain the order of exploration.\nEach element in the queue normally contains two pieces of information: the current position and the distance traveled so far from the starting point.\n\n>However, in our problem here, we need another piece of information, which is the **remaining** quota that we can use to eliminate the obstacles.\n\nTogether with the coordinates, the obstacle elimination quota uniquely constitutes a **_state_** during our BFS exploration.\nFor example, in the following graph, we demonstrate two different paths between the start cell and an intermediate cell.\n\n![BFS with two paths](../Figures/1293/1293_bfs_two_paths.png)\n\nWithout the obstacle elimination quota, we would only visit the intermediate cell once, while only one of the two paths can lead us to the target, since in one of the paths we don't have sufficient quota to get through.\nTherefore, it is critical to keep the quota information, so that we can revisit the same cell with different quotas.\n\n**Implementation**\n\nThere are several ways to implement a BFS algorithm.\nWe provide [a template](https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/) to do so in the Queue and Stack Explore Card.\n\nIn this section, we provide some sample implementations together with the tweak we mentioned in the above section.\n\nWe can break down the algorithm into the following steps:\n\n1. The main body of the BFS algorithm consists of a loop around a `queue`, as well as a set called `seen` which keeps track of all the states visited along the way so that we don't visit the same _state_ twice. A _state_ refers to a unique combination of coordinates and the remaining quota.\n\n2. At each iteration of the loop, we pop out one element from the queue. The element contains the distance from the starting point as well as the current `state` which includes the current coordinate and the remaining quotas to eliminate obstacles.\n\n3. Within the same iteration, we evaluate the next moves starting from the popped element. Each move results in a new state and the state is valid if it is within the grid boundaries and has not been visited before. Each valid state is pushed into the queue for later iterations. Meanwhile, we also need to mark the state as _visited_ by adding the state to the `seen` states set.\n\n4. At any iteration, if we have reached our `target`, we can return immediately from the loop.\n\n**_Note:_** before running the BFS traversal, we also perform a quick check to see if we have sufficient quotas to take the most direct path from start to finish regardless of the number of obstacles.\nIf so, the shortest distance to reach the target is the [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry) between the starting cell and the target cell.\n\n<iframe src=\"https://leetcode.com/playground/GwTQYLYJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"GwTQYLYJ\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the number of cells in the grid, and $$K$$ be the quota to eliminate obstacles.\n\n- Time Complexity: $$O(N \\cdot K)$$\n\n    - We conduct a BFS traversal in the grid. In the worst case, we will visit each cell in the grid. And for each cell, at most, it will be visited $$K$$ times, with different quotas of obstacle elimination.\n\n    - Thus, the overall time complexity of the algorithm is $$O(N \\cdot K)$$.\n\n- Space Complexity: $$O(N \\cdot K)$$\n\n    - We used a `queue` to maintain the order of visited states. In the worst case, the queue will contain the majority of the possible states that we need to visit, which in total is $$N \\cdot K$$ as we discussed in the time complexity analysis. Thus, the space complexity of the `queue` is $$O(N \\cdot K)$$.\n\n    - Other than the `queue`, we also used a set variable (named `seen`) to keep track of all the visited states along the way. Same as the `queue`, the space complexity of this set is also $$O(N \\cdot K)$$.\n\n    - To sum up, the overall space complexity of the algorithm is $$O(N \\cdot K)$$.\n\n\n---\n#### Approach 2: A* (A Star) Algorithm\n\n**Intuition**\n\nIn the above BFS approach, one might notice that when at any specific position, we would _systematically_ explore the surrounding neighbors in all four directions, due to the nature of BFS.\n\nHowever, the action might seem *conterintuitive* or **sub-optimal**.\nSince the destination is located in the lower-right corner of the grid, in order to find the shortest path, the optimal directions to explore should be either **_right_** or **_down_**, rather than left or up.\n\n![BFS with two paths](../Figures/1293/1293_next_steps.png)\n\nAs depicted in the above image, the optimal steps to explore should be the ones in green (right and down), rather than the ones in orange.\n\n>Therefore, one idea to improve our BFS approach is to **_prioritize_** exploring the most _promising_ directions at each step. Through prioritization, we can speed up the algorithm by reducing the time spent exploring less promising paths.\n\nThis idea leads us to the [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm), which is yet another classic path finding algorithm that uses a **_heuristic_**.\n\n\nNote: we cannot **exclude** (or prune) those less promising directions, otherwise we might miss the correct path because sometimes we have to take a **_detour_** in order to reach the destination.\n\n**Algorithm**\n\nA* (pronounced as A star) is also known as an [informed search algorithm](https://en.wikipedia.org/wiki/Search_algorithm#Informed_search) or [best-first search](https://en.wikipedia.org/wiki/Best-first_search).\nBecause at each step of exploration, it makes the **_best_** and **_informed_** decision on the next steps, _i.e._ it _prioritizes_ the steps that are the most promising.\nSpecifically, this prioritization strategy can be expressed as _A* selects a path that minimizes the following function_:$$f(n) = g(n) + h(n)$$\n\n- $$n$$: a specific step during the exploration.\n\n- $$g(n)$$: the cost to reach the step $$n$$. Here, the cost refers to the distance traveled so far to the step $$n$$.\n\n- $$h(n)$$: a heuristic **_estimation_** on the cost to reach the destination from the step $$n$$. Here, the cost refers to the distance ahead.\n\n- $$f(n)$$: the _estimated_ total cost to reach the destination if one takes the step $$n$$.\n\n>With the defined function, A* algorithm has a deterministic way to **_evaluate_** each potential step, and then make what it believes to be the _best_ decision at each step.\n\nThe problem boils down to defining the above functions for our scenario, in order to apply the A* algorithm.\nSpecifically, $$g(n)$$ would be the number of steps that one has taken to reach $$n$$.\nAnd $$h(n)$$ would be the [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry) from $$n$$ to the destination, which is the **_shortest_** path to reach the destination.\n\n>The most important property of our heuristic $$h(n)$$ function is that the function should be [admissible](https://en.wikipedia.org/wiki/Admissible_heuristic), _i.e._ it never **_overestimates_** the cost.\nOtherwise, it could not guarantee that the path we find is the shortest one.\n\nTo understand the _admissible_ property, let us take a metaphor. In a football tournament, we want to select the best team in the end.\nIf we __overestimate__ the incompetence of a team, _i.e._ we downplay the potential of the team, we might _prematurely_ disqualify or ignore the team.\nAs a result, we may predict that a _not-so-good_ team will win the championship, while in reality, the team we disqualified or ignored happens to be the best team.\n\n\n**Implementation**\n\nThe A* algorithm provides a more optimized path selection strategy, on top of the BFS approach.\nTherefore, we can implement the A* algorithm while keeping the bulk of our previous BFS approach intact.\nWe will still use a `queue` to keep track of the order of visits.\nAnd we will still use a `set` to keep track of the visited states so that we do not revisit any previously explored paths.\n\nAdditionally, here are the modifications that we will make:\n\n- Rather than using a normal queue, we use a [priority queue](https://en.wikipedia.org/wiki/Priority_queue) to store the order of visits. The order of visits is based on the estimated total cost function $$f(n)$$ that we defined. With the priority queue, the step that has potentially the _lowest_ cost will be visited first.\n\n- For each element in the queue, we add one more piece of information which is the _**estimated total cost**_ to reach the destination at each step. This estimation will be used to prioritize each potential next step.\n\n- We add another **_heuristic condition_** that allows us to determine the length of the shortest path without exploration. The condition is as follows:\n\n  - At any step, if the remaining quota to eliminate the obstacles is larger than the length of the estimated shortest path (_i.e._ manhattan distance between the current step and the destination), then the length of the remaining path is the manhattan distance.\n\n  - The condition can also be interpreted as if we have sufficient capacity to remove any obstacle along the way, we will simply take the shortest path to reach the destination, without the need for further exploration.\n\n  - We apply the condition at the beginning of each iteration of the loop.\n\n\n<iframe src=\"https://leetcode.com/playground/JGQTfNWm/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"JGQTfNWm\"></iframe>\n\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the number of cells in the grid, and $$K$$ be the quota to eliminate obstacles.\n\n- Time Complexity: $$O\\big(N \\cdot K \\cdot \\log{(N \\cdot K)} \\big)$$\n\n    - We conduct a BFS traversal in the grid. In the worst case, we will visit each cell in the grid. And each cell can be visited at most $$K$$ times, with different quotas of obstacle elimination. Therefore, the total number of visits would be $$N \\cdot K$$.\n\n    - For each visit, we perform one push and one pop operation in the priority queue, which takes $$O\\big(\\log{(N \\cdot K)} \\big)$$ time.\n\n    - Thus, the overall time complexity of the algorithm is $$O\\big(N \\cdot K \\cdot \\log{(N \\cdot K)} \\big)$$.\n\n    - Although the upper bound for the time complexity of the this algorithm is higher than the previous BFS approach, on average, the A* algorithm will outperform the previous BFS approach when there exists any relatively direct path from the source to the target.\n\n\n- Space Complexity: $$O(N \\cdot K)$$\n\n    - We use a `queue` to maintain the order of visited states. In the worst case, the queue could contain the majority of the possible states that we must visit, which in total is $$N \\cdot K$$, as we discussed in the time complexity analysis. Thus, the space complexity of the `queue` is $$O(N \\cdot K)$$.\n\n    - Other than the `queue`, we also used a set variable (named `seen`) to keep track of all the states we visited along the way. Again, the space complexity of this set is also $$O(N \\cdot K)$$.\n\n    - To sum up, the overall space complexity of the algorithm is $$O(N \\cdot K)$$.\n\n\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1170",
            "count": 116,
            "average": "4.897",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "shortest-path-in-a-grid-with-obstacles-elimination",
    "playgroundData": {
        "GwTQYLYJ": {
            "playground": {
                "testcaseInput": "",
                "name": "shortest-path-in-a-grid-with-obstacles-elimination-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "JGQTfNWm": {
            "playground": {
                "testcaseInput": "",
                "name": "shortest-path-in-a-grid-with-obstacles-elimination-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}