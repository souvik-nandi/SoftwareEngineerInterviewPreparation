{
    "id": "986",
    "question": {
        "questionId": "986",
        "questionFrontendId": "949",
        "boundTopicId": null,
        "title": "Largest Time for Given Digits",
        "titleSlug": "largest-time-for-given-digits",
        "content": "<p>Given an array <code>arr</code> of 4 digits, find the latest 24-hour time that can be made using each digit <strong>exactly once</strong>.</p>\n\n<p>24-hour times are formatted as <code>&quot;HH:MM&quot;</code>, where <code>HH</code> is between <code>00</code> and <code>23</code>, and <code>MM</code> is between <code>00</code> and <code>59</code>. The earliest 24-hour time is <code>00:00</code>, and the latest is <code>23:59</code>.</p>\n\n<p>Return <em>the latest 24-hour time in <code>&quot;HH:MM&quot;</code> format</em>. If no valid time can be made, return an empty string.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,2,3,4]\n<strong>Output:</strong> &quot;23:41&quot;\n<strong>Explanation:</strong> The valid 24-hour times are &quot;12:34&quot;, &quot;12:43&quot;, &quot;13:24&quot;, &quot;13:42&quot;, &quot;14:23&quot;, &quot;14:32&quot;, &quot;21:34&quot;, &quot;21:43&quot;, &quot;23:14&quot;, and &quot;23:41&quot;. Of these times, &quot;23:41&quot; is the latest.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [5,5,5,5]\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There are no valid 24-hour times as &quot;55:55&quot; is not valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>arr.length == 4</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 9</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 571,
        "dislikes": 926,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[1,2,3,4]\n[5,5,5,5]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Enumeration",
                "slug": "enumeration",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"LiveRamp\", \"slug\": \"liveramp\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    string largestTimeFromDigits(vector<int>& arr) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public String largestTimeFromDigits(int[] arr) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def largestTimeFromDigits(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: str\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nchar * largestTimeFromDigits(int* arr, int arrSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public string LargestTimeFromDigits(int[] arr) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} arr\n * @return {string}\n */\nvar largestTimeFromDigits = function(arr) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} arr\n# @return {String}\ndef largest_time_from_digits(arr)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func largestTimeFromDigits(_ arr: [Int]) -> String {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func largestTimeFromDigits(arr []int) string {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def largestTimeFromDigits(arr: Array[Int]): String = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun largestTimeFromDigits(arr: IntArray): String {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn largest_time_from_digits(arr: Vec<i32>) -> String {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return String\n     */\n    function largestTimeFromDigits($arr) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function largestTimeFromDigits(arr: number[]): string {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (largest-time-from-digits arr)\n  (-> (listof exact-integer?) string?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec largest_time_from_digits(Arr :: [integer()]) -> unicode:unicode_binary().\nlargest_time_from_digits(Arr) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec largest_time_from_digits(arr :: [integer]) :: String.t\n  def largest_time_from_digits(arr) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"72.9K\", \"totalSubmission\": \"206.1K\", \"totalAcceptedRaw\": 72909, \"totalSubmissionRaw\": 206137, \"acRate\": \"35.4%\"}",
        "hints": [],
        "solution": {
            "id": "992",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,2,3,4]",
        "metaData": "{\n  \"name\": \"largestTimeFromDigits\",\n  \"params\": [\n    {\n      \"name\": \"arr\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"string\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "992",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Overview\n\nIf we add one statement in the problem description that one could use the utility function in their preferred programming language to generate all permutations from a given list, _i.e._ `itertools.permutations(list)` in Python, then many of you would agree that this is definitely an **easy** problem.\n\n>Indeed, if we have all the permutations from the given list of digits, we could simply **_enumerate_** each of the permutations to see if we could build a valid time.\n\nAt the end of the enumeration, it would be easy to get the maximum of all valid times.\n\nIn the following sections, we would first present a solution with the built-in **_permutation_** utility.\n\nThen, in case the interviewer insists that one should not use the permutation utility, we would present another solution where we **_hand-craft_** the permutations via enumeration.\n\nAt the end, we would also present a more _generic_ and _efficient_ algorithm to generate permutations via **backtracking**.\n\n\n---\n#### Approach 1: Enumerate the Permutations\n\n**Intuition**\n\n>As we stated before, once we have the permutations at our disposal, the idea is simple: we iterate through all possible permutations of the given 4 digits, and for each permutation, we check if we could build a time out of it in the 24H format (_i.e._ `HH:MM`).\n\nThere are two conditions that we should meet, in order to construct a valid time format:\n\n- `HH < 24`: The first two digits, _i.e._ the hour, should be less than 24.\n\n- `MM < 60`: The last two digits, _i.e._ the minute, should be less than 60.\n\n**Algorithm**\n\n- The algorithm can be implemented in a single loop over all the possible permutations for the given 4 digits.\n\n- At each iteration, we check if we could build a valid time based on the conditions we presented before.\n\n- Meanwhile, we use a variable (_i.e._`max_time`) to keep track of the maximum valid time that we've seen during the iteration.\n\n\n<iframe src=\"https://leetcode.com/playground/YNpTqvyH/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"YNpTqvyH\"></iframe>\n\n\n**Note:** \n\n- We did not provide a solution in Java, since in Java we don't have a built-in function that can do the permutation.\n\n- Both the [itertools.permutations](https://docs.python.org/3/library/itertools.html#itertools.permutations) API in Python and the [next_permutation()](https://en.cppreference.com/w/cpp/algorithm/next_permutation) in C++ can generate the permutations in _**lexicographic**_ ordering.\nAs a result, one can order the input array in descending order, rather than iterating all possible permutations, one can have an **early stop** as soon as we find the first valid time, which would also be the largest one, since the permutations are generated in lexicographic ordering.\n\n**Complexity Analysis**\n\n- Time Complexity: $$\\mathcal{O}(1)$$ \n\n    - For an array of length $$N$$, the number of permutations would be $$N!$$.\n    In our case, the input is an array of 4 digits. Hence, the number of permutations would be $$4! = 4 * 3 * 2 * 1 = 24$$.\n\n    - Since the length of the input array is fixed, it would take the same constant time to generate its permutations, regardless the content of the array.\n    Therefore, the time complexity to generate the permutations would be $$\\mathcal{O}(1)$$.\n\n    - In the above program, each iteration takes a constant time to process.\n    Since the total number of permutations is fixed (constant), the time complexity of the loop in the algorithm is constant as well, _i.e._ $$24 \\cdot \\mathcal{O}(1) = \\mathcal{O}(1)$$.\n\n    - To sum up, the overall time complexity of the algorithm would be $$\\mathcal{O}(1) + \\mathcal{O}(1) = \\mathcal{O}(1)$$.\n\n- Space Complexity: $$\\mathcal{O}(1)$$\n\n    - In the algorithm, we keep the permutations for the input digits, which are in total 24, _i.e._ a constant number regardless the input.\n\n\n---\n#### Approach 2: Permutation via Enumeration\n\n**Intuition**\n\nWe are asked to generate permutations of four digits, _i.e._ $$D_1D_2D_3D_4$$ from a given array _e.g._ `A=[1, 2, 3, 4]`.\n\nEach of the digit in the permutation, say $$D_1$$, can come from any of the elements in the input array, _e.g._ $$D_1 = 1$$ or $$D_1 = 2$$ _etc_.\n\n>An intuitive idea would be that we can run nested loops to generate combination of digits, one loop per digit. At the end of loops, we **filter** out those invalid combinations, _i.e._ combinations that contains duplicate elements from the input array.\nThe remaining combinations are actually permutations by definition.\n\n**Algorithm**\n\n- Normally, we should have 4 nested loops, one loop per digit.\nBut once we choose 3 non-duplicate elements from the input array, the last digit of the permutation is then fixed. \nAs a result, we could reduce the loops down to 3-level nested loops, rather than 4.\n\n- At the end of loops, we check if we could build a valid time out of the _permutation_ we generate.\n\n- Meanwhile, we use a variable (_i.e._`max_time`) to keep track of the maximum valid time that we've seen during the iteration.\n\n<iframe src=\"https://leetcode.com/playground/Tht9GjVq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Tht9GjVq\"></iframe>\n\n\n**Complexity Analysis**\n\n- Time Complexity: $$\\mathcal{O}(1)$$ \n\n    - We have a 3-level nested loops, each loop would have 4 iterations. As a result, the total number of iterations is $$4 * 4 * 4 = 64$$. \n\n    - Since the length of the input array is fixed, it would take the same constant time to generate its permutations, regardless the content of the array.\n    Therefore, the time complexity to generate the permutations would be $$\\mathcal{O}(1)$$.\n\n    - Note that the total number of permutations is $$4! = 4 * 3 * 2 * 1 = 24$$. Yet, it takes us 64 iterations to generate the permutations, which is not the most efficient algorithm as one can see.\n    As the size of array grows, this discrepancy would grow exponentially.\n\n\n- Space Complexity: $$\\mathcal{O}(1)$$\n\n    - In the algorithm, we keep a variable to keep track of the maximum time, as well as some intermediates variables for the function.\n    Since the size of the input array is fixed, the total size of the local variables are bounded as well.  \n\n\n---\n#### Approach 3: Permutation via Backtracking\n\n**Intuition**\n\nAs we discussed before, the **_hard_** part of the problem is not enumerating over the permutations, but actually constructing the permutations itself.\nFor practice, one can implement the permutation algorithms on these two problem: [permutations](https://leetcode.com/problems/permutations/) and [next permutation](https://leetcode.com/problems/next-permutation/).\n\nIn the previous approach, we've presented a naive way to implement the permutation, which is not the most efficient algorithm obviously.\n\nThere have been several classic algorithms to generate the permutations.\nFor instance, B.R. Heap proposed an algorithm (named [Heap's algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)) in 1963, which minimizes the movements of elements.\nIt was still considered as the most efficient algorithm later in 1977.\n\nHere we present an algorithm, which might not be the most efficient one but arguably more intuitive.\n>It is based on the ideas of **divide-and-conquer**, **swapping** and **backtracking**.\n\n- First of all, the algorithm follows the paradigm of **_divide and conquer_**. Given an array `A[0:n]`, once we fix on the arrangements of the prefix subarray `A[0:i]`, we then reduce the problem down to a subproblem, _i.e._ generating the permutations for the postfix subarray `A[i:n]`.\n\n- In order to fix on a prefix subarray, we apply the operation of **swapping**, where we swap the elements between a fixed position and an alternative position.\n\n![divide and conquer](../Figures/949/949_divide_and_conquer.png)\n\n- Finally, once we explore the permutations after a swapping operation, we then revert the choice (_i.e._ **backtracking**) by performing the same swapping, so that we could have a clean slate to start all over again.\n\n![backtracking](../Figures/949/949_backtracking.png)\n\n\n**Algorithm**\n\nNow we can put together all the ideas that we presented before, and implement the permutation algorithm.\n\nHere we implement the permutation algorithm as the function `permutate(array, start)` which generates the permutations for the postfix subarray of `array[start:len(array)]`.\nOnce we implement the function, we invocate it as `permutate(array, 0)` to generate all the permutations from the array.\n\nAs a preview, once implemented, the function will unfold itself as in the following example.\n\n![DFS](../Figures/949/949_DFS.png)\n\nFor instance, starting from the root node, first we try to fix on the first element in the final combination, which we try to switch the element between the first position in the array and each of the positions in the array.\nSince there are 3 possible candidates, we _branch_ out in 3 directions from the root node.\n\nThe function can be implemented in **_recursion_**, due to its nature of divide-and-conquer and backtracking.\n\n- The base case of the function would be `start == len(array)`, where we've fixed all the prefixes and reached the end of the combination.\nIn this case, we simply add the current `array` as one of the results of combination.\n\n- When we still have some postfix that need to be permutated, _i.e._ `start < len(array)`, we then apply _backtracking_ to try out all possible permutations for the postfixes, _i.e._ `permutate(array, start+1)`.\nMore importantly, we need to swap the `start` element with each of the elements following the start index (including the start element).\nThe goal is two-fold: 1). we generate different prefixes for the final combination; 2). we generate different lists of candidates in the postfixes, so that the permutations generated from the postfixes would vary as well.\n\n- At the end of backtracking, we will swap the `start` element back to its original position, so that we can try out other alternatives.\n\n- For each permutation, we apply the same logic as in the previous approach, _i.e._ check if the permutation is of valid time and update the maximum time.\n\n<iframe src=\"https://leetcode.com/playground/mP6R4iM5/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mP6R4iM5\"></iframe>\n\n\n\n**Complexity Analysis**\n\n- Time Complexity: $$\\mathcal{O}(1)$$ \n\n    - Since the length of the input array is fixed, it would take the same constant time to generate its permutations, regardless the content of the array.\n    Therefore, the time complexity to generate the permutations would be $$\\mathcal{O}(1)$$.\n\n    - Therefore, same as the previous approach, the overall time complexity of the algorithm would be $$\\mathcal{O}(1)$$.\n\n- Space Complexity: $$\\mathcal{O}(1)$$\n\n    - In the algorithm, we keep the permutations for the input digits, which are in total 24, _i.e._ a constant number regardless the input.\n\n    - Although the recursion in the algorithm could incur additional memory consumption in the function call stack, the maximal number of recursion is bounded by the size of the combination.\n    Hence, the space overhead for the recursion in this problem is constant.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "937",
            "count": 42,
            "average": "4.452",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "largest-time-for-given-digits",
    "playgroundData": {
        "YNpTqvyH": {
            "playground": {
                "testcaseInput": "",
                "name": "largest-time-for-given-digits-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "Tht9GjVq": {
            "playground": {
                "testcaseInput": "",
                "name": "largest-time-for-given-digits-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "mP6R4iM5": {
            "playground": {
                "testcaseInput": "",
                "name": "largest-time-for-given-digits-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}