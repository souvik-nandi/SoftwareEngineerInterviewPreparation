{
    "id": "1371",
    "question": {
        "questionId": "1371",
        "questionFrontendId": "1249",
        "boundTopicId": null,
        "title": "Minimum Remove to Make Valid Parentheses",
        "titleSlug": "minimum-remove-to-make-valid-parentheses",
        "content": "<p>Given a string <font face=\"monospace\">s</font> of <code>&#39;(&#39;</code> , <code>&#39;)&#39;</code> and lowercase English characters.</p>\n\n<p>Your task is to remove the minimum number of parentheses ( <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>, in any positions ) so that the resulting <em>parentheses string</em> is valid and return <strong>any</strong> valid string.</p>\n\n<p>Formally, a <em>parentheses string</em> is valid if and only if:</p>\n\n<ul>\n\t<li>It is the empty string, contains only lowercase characters, or</li>\n\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li>\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;lee(t(c)o)de)&quot;\n<strong>Output:</strong> &quot;lee(t(c)o)de&quot;\n<strong>Explanation:</strong> &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a)b(c)d&quot;\n<strong>Output:</strong> &quot;ab(c)d&quot;\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;))((&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> An empty string is also valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either<code>&#39;(&#39;</code> , <code>&#39;)&#39;</code>, or lowercase English letter<code>.</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 5016,
        "dislikes": 90,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Minimum Number of Swaps to Make the String Balanced\", \"titleSlug\": \"minimum-number-of-swaps-to-make-the-string-balanced\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check if a Parentheses String Can Be Valid\", \"titleSlug\": \"check-if-a-parentheses-string-can-be-valid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "\"lee(t(c)o)de)\"\n\"a)b(c)d\"\n\"))((\"",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Stack",
                "slug": "stack",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 202}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 8}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 18}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 3}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"tiktok\", \"slug\": \"tiktok\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    string minRemoveToMakeValid(string s) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public String minRemoveToMakeValid(String s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minRemoveToMakeValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nchar * minRemoveToMakeValid(char * s){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public string MinRemoveToMakeValid(string s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string}\n */\nvar minRemoveToMakeValid = function(s) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String} s\n# @return {String}\ndef min_remove_to_make_valid(s)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minRemoveToMakeValid(_ s: String) -> String {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minRemoveToMakeValid(s string) string {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minRemoveToMakeValid(s: String): String = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minRemoveToMakeValid(s: String): String {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn min_remove_to_make_valid(s: String) -> String {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function minRemoveToMakeValid($s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minRemoveToMakeValid(s: string): string {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec min_remove_to_make_valid(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmin_remove_to_make_valid(S) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec min_remove_to_make_valid(s :: String.t) :: String.t\n  def min_remove_to_make_valid(s) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"445.8K\", \"totalSubmission\": \"679.1K\", \"totalAcceptedRaw\": 445791, \"totalSubmissionRaw\": 679108, \"acRate\": \"65.6%\"}",
        "hints": [
            "Each prefix of a balanced parentheses has a number of open parentheses greater or equal than closed parentheses, similar idea with each suffix.",
            "Check the array from left to right, remove characters that do not meet the property mentioned above, same idea in backward way."
        ],
        "solution": {
            "id": "822",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "\"lee(t(c)o)de)\"",
        "metaData": "{\n  \"name\": \"minRemoveToMakeValid\",\n  \"params\": [\n    {\n      \"name\": \"s\",\n      \"type\": \"string\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"string\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "843",
            "date": "2022-03-15",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "822",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Approach 1: Using a Stack and String Builder\n\n**Intuition**\n\nLet's start by looking at what it means for the parentheses of a string to be *valid*.\n\nThe parentheses in a string are balanced *if and only if* these 2 conditions are met:\n\n1. There are the same number of `\"(\"` and `\")\"` in the string.\n2. Scanning through the string from left to right and counting how many `\"(\"` and `\")\"` there are so far, there should never be a time where there are *more* `\")\"` than `\"(\"`. We call `count(\"(\") - count(\")\")` the *balance* of the string..\n\nHere's a simple pseudocode algorithm that checks for these conditions by scanning through the string and incrementing `balance` each time it sees a `\"(\"`, and decrementing each time it sees `\")\"`. If at any point the balance is negative, which can only happen if we've seen more `\")\"` than `\"(\"`, then it returns `false`. If we get to the end, then it returns `true` only if the balance is `0`, which means we've seen the same number of `\"(\"` as `\")\"`.\n\n```\nfunction is_balanced_parentheses(string)\n    balance = 0\n    for each char in the string\n        if char == \"(\"\n            balance = balance + 1\n        if char == \")\"\n            balance = balance - 1\n        if balance < 0\n            return false\n    return balance == 0\n```\n\nFor example, `\"L(ee)(t(()co)d)e\"` is a *balanced* string. We'll use a table to show how the balance changes at each point in the string.\n\n![A diagram showing that L(ee)(t(()co)d)e is a balanced string.](../Figures/1249/balance_example_1.png)\n\nThe string `\"L(e)e(t)c)o)(d)e\"` is invalid because the *balance goes negative*.\n\n![A diagram showing that L(e)e(t)c)o)(d)e is an unbalanced string.](../Figures/1249/balance_example_2.png)\n\nAnd the string `\"L(e)e(t()c(o(d)e\"` is invalid because the balance *is not 0 at the end*.\n\n![A diagram showing that L(e)e(t()c(o(d)e is an unbalanced string.](../Figures/1249/balance_example_3.png)\n\nThe question asks us to remove the ***minimum number of parentheses*** to make the string valid. So, how can we use the tricks above to achieve this? For starters, we know we'll need to remove any `\")\"` that we encountered when balance was already 0. It would be impossible to remove less `\")\"`, because there are not enough `\"(\"` before them.\n\nTaking the 2nd example from above, here's what we get when we delete `\")\"` that would have made the balance go negative.\n\n![A diagram showing the balancing of L(e)e(t)c)o)(d)e.](../Figures/1249/balance_example_4.png)\n\nBecause we now finish with a zero balance, we know the string is valid.\n\nHowever, this isn't the full solution. Take a look at this example where we have removed any `\")\"` from `\"L(e)))et((co)d(e\"` that would have caused a negative balance, but we still *end with a non-zero balance*.\n\n![A diagram showing an attempt to balance L(e)))et((co)d(e](../Figures/1249/balance_example_5.png)\n\nA non-zero balance at the end occurs when there were `\"(\"` that were not closed with a `\")\"`. Clearly, we'll need to remove some `\"(\"` to reduce the balance at the end down to 0. But which should we remove? What will happen if we choose 2 random ones?\n\nHere is the string from above. The 2 `\"(\"` we have randomly chosen to remove have been crossed out (along with the 2 `\")\"` from before) and we've checked the balance of the new string.\n\n![A diagram showing a failed attempt to balance L(e)))et((co)d(e by removing invalid ) and then random (](../Figures/1249/balance_example_6.png)\n\nWe've caused the balance to go negative while checking again. Even though we have the same number of `\"(\"` and `\")\"` in the string, they don't match up. The last `\")\"` is *before* the last `\"(\"`. We don't want to do another round of removing `\")\"`, because that would no longer be optimal. We need to identify which `\"(\"` each of our `\")\"` is actually pairing with. Here is the example with a different color to show each pair. A `\")\"` always pairs with the *closest* `\"(\"` that doesn't already have a pair.\n\n![A diagram using color to show pairs in L(e)))et((co)d(e](../Figures/1249/balance_example_7.png)\n\nThe 2 `\"(\"` that don't pair with a `\")\"` are the ones we should remove. This way, we know we won't cause a negative balance.\n\nSo, remembering that each `\")\"` was paired with the *closest*  `\"(\"` that isn't already paired, how could we do this in code? We need to know the indexes of the problematic `\"(\"`.\n\nWe can use a **stack**. Each time we see a `\"(\"`, we should add its index to the stack. Each time we see a `\")\"`, we should remove an index from the stack because the `\")\"` will match with whatever `\"(\"` was at the top of the stack. The *length of the stack* is equivalent to the `balance` from above. We will need to do the:\n\n1. Remove a `\")\"` if it is encountered when stack was already empty (prevent negative balance).\n2. Remove a `\"(\"` if it is left on stack at end (prevent non-zero final balance).\n\nHere is an animation of using a stack to fix the string from above.\n\n!?!../Documents/1249_balance_example.json:960,540!?!\n\nYou might wonder whether or not this greedy approach is safe, i.e. why not remove an earlier `\")\"` instead? This would \"free up\" a `\"(\"` for the current`\")\"` we're looking at, right? The answer is yes, we could do this, but no it won't make any difference to the overall number of `\")\"` we need to remove. This is because whatever `\"(\"` was matching with the earlier `\")\"` will now simply match with our current `\")\"` leaving no net benefit.\n\nAfter removing invalid `\")\"`, the number of `\"(\"` we remove is the minimum needed to ensure that `count(\"(\") == count(\")\")`.\n\n**Algorithm**\n\nLet's put all this together into a 2-pass algorithm.\n\n1. Identify all indexes that should be removed.\n2. Build a new string with removed indexes.\n\nAs explained above, we should use a **stack**. If we put the *indexes* of the `\"(\"` on the stack, then we'll know that all the indexes on the stack at the *end* are the indexes of the unmatched `\"(\"`. We should also use a **set** to keep track of the unmatched  `\")\"` we come across. Then, we can remove the character at each of those indexes and then return the edited string.\n\nWe need to be really careful with that \"removal\" step though, as it can be done in $$O(n)$$, but there are many ways of accidentally making it $$O(n^2)$$. Making these mistakes (and not fixing them) in an interview won't look good. Here's some operations that are $$O(n)$$ that people sometimes assume are $$O(1)$$.\n\n- Adding or removing (or even changing) just one character *anywhere* in a **string** is $$O(n)$$, because strings are **immutable**. The entire string is rebuilt for every change.\n- Adding or removing *not from the end* of a list, vector, or array is $$O(n)$$ because the other items are moved up to make a gap or down to fill in the gap.\n- Checking if an item is in a list, because this requires a **linear search**. Even if you use binary search, it'll still be $$O(\\log n)$$, which is not ideal for this problem.\n\nA safe strategy is to iterate over the string and insert each character we want to keep into a **list** (Python) or **StringBuilder** (Java). Then once we have all the characters, it is a single $$O(n)$$ step to convert them into a string.\n\nRecall that checking if an item is in a **set** is $$O(1)$$. If all the indexes we need to remove are in a set, then we can iterate through each index in the string, check if the current index is in the set, and if it is not, then add the character at that index to the string builder.\n\n<iframe src=\"https://leetcode.com/playground/hrGhBdNv/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"hrGhBdNv\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$, where $$n$$ is the length of the input string.\n\n    There are 3 loops we need to analyze. We also need to check carefully for any library functions that are not constant time.\n\n    The first loop iterates over the string, and for each character, either does nothing, pushes to a stack or adds to a set. Pushing to a stack and adding to a set are both $$O(1)$$. Because we are processing each character with an $$O(1)$$ operation, this overall loop is $$O(n)$$.\n\n    The second loop (hidden in library function calls for the Python code) pops each item from the stack and adds it to the set. Again, popping items from a stack is $$O(1)$$, and there are at most $$n$$ characters on the stack, and so it too is $$O(n)$$.\n\n    The third loop iterates over the string again, and puts characters into a StringBuilder/ list. Checking if an item is in a set and appending to the end of a String Builder or list is $$O(1)$$. Again, this is $$O(n)$$ overall.\n\n    The `StringBuilder.toString()` method is $$O(n)$$, and so is the `\"\".join(...)`. So again, this operation is $$O(n)$$.\n\n    So this gives us $$O(4n)$$, and we drop the $$4$$ because it is a constant.\n\n* Space complexity : $$O(n)$$, where $$n$$ is the length of the input string.\n\n    We are using a **stack**, **set**, and **string builder**, each of which could have up to n characters in them, and so require up to $$O(n)$$ space.\n\nWhen checking your own implementation, watch out for any $$O(n)$$ library calls *inside loops*, as these would make your solution $$O(n^2)$$.\n\n<br />\n\n---\n\n#### Approach 2: Two Pass String Builder\n\n**Intuition**\n\nA key observation you might have made from the previous algorithm is that for all invalid `\")\"`, we know immediately that they are invalid (they are the ones we were putting in the set). It is the `\"(\"` that we don't know about until the end (as they are what was left on the stack at the end). We could be building up a string builder in that first loop that has *all* of the invalid `\")\"` removed. This would be half the problem solved in the first loop, in $$O(n)$$ time.\n\nGoing back to our example above, we start by identifying all the problematic `\")\"`.\n\n![L(e)))et((co)d(e with the unbalanced ) crossed out. ](../Figures/1249/balance_example_8.png)\n\nWhile we were running this pass, we could have been adding all *characters to keep* to a String Builder. This is what we'd have left if we had.\n\n![The string L(e)et((co)d(e.](../Figures/1249/balance_example_9.png)\n\nNow, another important observation is that we can use *the same algorithm* to remove the invalid `\"(\"`. We just need to look at the string in reverse. We do this by swapping the `\"(\"` and `\")\"` for each other, and reversing the order of all characters in the string.\n\n![The string L(e)et((co)d(e reversed to be e)d(oc))te(e)L and new balance calculations done](../Figures/1249/balance_example_10.png)\n\nSo then we can remove those characters, and undo the reverse operation by reversing all characters and swapping `\"(\"` and `\")\"` again, and we have the answer!\n\n![The string e)d(oc))te(e)L with invalid ) removed to give ed(oc)te(e)L](../Figures/1249/balance_example_11.png)\n\n![The string ed(oc)te(e)L reversed back to L(e)et(co)de and balances used to verify it.](../Figures/1249/balance_example_12.png)\n\n\n**Algorithm**\n\nIn code, it's best to pull out the common functionality of both passes, otherwise you will have almost the same code repeated twice. A good way to do this is to have a function that takes a string, a symbol to treat as the \"open\" parenthesis, and a symbol to treat as the \"close\" parenthesis. The function then returns a string that has all invalid instances of the \"closing\" symbol removed. Then for the second pass, pass in the reversed string (that was returned from the first pass) and with the \"open\" and \"close\" symbols swapped.\n\n<iframe src=\"https://leetcode.com/playground/UNSaLpb4/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"UNSaLpb4\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$, where $$n$$ is the length of the input string.\n\n    We need to analyze the `removeInvalidClosing` function and then the outside code.\n\n    `removeInvalidClosing` processes each character once and optionally modifies balance and adds the character to a string builder. Adding to the end of a string builder is $$O(1)$$. As there are at most $n$ characters to process, the overall cost is $$O(n)$$.\n\n    The other code makes 2 calls to `removeInvalidClosing`, 2 string reversals, and 1 conversion from string builder to string. These operations are $$O(n)$$, and the 3 is treated as a constant so is dropped. Again, this gives us an overall cost of $$O(n)$$.\n\n    Because all parts of the code are $$O(n)$$, the overall time complexity is $$O(n)$$.\n\n* Space complexity : $$O(n)$$, where $$n$$ is the length of the input string.\n\n    The string building still requires $$O(n)$$ space. However, the constants are smaller than the previous approach, as we no longer have the set or stack.\n\n    It is impossible to do better, because the input is an immutable string, and the output must be an immutable string. Therefore, manipulating the string cannot be done in-place, and requires $$O(n)$$ space to modify.\n\nWhen checking your own implementation, watch out for any $$O(n)$$ library functions *inside loops*, as these would make your solution $$O(n^2)$$.\n\n</br>\n\n---\n\n#### Approach 3: Shortened Two Pass String Builder\n\n**Intuition**\n\nThis approach is a simplification of the previous one, and only needs to keep track of the `balance`. It does not need a stack. Instead of doing the full procedure twice, we can do the first pass and then look at the `balance` to see how many `\"(\"` we need to remove. It turns out that if we remove the *rightmost* `'('`, we are guaranteed to have a balanced string. So for the second pass, we only need to remove `balance` `\"(\"`, starting from the right.\n\nIt might be difficult initially to see why this works, so here's a justification.\n\nConsider a string ***`s` that contains no invalid \")\"*** (it has had all the invalid `\")\"` removed by the first pass of the algorithm). It's important to understand that we therefore *know there is a way* of removing `balance` `\"(\"` that *will* make it valid. For example, one of our examples from above.\n\n![The string L(e)et((co)d(e.](../Figures/1249/balance_example_9.png)\n\nFor a given `\"(\"` to be valid, there needs to be *more* `\")\"` *than* `\"(\"` *after it* in `s` (if not, there won't be a `\")\"` leftover for it). If this is true for *all* `\"(\"` in `s`, then `s` would be valid.\n\nWhen we remove a `\"(\"`, all other `\"(\"` to the *left* see their ratio of `\")\"` to `\"(\"` go up (in other words, they have less others to compete for the `\")\"` with).\n\nSo by removing `balance` `\"(\"` from the right, *every* other `\"(\"` now has `balance` less `\"(\"` after it, which is the biggest improvement in the ratios we could have possibly got. If any `\"(\"` was still not valid after this, then that would mean `s` had invalid `\")\"` at the start (which it didn't, because it had all of those removed already).\n\nTherefore, this has to be a valid solution.\n\n**Algorithm**\n\nIn order to avoid iterating backwards (which adds needless complexity to the algorithm), we also keep track of how many `\"(\"` are in the string in the first pass. This way, we can calculate how many `\"(\"` we are *keeping*, and count these down as we iterate through the string on the second pass. Then once we've kept enough, we can start dropping them.\n\n<iframe src=\"https://leetcode.com/playground/TBWcoJES/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"TBWcoJES\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$, where $$n$$ is the length of the input string.\n\n    Same as the above approaches. We have 2 loops that are looping through up to $n$ characters, doing an $$O(1)$$ operation on each. We also have some $$O(n)$$ library function calls *outside of the loops*.\n\n* Space complexity : $$O(n)$$, where $$n$$ is the length of the input string.\n\n    Like the previous approach, the string building requires $$O(n)$$ space.\n\nWhen checking your own implementation, watch out for any $$O(n)$$ library functions *inside loops*, as these would make your solution $$O(n^2)$$.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "786",
            "count": 394,
            "average": "4.936",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "minimum-remove-to-make-valid-parentheses",
    "playgroundData": {
        "hrGhBdNv": {
            "playground": {
                "testcaseInput": "",
                "name": "minimum-remove-to-make-valid-parentheses-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "UNSaLpb4": {
            "playground": {
                "testcaseInput": "",
                "name": "minimum-remove-to-make-valid-parentheses-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "TBWcoJES": {
            "playground": {
                "testcaseInput": "",
                "name": "minimum-remove-to-make-valid-parentheses-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}