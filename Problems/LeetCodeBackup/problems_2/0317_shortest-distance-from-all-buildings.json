{
    "id": "317",
    "question": {
        "questionId": "317",
        "questionFrontendId": "317",
        "boundTopicId": null,
        "title": "Shortest Distance from All Buildings",
        "titleSlug": "shortest-distance-from-all-buildings",
        "content": "<p>You are given an <code>m x n</code> grid <code>grid</code> of values <code>0</code>, <code>1</code>, or <code>2</code>, where:</p>\n\n<ul>\n\t<li>each <code>0</code> marks <strong>an empty land</strong> that you can pass by freely,</li>\n\t<li>each <code>1</code> marks <strong>a building</strong> that you cannot pass through, and</li>\n\t<li>each <code>2</code> marks <strong>an obstacle</strong> that you cannot pass through.</li>\n</ul>\n\n<p>You want to build a house on an empty land that reaches all buildings in the <strong>shortest total travel</strong> distance. You can only move up, down, left, and right.</p>\n\n<p>Return <em>the <strong>shortest travel distance</strong> for such a house</em>. If it is not possible to build such a house according to the above rules, return <code>-1</code>.</p>\n\n<p>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.</p>\n\n<p>The distance is calculated using <a href=\"http://en.wikipedia.org/wiki/Taxicab_geometry\" target=\"_blank\">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/buildings-grid.jpg\" style=\"width: 413px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).\nThe point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.\nSo return 7.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1]]\n<strong>Output:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n\t<li>There will be <strong>at least one</strong> building in the <code>grid</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Hard",
        "likes": 1617,
        "dislikes": 189,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Best Meeting Point\", \"titleSlug\": \"best-meeting-point\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"As Far from Land as Possible\", \"titleSlug\": \"as-far-from-land-as-possible\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]\n[[1,0]]\n[[1]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 14}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"DoorDash\", \"slug\": \"doordash\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Qualtrics\", \"slug\": \"qualtrics\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Zenefits\", \"slug\": \"zenefits\", \"timesEncountered\": 0}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int shortestDistance(vector<vector<int>>& grid) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int shortestDistance(int[][] grid) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def shortestDistance(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def shortestDistance(self, grid: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint shortestDistance(int** grid, int gridSize, int* gridColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int ShortestDistance(int[][] grid) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar shortestDistance = function(grid) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef shortest_distance(grid)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func shortestDistance(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func shortestDistance(grid [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def shortestDistance(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun shortestDistance(grid: Array<IntArray>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn shortest_distance(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function shortestDistance($grid) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function shortestDistance(grid: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (shortest-distance grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec shortest_distance(Grid :: [[integer()]]) -> integer().\nshortest_distance(Grid) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec shortest_distance(grid :: [[integer]]) :: integer\n  def shortest_distance(grid) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"142.7K\", \"totalSubmission\": \"330.4K\", \"totalAcceptedRaw\": 142654, \"totalSubmissionRaw\": 330372, \"acRate\": \"43.2%\"}",
        "hints": [],
        "solution": {
            "id": "1162",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]",
        "metaData": "{\r\n  \"name\": \"shortestDistance\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"grid\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1162",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n\r\n#### Overview\r\n\r\nWe are asked to build a house with the shortest total travel distance to all other houses. To do so, we must be able to find the shortest distance between two cells (one empty land and a house). This process will then be repeated for every pair of empty land and house.\r\nAs such, an intuitive first step is to record the location of all houses (1-valued cells) and empty land (0-valued cells) in separate vectors.\r\n\r\nThen, for each empty land, traverse all houses, and add the Manhattan Distance:  \r\n`distance = |x1 - x2| + |y1 - y2|`, where `(x1, y1)` are the coordinates of empty land and `(x2, y2)` are the coordinates of a house.\r\n\r\nBut the problem here is that we have some blocked cells.\r\nFor example, in the below configuration the formula does not give the correct distance between P1 and P2. This is because there are **obstacles between the two points**.\r\n\r\n![blocked paths](../Figures/317/Slide1.PNG)\r\n\r\n<br />\r\n\r\nSince obstacles preclude us from using the formula, we will instead perform a level-wise Breadth-First Search (BFS) for each cell, where each level is 1 distance further away from the starting cell (traversing 4-directionally). As we expand our Breadth-First Search, we will not visit any cell that is blocked or any cell that has already been visited.\r\n\r\n<br />\r\n\r\n_Why did we choose to use BFS?_\r\n\r\n> Our graph is not weighted. We can consider each edge to have the same weight of 1.\r\n> Since the graph is unweighted, BFS can be used to find the shortest path between a starting cell and any other reachable cell.\r\n\r\n> The actual distance calculation measures grid distance in terms of only horizontal and vertical movements. Since we can only move up, down, left, and right, we can apply BFS to calculate the actual distance.  At each iteration in the BFS, we will only consider expanding our search in the horizontal or vertical direction.\r\n\r\n</br>\r\n\r\n---\r\n\r\n#### Approach 1: BFS from Empty Land to All Houses\r\n\r\n**Intuition**\r\n\r\nOur goal is to find the empty land cell with the shortest total distance to all houses, so we must first find the shortest total distance to all houses from each empty land cell.\r\nAs previously mentioned, this can be accomplished using BFS. For each empty cell (cell value equals 0) in the grid, start a BFS and sum all the distances to houses (cell value equals 1) from this cell. We will also keep track of the number of houses we have reached from this source cell (empty cell).\r\nIf we cannot reach all the houses from the current empty cell, then it is not a valid empty cell. Furthermore, we can be certain that any cell visited during this BFS also cannot reach all of the houses. So we will mark all cells visited during this BFS as obstacles to ensure that we do not start another BFS from this region.\r\n\r\n**Algorithm**\r\n\r\n1. For each empty cell (`grid[i][j]` equals 0), start a BFS:\r\n    - In the BFS, traverse all 4-directionally adjacent cells that are not blocked or visited and keep track of the distance from the start cell. Each iteration adds 1 to the distance.\r\n    - Every time we reach a house, increment houses reached counter `housesReached` by 1, and increase the total distance `distanceSum` by the current distance (i.e., the distance from the start cell to the house).\r\n    - If `housesReached` equals `totalHouses`, then return the total distance. \r\n    - Otherwise, the starting cell (and every cell visited during this BFS) cannot reach all of the houses.  So set every visited empty land cell equal to 2 so that we do not start a new BFS from that cell and return `INT_MAX`.\r\n2. Each time a total distance is returned from a BFS call, update the minimum distance (`minDistance`).\r\n3. If it is possible to reach all houses from any empty land cell, then return the minimum distance found. Otherwise, return `-1`.\r\n\r\n!?!../Documents/317/317_shortest_distance_from_all_buildings_1.json:960,540!?!\r\n\r\n<br />\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/XeFbciGf/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XeFbciGf\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$N$$ and $$M$$ be the number of rows and columns in `grid` respectively.\r\n\r\n-   Time Complexity: $$O(N^2 \\cdot M^2)$$\r\n\r\n    For each empty land, we will traverse to all other houses.\r\n    This will require $$O($$number of zeros $$\\cdot$$ number of ones$$)$$ time and the number of zeros and ones in the matrix is of order $$N \\cdot M$$.\r\n    Consider that when half of the values in grid are 0 and half of the values are 1, the total elements in grid would be $$(M \\cdot N)$$ so their counts are $$(M \\cdot N)/2$$ and $$(M \\cdot N)/2$$ respectively, thus giving time complexity $$(M \\cdot N)/2 \\cdot (M \\cdot N)/2$$, that results in $$O(N^2 \\cdot M^2)$$.\r\n\r\n> In JavaScript implementation, for simplicity, we have used an array for the queue.\r\n> Since popping elements from the front of an array is an O(n) operation, which is undesirable,\r\n> instead of popping from the front of the `queue`, we will iterate over the `queue` and record cells to be explored in the next level in `next_queue`.\r\n> Once the current `queue` has been traversed, we simply set `queue` equal to the `next_queue`.\r\n\r\n-   Space Complexity: $$O(N \\cdot M)$$\r\n\r\n    We use an extra matrix to track the visited cells, and the queue will store each matrix element at most once during each BFS call.\r\n    Hence, $$O(N \\cdot M)$$ space is required.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 2: BFS from Houses to Empty Land\r\n\r\n**Intuition**\r\n\r\nIn the previous approach, to get the minimum distance we started a BFS from each empty land (cell value equal to 0) to all the houses (cell value equal to 1), but another way to look at the problem is starting from a house and finding all reachable empty lands.\r\n\r\nIf we can reach a house from an empty land, then we can also traverse the other way (i.e., reach empty land from a house).\r\n\r\nWhen there are fewer houses than empty lands, then this approach will require less time than the previous approach and vice versa. While, on average, this approach is not an improvement on the previous approach, it will serve as a mental stepping stone to better understand the third approach.\r\n\r\nPreviously, we were calculating the total minimum distance sum of one empty cell in one BFS traversal, hence we were only returning the distance sum from the BFS function for each cell.\r\nBut if we start BFS from a house instead of an empty cell, we will be generating partial distance (i.e., distance from only one house to the current cell and not the sum distance from all the houses to this empty cell), hence we need some extra space to store the sum of the partial distances from each house cell.\r\n\r\n\r\nWe will need to store 2 values at each cell position of empty cells: total distance sum from all houses to this empty land and number of houses that can reach this empty land.\r\n\r\n**Algorithm**\r\n\r\n1. For each house cell (`grid[i][j]` equals 1), start a BFS:\r\n    - For each empty cell we reach, increase the cell's sum of distances by the steps taken to reach the cell.\r\n    - For each empty cell we reach, also increment the cell's house counter by 1.\r\n2. After traversing all houses, get the minimum distance from all empty cells which have `housesReached` equal to `totalHouses`.\r\n3. If it is possible for all houses to reach a specific empty land cell, then return the minimum distance found. Otherwise, return `-1`.\r\n\r\n!?!../Documents/317/317_shortest_distance_from_all_buildings_2.json:960,540!?!\r\n\r\n<br />\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/FECHEJ2e/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"FECHEJ2e\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$N$$ and $$M$$ be the number of rows and columns in `grid` respectively.\r\n\r\n-   Time Complexity: $$O(N^2 \\cdot M^2)$$\r\n\r\n    For each house, we will traverse across all reachable land.\r\n    This will require $$O($$number of zeros $$\\cdot$$ number of ones$$)$$ time and the number of zeros and ones in the matrix is of order $$N \\cdot M$$.\r\n    Consider that when half of the values in grid are 0 and half of the values are 1, total elements in grid will be $$(M \\cdot N)$$ so their counts are $$(M \\cdot N)/2$$ and $$(M \\cdot N)/2$$ respectively, thus giving time complexity $$(M \\cdot N)/2 \\cdot (M \\cdot N)/2$$, which results in $$O(N^2 \\cdot M^2)$$.\r\n\r\n> In JavaScript implementation, for simplicity, we have used an array for the queue.\r\n> However, popping elements from the front of an array is an O(n) operation, which is undesirable.\r\n> So, instead of popping from the front of the `queue`, we will iterate over the `queue` and record cells to be explored in the next level in `next_queue`.\r\n> Once the current `queue` has been traversed, we simply set `queue` equal to the `next_queue`.\r\n\r\n-   Space Complexity: $$O(N \\cdot M)$$\r\n\r\n    We use an extra matrix to track the visited cells and another one to store distance sum along with the house counter for each empty cell, and the queue will store each matrix element at most once during each BFS call.\r\n    Hence, $$O(N \\cdot M)$$ space is required.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 3: BFS from Houses to Empty Land (Optimized)\r\n\r\n**Intuition**\r\n\r\nInstead of making a new matrix each time to track the visited cells, we can use the input grid matrix for this purpose.\r\nDuring the first BFS we can change the visited empty land values from `0` to `-1`. Then during the next BFS we will only visit empty lands with a value of `-1`s (meaning they can reach the first house), then change `-1` to `-2` and then perform the next BFS only on `-2`s, and so on...\r\n\r\nThis approach allows us to avoid visiting any cell that cannot reach all houses.\r\n\r\n_Can we also use this decrement in empty land value to denote that the cell has been visited?_\r\n\r\n> Imagine we are currently at cell `(2, 3)` with value `-1` and we change its value to `-2`.  \r\n> In the queue the next element is `(2, 4)`, its value is also `-1` and we change its value to `-2`. While exploring paths from `(2, 4)`, we see that the cell `(2, 3)` is adjacent, and has the value `-2`. However, currently, we are checking for `-1` valued cells only. Hence, `(2, 3)` will not be inserted again in the queue, so this decrease in value can be used as a visited cell check because when a cell has been visited, then its value will be 1 less and it will not satisfy the condition to be inserted in the queue.\r\n\r\nIf there was an empty land cell that was not reachable in the previous iteration, then its value has not been decreased, hence we will not insert that cell in the queue when we start a BFS from another house cell.  \r\nTherefore, this approach prunes many iterations and saves some time since we are not creating a new matrix to track visited cells for each BFS call.\r\n\r\n!?!../Documents/317/317_shortest_distance_from_all_buildings_3.json:960,540!?!\r\n\r\n<br />\r\n\r\n**Algorithm**\r\n\r\n1. For each `grid[i][j]` that is equal to 1, start a BFS. During the BFS:\r\n    - All 4-directionally adjacent grid cells with values equal to `emptyLandValue` are valid.\r\n    - Visit them one by one and store the distances of these cells from the source in a `total` matrix.\r\n    - Decrease the value of visited cells by 1.\r\n2. After each BFS traversal, decrement `emptyLandValue` by 1.\r\n3. Before we start a BFS call for a house, we set `minDist` equal to `INT_MAX`.\r\n4. Then we will traverse all of the empty land cells with values equal to `emptyLandValue`\r\n5. After the last BFS traversal, if the minimum distance equals `INT_MAX`, then there has not been any cell that can be reached by all the houses, so return `-1`.\r\n6. Otherwise, return the minimum distance `minDist`.\r\n\r\n!?!../Documents/317/317_shortest_distance_from_all_buildings_4.json:960,540!?!\r\n\r\n<br />\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/kSHkPKbL/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"kSHkPKbL\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$N$$ and $$M$$ be the number of rows and columns in `grid` respectively.\r\n\r\n-   Time Complexity: $$O(N^2 \\cdot M^2)$$\r\n\r\n    For each house, we will traverse across all reachable land.\r\n    This will require $$O($$number of zeros $$\\cdot$$ number of ones$$)$$ time and the number of zeros and ones in the matrix is of order $$N \\cdot M$$.\r\n    Consider that when half of the values in grid are 0 and half of the values are 1, total elements in grid would be $$(M \\cdot N)$$ so their counts are $$(M \\cdot N)/2$$ and $$(M \\cdot N)/2$$ respectively, thus giving time complexity $$(M \\cdot N)/2 \\cdot (M \\cdot N)/2$$, that results in $$O(N^2 \\cdot M^2)$$.\r\n\r\n-   Space Complexity: $$O(N \\cdot M)$$\r\n\r\n    We use an extra matrix to store distance sums, and the queue will store each matrix element at most once during each BFS call.\r\n    Hence, $$O(N \\cdot M)$$ space is required.\r\n\r\n<br/>\r\n\r\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1167",
            "count": 44,
            "average": "4.546",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "shortest-distance-from-all-buildings",
    "playgroundData": {
        "XeFbciGf": {
            "playground": {
                "testcaseInput": "",
                "name": "shortest-distance-from-all-buildings-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "FECHEJ2e": {
            "playground": {
                "testcaseInput": "",
                "name": "shortest-distance-from-all-buildings-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "kSHkPKbL": {
            "playground": {
                "testcaseInput": "",
                "name": "shortest-distance-from-all-buildings-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}