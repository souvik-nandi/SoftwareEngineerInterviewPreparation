{
    "id": "29",
    "question": {
        "questionId": "29",
        "questionFrontendId": "29",
        "boundTopicId": null,
        "title": "Divide Two Integers",
        "titleSlug": "divide-two-integers",
        "content": "<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p>\n\n<p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p>\n\n<p>Return <em>the <strong>quotient</strong> after dividing </em><code>dividend</code><em> by </em><code>divisor</code>.</p>\n\n<p><strong>Note: </strong>Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[&minus;2<sup>31</sup>, 2<sup>31</sup> &minus; 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>2<sup>31</sup> - 1</code>, then return <code>2<sup>31</sup> - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-2<sup>31</sup></code>, then return <code>-2<sup>31</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 10, divisor = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 10/3 = 3.33333.. which is truncated to 3.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 7, divisor = -3\n<strong>Output:</strong> -2\n<strong>Explanation:</strong> 7/-3 = -2.33333.. which is truncated to -2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= dividend, divisor &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>divisor != 0</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 3267,
        "dislikes": 11099,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "10\n3\n7\n-3",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Math",
                "slug": "math",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 11}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 8}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 3}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint divide(int dividend, int divisor){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int Divide(int dividend, int divisor) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\nvar divide = function(dividend, divisor) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} dividend\n# @param {Integer} divisor\n# @return {Integer}\ndef divide(dividend, divisor)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func divide(dividend int, divisor int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def divide(dividend: Int, divisor: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun divide(dividend: Int, divisor: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $dividend\n     * @param Integer $divisor\n     * @return Integer\n     */\n    function divide($dividend, $divisor) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function divide(dividend: number, divisor: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (divide dividend divisor)\n  (-> exact-integer? exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec divide(Dividend :: integer(), Divisor :: integer()) -> integer().\ndivide(Dividend, Divisor) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec divide(dividend :: integer, divisor :: integer) :: integer\n  def divide(dividend, divisor) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"519.1K\", \"totalSubmission\": \"3M\", \"totalAcceptedRaw\": 519139, \"totalSubmissionRaw\": 2970473, \"acRate\": \"17.5%\"}",
        "hints": [],
        "solution": {
            "id": "891",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "10\n3",
        "metaData": "{\r\n  \"name\": \"divide\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"dividend\",\r\n      \"type\": \"integer\"\r\n    },\r\n    {\r\n      \"name\": \"divisor\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "929",
            "date": "2022-05-30",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "891",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nBefore we get started on the actual approaches, let's cover a few other important things.\n\nDoing this question \"properly\", following *all* the rules given, makes this one of our most difficult medium-level questions.\n\n**Don't panic, you don't need to know all the approaches**\n\nWe have provided a lot of different approaches to show how many different ways there are of solving this question. Approach 1 is a brute-force, and then Approaches 2 to 4 build on each other, and Approach 5 is similar, but approaches the thinking from a very different angle. If you only want to study the first 2 approaches, then that's fine. Approach 2 should be sufficient for an interview. However, we hope you enjoy learning about this question enough that you'll keep reading! :-)\n\n**Make sure you read the question carefully**\n\nThis question was designed with fixed-sized integers in mind. Some languages, such as Python and JavaScript, only have arbitrary-precision integers (meaning they can go *huge*, probably as big as you'll ever need!). Depending on which programming languages you're familiar with, the requirements of this question might seem a little tedious and silly to you. We recommend using a language such as C, C++, or Java for it if you're familiar with them. Otherwise, you'll just need to be really careful and think very carefully about whether or not your algorithm would work in a 32-bit-signed-integer environment. Unfortunately, Leetcode doesn't currently enforce these requirements in languages such as Python, so it's up to you to determine whether or not your solution really is a \"correct\" one. Hint: Throw heaps of `assert` statements into your code.\n\nMost of the upvoted posts on the discussion forum *aren't following the rules specified in the question*. Here are some of the problems I've seen:\n\n- The use of `long` in Java or `long long` in C++ is *not allowed*, because the question states that we're working in an environment where we only have integers within the range $$[\u22122^{31},  2^{31} \u2212 1]$$.\n- The use of `abs` in Python (and other arbitrary-precision integer languages) needs to be considered carefully, because $$abs(-2^{31}) = 2^{31}$$, *which is **outside** the allowed range by 1*.\n- While you might be tempted to use multiplication and division for a few \"simple\" tasks, this is unnecessary. Here are some alternatives:\n  - Instead of `a = a * -1` for making numbers negative, use `a = -a`.\n  - Instead of using `a / 2` for dividing by `2`, use the right shift operator; `a >> 1`.\n  - Instead of using `a * 2` for doubling, use `a = a + a`, `a += a`, or even the left shift operator; `a << 1`.\n\nAdditionally, we strongly advise against allowing overflows to happen *at all*. For some compilers/interpreters/languages, `INT_MAX + 1 \u2261 INT_MIN`. For others, `INT_MAX + 1 \u2261 INT_MAX`. And for others again, it is `undefined` or ***crash***. Some people on the discussion forum have written code that actually relies on specific overflow behaviour for correctness. While this can be quite \"clever\", it's not portable at all. For code like that to be shippable, you'd need to be *certain* of the behaviour of the specific system it is to run on, and that no future system upgrade would change the behaviour. If it works on your machine, but not on Leetcode's machine, it's *incorrect code*.\n\nIn this article, we'll be looking at a few techniques that can solve the problem elegantly and are portable.\n\n**In what cases will the *final result* be out of range?**\n\nWe're told the following about overflow in the problem description:\n\n> For the purpose of this problem, assume that your function returns $$2^{31} \u2212 1$$ when the division result overflows.\n\nSo, keeping in mind that our integer range is $$[\u22122^{31},  2^{31} \u2212 1]$$, in what cases could we have an end result *outside* of this range?\n\nWell, when we do `a / b = c`, where `a` and `b` are both *positive integers*, we know that `c \u2264 a`. In other words, the answer (`c`) cannot end up bigger than the thing we divided (the dividend, `a`).\n\nSomething similar happens even when one or both of them are negative. In that case, `abs(a) \u2264 abs(c)`. Another way of thinking about it is that `c` will *always* be closer to zero than `a` is (or, they could also be equal).\n\nTherefore, for `a` and `b` within the range $$[\u22122^{31} + 1,  2^{31} \u2212 1]$$, the result `a / b` will be closer to zero, so has to be fine.\n\nHowever, notice we left $$-2^{31}$$ out of the above range. This is because there's a special case of $$-2^{31} / -1$$, which has an answer of $$2^{31}$$. But $$2^{31}$$ is outside of the integer range! So instead we return $$2^{31}-1$$ for this case (which is in range).\n\nMost algorithms for this question simply check for the case $$-2^{31} / -1$$ at the start, returning $$2^{31} - 1$$ if they detect it. This is a sensible approach.\n\n</br>\n\n---\n\n#### Approach 1: Repeated Subtraction\n\n**Intuition**\n\n*This approach won't pass the large test cases. However, we'll use it as a starting point, and to introduce a key idea we'll be using for all the approaches\u2014doing **all** intermediate working with negative numbers.*\n\nThink about what it means to divide two integers. In order to divide, say, `15` by `5`, we ask how many times we can put `5` into `15`. The simplest way of doing this is to subtract `5` from `15` repeatedly until we can no longer do so.\n\n```python\n15 - 5 = 10\n10 - 5 = 5\n 5 - 5  = 0\n```\n\nBecause we were able to do `3` subtractions, we know the answer to `15 / 5` is `3`.\n\nAs another example, consider dividing `20` by `3`.\n\n```python\n20 - 3 = 17\n17 - 3 = 14\n14 - 3 = 11\n11 - 3 = 8\n 8 - 3 = 5\n 5 - 3 = 2\n```\n\nWe had to stop when we got to `2`, because `3` is bigger than `2`. So, because we were able to do `6` subtractions, we know the answer to `20 / 3` is `6`.\n\nIn the example above, we call `20` the `dividend` and `3` the `divisor` (`2` is the *remainder*, which we ignore for this question). The result of dividing the `dividend` by the `divisor` is the number of times we could subtract the `divisor` from the `dividend`. A commonly used name for this result is the `quotient`.\n\nTherefore, our first algorithm will simply subtract the `divisor` from the `dividend` repeatedly until doing so would push it below `0`. It will keep count of the number of these subtractions done, so that it can return it at the end.\n\n*Assuming that both the dividend and divisor are positive*, here is a code snippet for this process.\n\n```java\npublic int divide(int dividend, int divisor) {\n    int quotient = 0;\n    while (dividend - divisor >= 0) {\n        quotient++;\n        dividend -= divisor;\n    }\n    return quotient;\n}\n```\n\nThis doesn't work if one, or both, of the `dividend` or `divisor` are negative\u2014the dividend will head *away* from zero! Trying to generalise this code to handle all four of the possible sign combinations is problematic, because some are repeated addition instead of subtraction, and some have a `<= 0` continuation case instead of `>= 0`.\n\nA logical solution here is to simply convert any negative inputs to positives, and then put a negative sign back on at the end if needed. Recall that `positive * negative = negative`, and `negative * negative = positive`. In other words, if there was exactly one negative sign in the inputs, the final result is negative. Otherwise, it's positive.\n\nFor example:\n\n```python\n 60 /  10 =  6\n-60 /  10 = -6\n 60 / -10 = -6\n-60 / -10 =  6\n```\n\nWe'll avoid using `abs` (it causes overflows, that we'll talk more about soon). So for now, let's just use some conditionals so that we can count the negative signs at the same time as making the numbers positive. At the end, we'll then need to put the sign back on if needed.\n\n```java\npublic int divide(int dividend, int divisor) {\n\n    // Count the number of negatives + convert parameters to positives.\n    int negatives = 0;\n    if (dividend < 0) {\n        negatives++;\n        dividend = -dividend;\n    }\n    if (divisor < 0) {\n        negatives++;\n        divisor = -divisor;\n    }\n\n    // Count the number of subtractions.\n    int subtractions = 0;\n    while (dividend - divisor >= 0) {\n        subtractions++;\n        dividend -= divisor;\n    }\n\n    // Convert back to negative if needed.\n    if (negatives == 1) {\n        subtractions = -subtractions;\n    }\n\n    return subtractions;\n}\n```\n\nHowever, there are still a couple of issues here.\n\nFirstly, we haven't handled the `-2147483648 / -1` case. Like we said in the Overview section, this case is best handled as a special case at the start of the algorithm.\n\n```java\nif (dividend == -2147483648 && divisor == -1) {\n    return 2147483647;\n}\n```\n\nThe second issue doesn't happen in Java, but it will happen with the same algorithm in `C`\u2014an integer overflow. In Java, the math happens to combine perfectly with Java's overflow behaviour to give the correct answers. Because our goal for this solution article is to develop portable algorithms that work with any compiler/interpreter/language, we still want to fix this (and will need this same idea for our other approaches anyway). Specifically, the potentially problematic code is on these lines:\n\n```java\ndividend = -dividend;\n```\n\nand\n\n```java\ndivisor = -divisor;\n```\n\nIf `dividend = -2147483648`, then converting it to a positive number will behave differently depending on the language/compiler/interpreter you're using. This is because the positive form (`2147483648`) is outside of the 32-bit signed integer range.\n\nTreating this as an edge case is impractical\u2014it affects billions of cases. We'll need a better way.\n\n> The key observation to make is that the problems are occurring because there are more negative signed 32-bit integers than there are positive signed 32-bit integers. Each positive signed 32-bit integer has a corresponding negative signed 32-bit integer. However, the same is not true for negative signed 32-bit integers. The smallest one, `-2147483648`, is alone. It is this number that causes the problems.\n\nThe best solution is to work with negative, instead of positive, numbers. This is allows us to use the largest possible range of numbers, and it covers all the ones we need.\n\nAt the start of the algorithm, we'll instead convert both inputs to *negative*. Then, we'll need to modify the loop so that it *subtracts* the negative divisor from the negative dividend. At the end, we'll need to convert the result back to a positive if the number of negative signs in the input was not 1.\n\nThe code for this is our complete approach 1, and can be found in the code box below.\n\n**Algorithm**\n\nRemember that we're converting the inputs to *negative* numbers. This is because we don't want separate code for all the possible combinations of positive/negative divisor and dividend. We converted them to negative instead of positive because the range of valid negative numbers is bigger, and therefore overflows can be cleanly avoided.\n\nThe looping condition is `while (dividend - divisor <= 0)` because the difference is moving towards zero from the *negative* side. Therefore, we want to continue while it is still under it. Once it goes over, we know we're done.\n\n<iframe src=\"https://leetcode.com/playground/LTaQQbMt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"LTaQQbMt\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the absolute value of $$dividend$$.\n\n- Time Complexity : $$O(n)$$.\n\n    Consider the worst case where the divisor is $$1$$. For any dividend $$n$$, we'll need to subtract $$1$$ a total of $$n$$ times to get to $$0$$. Therefore, the time complexity is $$O(n)$$ in the worst case.\n\n- Space Complexity : $$O(1)$$.\n\n    We only use a fixed number of integer variables, so the space complexity is $$O(1)$$.\n\nSeeing as $$n$$ can be up to $$2^{31}$$, this algorithm is **too slow** on the largest test cases. We'll need to do better!\n\n</br>\n\n---\n\n#### Approach 2: Repeated Exponential Searches\n\n**Intuition**\n\nLinear Search is too slow because at each step, we only subtract one copy of the divisor from the dividend. A better way would be to try and subtract multiple copies of the divisor each time.\n\nOne way of quickly increasing numbers, without using multiplication, is to double them repeatedly. So let's try doubling the divisor until it no longer fits into the dividend.\n\nIt'll be easiest to understand with an example, so let's say we have a dividend of `93706` and a divisor of `157`. We'll now just see what happens when we repeatedly double `157` until it's bigger than `93706`.\n\n```python\n157\n314\n628\n1256\n2512\n5024\n10048\n20096\n40192\n80384\n160768 # Too big\n```\n\nFrom this, we know that we can fit `80384` into `93706`, and that `80384` must be a multiple of `157`. But how many copies of `157` is this?\n\nWell, each time we double a number we also double the amount of copies of the original number. So because we doubled `157` nine times, we must have had `2\u2079` copies of `157`. Indeed, `2\u2079 \u00b7 157 = 80384`. Yay!\n\nBut, we still have some left over\u2014in fact we have `93706 - 80384 = 13322` left over! That's still a *lot* of copies of `157` we haven't counted! So what could we do about this? Well, if we work out how many times `157` fits into `13322`, we could just add that to `512` to get our result.\n\nHow can we work out how many times `157` fits into `13322`? Well, we just repeat the same process, adding to the result as we go, until there's nothing left for `157` to fit into.\n\nIf we do this, we'll find that `157 \u00b7 2\u2076 = 10048` is the highest power that fits into `13322`, leaving us with `13322 - 10048 = 3274` and a quotient so far of `2\u2076 + 2\u2079 = 576` (if you noticed that `10048` looks very familiar, well done. We'll be looking at this in approach 3).\n\nWe repeat this process until the dividend is less than `157`.\n\nHere is the algorithm in code (for this example we're pretending the numbers are positive, and we're ignoring the \"overflow\" case. In the actual code, we use negatives numbers to prevent the overflow).\n\n```java\nint quotient = 0;\n/* Once the divisor is bigger than the current dividend,\n * we can't fit any more copies of the divisor into it. */\nwhile (dividend >= divisor) {\n    /* Now that we're in the loop, we know it'll fit at least once as\n     * divivend >= divisor */\n    int powerOfTwo = 1;\n    int value = divisor;\n    /* Check if double the current value is too big. If not, continue doubling.\n     * If it is too big, stop doubling and continue with the next step */\n    while (value + value < dividend) {\n        value += value;\n        powerOfTwo += powerOfTwo;\n    }\n    // We have been able to subtract divisor another powerOfTwo times.\n    quotient += powerOfTwo;\n    // Remove value so far so that we can continue the process with remainder.\n    dividend -= value;\n}\n\nreturn quotient;\n```\n\nThis algorithm is known as exponential search and is commonly used for searching sorted spaces of unknown size for the first value that past a particular condition. It it a lot like binary search, having the same time complexity of $$O(\\log \\, n)$$. I believe this is why this question is tagged as binary search (there is technically a way of using binary search, but it is a lot more complicated and gives no real efficiency gain, and so we won't be talking about it in this article.)\n\nHere's an animation of using this algorithm to do `divide(93706, 157)`.\n\n!?!../Documents/29_animation_1.json:700,200!?!\n\n**Algorithm**\n\nIn Approach 1, we used negative numbers due to their larger range avoiding overflow problems. We do the same here.\n\nAgain, some of the conditions might initially seem like they're around the wrong way. Think carefully about them, and remember that we're *working entirely with negative numbers*.\n\n<iframe src=\"https://leetcode.com/playground/byTFoCVZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"byTFoCVZ\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the absolute value of $$dividend$$.\n\n- Time Complexity : $$O(\\log^2 \\, n)$$.\n\n    We started by performing an exponential *search* to find the biggest number that fits into the current dividend. This search took $$O(\\log \\, n)$$ operations.\n\n    After doing this *search*, we updated the dividend by subtracting the number we found. In the worst case, we were left with a dividend slightly less than half of the previous dividend (if it was more than half, then we couldn't have found the maximum number that fit in by doubling!).\n\n    So how many of these searches did we need to do? Well, with the dividend *at least* halving after each one, there couldn't have been more than $$O(\\log \\, n)$$ of them.\n\n    So combined together, in the worst case, we have $$O(\\log \\, n)$$ searches with each search taking $$O(\\log \\, n)$$ time. This gives us $$O((\\log \\, n) \\cdot (\\log \\, n)) = O(\\log^2 \\, n)$$ as our total time complexity.\n\n- Space Complexity : $$O(1)$$.\n\n    Because only a constant number of single-value variables are used, the space complexity is $$O(1)$$.\n\n</br>\n\n---\n\n#### Approach 3: Adding Powers of Two\n\n**Intuition**\n\nIn the previous approach, we did repeated exponential searches for the largest value that would fit into the current dividend.\n\nHowever, notice that each time we do a search, we repeatedly go through the same doubles to find the largest. For example, consider the first and second step of our previous example: `divide(93706, 157)`.\n\nOn the first step we did this:\n\n```python\n157\n314\n628\n1256\n2512\n5024\n10048\n20096\n40192\n80384\n160768 # Too big\n```\n\nThis left us with a difference of `93706 - 80384 = 13322`.\n\nOn the second step we repeated this process again with `13322`:\n\n```python\n157\n314\n628\n1256\n2512\n5024\n10048\n20096 # Too big\n```\n\nNotice that we've just recomputed the first seven terms of the doubles *again!*\n\nInstead of doing this, we should find a way so that we can compute the sequence just once and then use the results from this to compute our quotient.\n\nIn order to do this, we need to notice one more property about the difference. That property is that the difference will *always* be less than the previous doubling of the divisor that fits into it. Why? Well, if it were equal, or bigger, than the largest doubling, then we must've stopped doubling too soon. So, the difference is always less than the biggest doubling.\n\nSo to use these properties, we'll put all the \"doubles\" of `157` into a List. Then we'll iterate backwards over the list taking all the numbers that will fit into the dividend. Here's an animation of the algorithm.\n\n!?!../Documents/29_animation_2.json:960,300!?!\n\nHere is the algorithm in code (like before, we're showing this example with positive inputs and pretending overflow doesn't exist, as our focus right now is on the approach and not the implementation. We'll do it correctly in the actual code of course!).\n\n```java\nList<Integer> doubles = new ArrayList<>();\nList<Integer> powersOfTwo = new ArrayList<>();\n\nint powerOfTwo = 1;\n\n/* Nothing too exciting here, we're just making a list of doubles of 1 and\n * the divisor. This is pretty much the same as Approach 2, except we're\n * actually storing the values this time. */\nwhile (divisor <= dividend) {\n    powersOfTwo.add(powerOfTwo);\n    doubles.add(divisor);\n    powerOfTwo += powerOfTwo;\n    divisor += divisor;\n}\n\nint quotient = 0;\n/* Go from largest double to smallest, checking if the current double fits.\n * into the remainder of the dividend */\nfor (int i = doubles.size() - 1; i >= 0; i--) {\n    if (doubles[i] <= dividend) {\n        // If it does fit, add the current powerOfTwo to the quotient.\n        quotient += powersOfTwo.get(i);\n        // Update dividend to take into account the bit we've now removed.\n        dividend -= doubles.get(i);\n    }\n}\n```\n\nWe also saved the powers of two, as we need to know which corresponded with each multiple of `157`.\n\n**Algorithm**\n\nAgain, we work with negative numbers to elegantly avoid overflow issues.\n\nHopefully you're getting the hang of the conditionals that have to work with negative, instead of positive, numbers!\n\n<iframe src=\"https://leetcode.com/playground/KQX5ZJgM/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"KQX5ZJgM\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the absolute value of $$dividend$$.\n\n- Time Complexity : $$O(\\log \\, n)$$.\n\n    We take $$O(\\log \\, n)$$ time in the first loop to create our list of doubles (and powers of two).\n\n    For the second loop, because there's $$O(\\log \\, n)$$ items in the list of doubles, it only takes  $$O(\\log \\, n)$$time for this loop as well.\n\n    Combined, our total time complexity is just $$O(\\log \\, n + \\log \\, n) = O(\\log \\, n)$$.\n\n- Space Complexity :  $$O(\\log \\, n)$$.\n\n    The length of the list of doubles of the divisor is proportional to $$O(\\log \\, n)$$ so our space complexity is $$O(\\log \\, n)$$.\n\nThis approach is interesting in that the time complexity is lower than the previous one, but it requires a bit of space. Trading off space for time is very common practice.\n\nHowever, as we'll see in the next approach, we can modify the algorithm so that we don't need $$O(\\log \\, n)$$ space at all!\n\n</br>\n\n---\n\n#### Approach 4: Adding Powers of Two with Bit-Shifting\n\n**Intuition**\n\nIn Approach 3 we put doubles of the divisor, and powers of two into lists. This was so that we could easily refer back to them.\n\nHowever, we don't need to save them\u2014we can simply find the largest double, along with it's corresponding power of two, and then generate the rest by dividing by two repeatedly. *But we can't divide by two, that breaks the rules...*, you might be thinking. The solution is to use the **right-shift** bitwise operator!\n\n```java\nint a = 1020;\na = a >> 1;\nSystem.out.println(a);\n// Prints 510.\n```\n\nOne potential pitfall with the right-shift operator is using it on negative *odd* numbers. Two's complement makes the result one-off what you would expect/ probably wanted. This happens in *all* the programming languages we've checked, although there could be a few that behave differently.\n\n```java\nint a = -1020;\na = a >> 1;\nSystem.out.println(a);\n// Prints -510. Great!\nint b = -1021;\nb = b >> 1;\nSystem.out.println(b);\n// Prints -511. Ugghh.\n```\n\nThe solution is to add 1 before doing the bit-shift *on a negative number*. This way, it'll be \"correct\" regardless of whether the number was odd or even.\n\n```java\nint a = -1020;\na = (a + 1) >> 1;\nSystem.out.println(a);\n// Prints -510. Great!\nint b = -1021;\nb = (b + 1) >> 1;\nSystem.out.println(b);\n// Prints -510. Yay!\n```\n\nThe reason we brought this up is because it's a pitfall you might encounter with your own code, and potentially be driven crazy by, if you have limited experience working with bitwise operators. It turns out we can completely ignore the issue for the algorithm we've got here, as we know the numbers we're right shifting happen to *always be even*. This is because of the way they were generated.\n\nHere is the algorithm, again using only positive numbers (like before, check the next section to see the actual implementations).\n\n```java\n /* In the first loop, we simply find the largest double of divisor. This is\n  * very similar to the start of what we did in Approach 2. */\nint highestDouble = divisor;\nint highestPowerOfTwo = 1;\nwhile (highestDouble + highestDouble <= dividend) {\n    highestPowerOfTwo += highestPowerOfTwo;\n    highestDouble += highestDouble;\n}\n\n/* In the second loop, we work out which powers of two fit in, by\n * halving highestDouble and highestPowerOfTwo repeatedly. */\nint quotient = 0;\nwhile (divisor <= dividend) {\n    if (dividend >= highestDouble) {\n        quotient += highestPowerOfTwo;\n        dividend += highestDouble;\n    }\n    highestPowerOfTwo >>= 1;\n    highestDouble >>= 1;\n}\n\nreturn quotient;\n```\n\n**Algorithm**\n\nAgain, this algorithm works with negative numbers.\n\n<iframe src=\"https://leetcode.com/playground/CoaPpaEX/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"CoaPpaEX\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$n$$ be the absolute value of $$dividend$$.\n\n- Time Complexity : $$O(\\log \\, n)$$.\n\n    Same as Approach 3, except instead of looping over a generated array, we simply perform an $$O(1)$$ halving operation to get the next values we need.\n\n- Space Complexity : $$O(1)$$.\n\n    We only use a fixed number of integer variables, so the space complexity is $$O(1)$$.\n\n</br>\n\n---\n\n#### Approach 5: Binary Long Division\n\n**Intuition**\n\nThe previous approaches are all fine for an interview. We provide this approach as an alternate way of thinking about the problem, that some people might relate better to.\n\nAnyway, another way we could divide two integers is to consider how we do division in math.\n\nOne of the common ways, which you may or may not have learned in school, is called long division.\n\nLike the previous two approaches, long division works by find a large multiple of the divisor which fits into the dividend. Then it subtracts this from the dividend and repeats the process.\n\n***Long Division in Base-10***\n\n*If you're familiar with long division feel free to skip this next bit.*\n\nLet's go through an example of long division. We'll start with a divisor of `379` and dividend of `872703948`. To perform division, we go through each digit looking at whether or not `379` fits into the right-most digits we've looked at so far.\n\nLet's start with the first digit:\n\n![Division of 872703948 by 379 where the first digit of result is unknown](../Figures/29/long_division_base_10_first_digit_unknown.png)\n\nClearly `379` does not fit into `8`, so we put a `0` and continue to the next digit.\n\n![Division of 872703948 by 379 where the second digit of result is unknown](../Figures/29/long_division_base_10_second_digit_unknown.png)\n\nSame thing again, `379` doesn't fit into `87`, so we put a `0` and continue to the next digit.\n\n![Division of 872703948 by 379 where the third digit of result is unknown](../Figures/29/long_division_base_10_third_digit_unknown.png)\n\nFinally we find `379` *does* fit into `872` (because `379` \u2264 `872`, it must fit in). Because it fits in two times we put the digit `2` onto our result. Don't worry about the multiplication we just referred to, we have a solution for that shortly!\n\n![Division of 872703948 by 379 where the third digit of result is 2](../Figures/29/long_division_base_10_third_digit_known.png)\n\nAt this point, you might wonder why we divide to see how many times `379` goes into `872`. This is because what it actually means is how many times `379000000` goes into `872703948`. It goes in `2` times. Okay, let's continue on.\n\nHowever `379000000` doesn't go into `872703948` exactly `2` times; `379000000 * 2 = 758000000`.\n\n`758000000` is quite a bit short of `872703948`. In fact, there's still `872703948 - 758000000 = 114703948` left over.\n\nWe now need to find how many times `379` goes into `114703948`.\n\n![Division of 872703948 by 379 with first difference](../Figures/29/long_division_base_10_first_difference.png)\n\nNow we simply repeat the process again with the difference. Let's start with the first digit again.\n\n![Division of 872703948 by 379 with first difference and showing trying to divide 379 into 1](../Figures/29/long_division_base_10_first_difference_digit_1.png)\n\nLike before, `379` doesn't fit into `1`. Repeating this again, we'll see that it doesn't go into `11` or `114` either. In fact, it's impossible for it to fit until the digit after the one where we placed our `2`. This shouldn't be too surprising\u2014if it did fit into the first three digits, we should've had a `3` (or higher) instead of a `2`.\n\nAs such, we can simply continue the process from the digit position after the `2`. Doing so, we discover that `379` goes into `1147` a total of `3` times. Let's add that to our result.\n\n(Remember this means `37900000` goes into `114703948` at most `3` times).\n\n![Division of 872703948 by 379 with first difference and 4th result digit](../Figures/29/long_division_base_10_first_difference_digit_4.png)\n\nWe continue to repeat this process. Eventually, we'll run out of digits and wind up with our final result.\n\n![Complete long division of 872703948 by 379](../Figures/29/long_division_base_10_complete.png)\n\nWith this final result, we now know that `379` goes into `114703948` a total of `2302648` times.\n\n***Long Division in Base-2***\n\nOne of the problems with using base-10 division for this problem is that in order to perform the algorithm, we'd need to be able to add the necessary `0`s onto the end of the divisor. Given that we aren't allowed to use multiplication, this would prove to be a bit of a challenge!\n\nAdditionally, the current divisor could fit into the current dividend up to `10` times. Again, without multiplication, this is a bit annoying to calculate.\n\nThere are ways we can hack around these problems, but a far better way is to simply do the division in base-2 so that we can use bitwise operators.\n\nIn base-2, division works exactly the same way. However, because there are only two digits (`1` and `0`), we can simply check if the divisor-padded-with-zeroes is greater than the current dividend, and then if it is, add a `0` digit to the quotient, otherwise add a `1` digit.\n\nHere's an animation showing base-2 long division.\n\n!?!../Documents/29_animation_3.json:960,540!?!\n\n**Algorithm**\n\nLike other approaches we use negative numbers so that the maximum possible range of numbers is available to us.\n\nWe can no longer assume the divisor, that we're right shifting, is always an *even* number. Therefore, we need to add 1 before doing the right shift. Otherwise, it could be off by 1: `(divisor + 1) >> 1;`.\n\nNot all programming languages support *left* shifting with negative numbers. In those that do, we need to be really careful with overflows.\n\n<iframe src=\"https://leetcode.com/playground/beokfnEx/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"beokfnEx\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the absolute value of $$dividend$$.\n\n- Time Complexity : $$O(\\log \\, n)$$.\n\n    As we loop over the bits of our dividend, performing an $$O(1)$$ operation each time, the time complexity is just the number of bits of the dividend: $$O(\\log \\, n)$$.\n\n- Space Complexity : $$O(1)$$.\n\n    We only use a fixed number of int variables, so the space complexity is $$O(1)$$.\n\n</br>\n\n---\n\n#### Final Words\n\nThis question is quite difficult, and is one many people fear getting in an interview. If you get a question like this though, don't panic, but instead just work through it step-by-step.\n\nA good strategy for this particular question could be to first develop your algorithm to work with *positive integers*. In fact, you might like to even assume that the inputs could only possibly be positive integers. This removes a **lot** of the code at the start of the algorithm (remember how about half of most of the approaches was literally just generalising all the numbers to negatives?!).\n\nOnce you feel you have your approach working with positive integers, think about how you could adapt it to work with any integer inputs, and then to avoid overflow issues.\n\n</br>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "849",
            "count": 382,
            "average": "4.809",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "divide-two-integers",
    "playgroundData": {
        "LTaQQbMt": {
            "playground": {
                "testcaseInput": "",
                "name": "divide-integers-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "byTFoCVZ": {
            "playground": {
                "testcaseInput": "",
                "name": "divide-integers-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "KQX5ZJgM": {
            "playground": {
                "testcaseInput": "",
                "name": "divide-integers-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "CoaPpaEX": {
            "playground": {
                "testcaseInput": "",
                "name": "divide-integers-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "beokfnEx": {
            "playground": {
                "testcaseInput": "",
                "name": "divide-integers-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}