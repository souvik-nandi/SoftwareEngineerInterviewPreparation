{
    "id": "583",
    "question": {
        "questionId": "583",
        "questionFrontendId": "583",
        "boundTopicId": null,
        "title": "Delete Operation for Two Strings",
        "titleSlug": "delete-operation-for-two-strings",
        "content": "<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong> required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p>\n\n<p>In one <strong>step</strong>, you can delete exactly one character in either string.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;sea&quot;, word2 = &quot;eat&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist of only lowercase English letters.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 4211,
        "dislikes": 63,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Edit Distance\", \"titleSlug\": \"edit-distance\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum ASCII Delete Sum for Two Strings\", \"titleSlug\": \"minimum-ascii-delete-sum-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Common Subsequence\", \"titleSlug\": \"longest-common-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "\"sea\"\n\"eat\"\n\"leetcode\"\n\"etco\"",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minDistance(char * word1, char * word2){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinDistance(string word1, string word2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String} word1\n# @param {String} word2\n# @return {Integer}\ndef min_distance(word1, word2)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minDistance(_ word1: String, _ word2: String) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minDistance(word1 string, word2 string) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minDistance(word1: String, word2: String): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minDistance(word1: String, word2: String): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn min_distance(word1: String, word2: String) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return Integer\n     */\n    function minDistance($word1, $word2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minDistance(word1: string, word2: string): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (min-distance word1 word2)\n  (-> string? string? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec min_distance(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> integer().\nmin_distance(Word1, Word2) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec min_distance(word1 :: String.t, word2 :: String.t) :: integer\n  def min_distance(word1, word2) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"173.2K\", \"totalSubmission\": \"295.8K\", \"totalAcceptedRaw\": 173180, \"totalSubmissionRaw\": 295835, \"acRate\": \"58.5%\"}",
        "hints": [],
        "solution": {
            "id": "137",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "\"sea\"\n\"eat\"",
        "metaData": "{\r\n  \"name\": \"minDistance\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"word1\",\r\n      \"type\": \"string\"\r\n    },\r\n    {\r\n      \"name\": \"word2\",\r\n      \"type\": \"string\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "949",
            "date": "2022-06-14",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "137",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Approach #1 Using Longest Common Subsequence [Time Limit Exceeded]\n\n**Algorithm**\n\nIn order to determine the minimum number of delete operations needed, we can make use of the length of the longest common sequence among the two given strings $$s1$$ and $$s2$$, say given by $$lcs$$. If we can find this $$lcs$$ value, we can easily determine the required result as $$m + n - 2*lcs$$. Here, $$m$$ and $$n$$ refer to the length of the two given strings $$s1$$ and $$s2$$.\n\nThe above equation works because in case of complete mismatch(i.e. if the two strings can't be equalized at all), the total number of delete operations required will be $$m + n$$. Now, if there is a common sequence among the two strings of length $$lcs$$, we need to do $$lcs$$ lesser deletions in both the strings leading to a total of $$2lcs$$ lesser deletions, which then leads to the above equation.\n\nIn order to find the length of the longest common sequence, we make use of a recursive function `lcs(s1,s2,i,j)` which returns the length of the longest common sequence among the strings $$s1$$ and $$s2$$ considering their lengths upto $$i$$ and $$j$$ respectively. For evaluating the function, we check if the characters $$s1[m-1]$$ and $$s2[n-1]$$ for equality. If they match, we can consider the corresponding strings upto 1 lesser lengths since the last characters have already been considered and add 1 to the result to be returned for strings of 1 lesser lengths. Thus, we make the function call `lcs(s1, s2, i-1, j-1)`. \n\nIf the last characters don't match, we have two options, either we can consider the second last character of $$s1$$ and the last character of $$s2$$, or we can consider the second last character of $$s2$$ and the last character of $$s1$$. We need to consider the larger result obtained out of the two considerations for getting the required length. \n\nThus, the function call `lcs(s1,s2,m,n)` returns the required $$lcs$$ value.\n\n<iframe src=\"https://leetcode.com/playground/QCLZ3ajV/shared\" frameBorder=\"0\" name=\"QCLZ3ajV\" width=\"100%\" height=\"309\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(2^{max(m,n)})$$. Size of recursion tree will be $$2^(m+n)$$. Here, $$m$$ and $$n$$ refer to the lengths of $$s1$$ and $$s2$$ respectively.\n\n* Space complexity : $$O(\\text{max}(m,n))$$. The depth of the recursion tree will go upto $$\\text{max}(m,n)$$.\n\n---\n\n#### Approach #2 Longest Common Subsequence with Memoization [Accepted]\n\n**Algorithm**\n\nWe can observe that in the last approach, while determining the $$lcs$$ value, a lot of redundant function calls are made, since the same $$m$$ and $$n$$ values to be used for the function calls could be obtained going through many different paths. We can remove this redundancy by making use of a $$memo$$ array to store the value to be returned for these function calls if they have been called once with the corresponding parameters. Thus, $$memo[i][j]$$ is used to store the result for the function call `lcs(s1,s2,i,j)`.\n\nThus, by returning the already stored values from the $$memo$$ array, we can prune the search space to a great extent.\n\n<iframe src=\"https://leetcode.com/playground/dPT69gpC/shared\" frameBorder=\"0\" name=\"dPT69gpC\" width=\"100%\" height=\"377\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. $$memo$$ array of size $$m$$x$$n$$ needs to be filled once. Here, $$m$$ and $$n$$ refer to the length of the strings $$s1$$ and $$s2$$ respectively.\n\n* Space complexity : $$O(m*n)$$. $$memo$$ array of size $$m$$x$$n$$ is used. Also, The depth of the recursion tree will go upto $$\\text{max}(m,n)$$.\n\n---\n\n#### Approach #3 Using Longest Common Subsequence- Dynamic Programming [Accepted]\n\n**Algorithm**\n\nAnother method to obtain the value of $$lcs$$ is to make use of Dynamic Programming. We'll look at the implemenation and carry-on alongside the idea behind it.\n\nWe make use of a 2-D $$dp$$, in which $$dp[i][j]$$ represents the length of the longest common subsequence among the strings $$s1$$ and $$s2$$ considering their lengths upto $$(i-1)^{th}$$ index and $$(j-1)^{th}$$ index only respectively. We fill the $$dp$$ array in row-by-row order.\n\nIn order to fill the entry for $$dp[i][j]$$, we can have two cases:\n\n1. The characters $$s1[i-1]$$ and $$s2[j-1]$$ match with each other. In this case, the entry for $$dp[i][j]$$ will be one more than the entry obtained for the strings considering their lengths upto one lesser index, since the matched character adds one to the length of LCS formed till the current indices. Thus, the $$dp[i][j]$$ entry is updated as $$dp[i][j] = 1 + dp[i-1][j-1]$$. Note that $$dp[i-1][j-1]$$ has been used because the matched character belongs to both $$s1$$ and $$s2$$.\n\n2. The characters $$s1[i-1]$$ and $$s2[j-1]$$ don't match with each other. In this case, we can't increment the current entry as compared to entries corresponding to the previous indices, but we need to replicate the previous entry again to indicate that the length of LCS upto the current indices also remains the same. But, which entry to pick up? Now, since the current character hasn't matched, we have got two options. We can remove the current character from consideration from either $$s1$$ or $$s2$$ and use the corresponding $$dp$$ entries given by $$dp[i-1][j]$$ and $$dp[i][j-1]$$ respectively. Since we are considering the length of LCS upto the current indices we need to pick up the larger entry out of these two to update the current $$dp$$ entry.\n\nAt the end, again, we obtain the number of deletions required as $$m + n - 2*dp[m][n]$$, where $$m$$ and $$n$$ refer to the lengths of $$s1$$ and $$s2$$. $$dp[m][n]$$ now refers to the length of LCS among the two given strings.\n\n!?!../Documents/583_Delete1.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/xQZCgSyw/shared\" frameBorder=\"0\" name=\"xQZCgSyw\" width=\"100%\" height=\"326\"></iframe>\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. We need to fill in the $$dp$$ array of size $$m$$x$$n$$. Here, $$m$$ and $$n$$ refer to the lengths of $$s1$$ and $$s2$$.\n\n* Space complexity : $$O(m*n)$$. $$dp$$ array of size $$m$$x$$n$$ is used.\n\n---\n\n#### Approach #4 Without using LCS Dynamic Programmming [Accepted]:\n\n**Algorithm**\n\nInstead of finding the length of LCS and then determining the number of deletions required, we can make use of Dynamic Programming to directly determine the number of deletions required till the current indices of the strings.\n\nIn order to do so, we make use of a 2-D $$dp$$ array. Now, $$dp[i][j]$$ refers to the number of deletions required to equalize the two strings if we consider the strings' length upto $$(i-1)^{th}$$ index and $$(j-1)^{th}$$ index for $$s1$$ and $$s2$$ respectively. Again, we fill in the $$dp$$ array in a row-by-row order. Now, in order to fill the entry for $$dp[i][j]$$, we need to consider two cases only:\n\n1. The characters $$s1[i-1]$$ and $$s2[j-1]$$ match with each other. In this case, we need to replicate the entry corresponding to $$dp[i-1][j-1]$$ itself. This is because, the matched character doesn't need to be deleted from any of the strings.\n\n2. The characters $$s1[i-1]$$ and $$s2[j-1]$$ don't match with each other. In this case, we need to delete either the current character of $$s1$$ or $$s2$$. Thus, an increment of 1 needs to be done relative to the entries corresponding to the previous indices. The two options available at this moment are $$dp[i-1][j]$$ and $$dp[i][j-1]$$. Since, we are keeping track of the minimum number of deletions required, we pick up the minimum out of these two values.\n\nAt the end, $$dp[m][n]$$ gives the required minimum number of deletions. Here, $$m$$ and $$n$$ refer to the lengths of $$s1$$ and $$s2$$.\n\n!?!../Documents/583_Delete2.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/aPU8b3Fd/shared\" frameBorder=\"0\" name=\"aPU8b3Fd\" width=\"100%\" height=\"326\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. We need to fill in the $$dp$$ array of size $$m$$x$$n$$. Here, $$m$$ and $$n$$ refer to the lengths of $$s1$$ and $$s2$$.\n\n* Space complexity : $$O(m*n)$$. $$dp$$ array of size $$m$$x$$n$$ is used.\n\n---\n\n#### Approach #5 1-D Dynamic Programming [Accepted]:\n\n**Algorithm**\n\nWe can observe that in the last approach, in order to update the current $$dp$$ entries, we need only the values of the previous row of $$dp$$. Thus, rather than using a 2-D array, we can do the same job by making use of a 1-D $$dp$$ array.\n\nThus, now, $$dp[i]$$ refers to the number of deletions that need to be made in order to equalize the strings $$s1$$ and $$s2$$ if we consider string $$s1$$ upto the $$(i-1)^{th}$$ index and string $$s2$$ upto the last to current index of $$s2$$. \n\nNow, we make the updations for the current row in an array $$temp$$ of the same size as $$dp$$, and use the $$dp$$ entries as if they correspond to the previous row's entries. When, the whole $$temp$$ array has been filled, we copy it the $$dp$$ array so that $$dp$$ array now reflects the new row's entries.\n\n<iframe src=\"https://leetcode.com/playground/jfeuFUeS/shared\" frameBorder=\"0\" name=\"jfeuFUeS\" width=\"100%\" height=\"360\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. We need to fill in the $$dp$$ array of size $$n$$, $$m$$ times. Here, $$m$$ and $$n$$ refer to the lengths of $$s1$$ and $$s2$$.\n\n* Space complexity : $$O(n)$$. $$dp$$ array of size $$n$$ is used.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "130",
            "count": 107,
            "average": "4.682",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "delete-operation-for-two-strings",
    "playgroundData": {
        "QCLZ3ajV": {
            "playground": {
                "testcaseInput": "",
                "name": "583_delete_operationmd5",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "dPT69gpC": {
            "playground": {
                "testcaseInput": "",
                "name": "583_delete_operationmd4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "xQZCgSyw": {
            "playground": {
                "testcaseInput": "",
                "name": "583_delete_operationmd3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "aPU8b3Fd": {
            "playground": {
                "testcaseInput": "",
                "name": "583_delete_operationmd2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "jfeuFUeS": {
            "playground": {
                "testcaseInput": "",
                "name": "583_delete_operationmd1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}