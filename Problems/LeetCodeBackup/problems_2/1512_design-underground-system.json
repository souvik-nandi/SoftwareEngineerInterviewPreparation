{
    "id": "1512",
    "question": {
        "questionId": "1512",
        "questionFrontendId": "1396",
        "boundTopicId": null,
        "title": "Design Underground System",
        "titleSlug": "design-underground-system",
        "content": "<p>An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.</p>\n\n<p>Implement the <code>UndergroundSystem</code> class:</p>\n\n<ul>\n\t<li><code>void checkIn(int id, string stationName, int t)</code>\n\n\t<ul>\n\t\t<li>A customer with a card ID equal to <code>id</code>, checks in at the station <code>stationName</code> at time <code>t</code>.</li>\n\t\t<li>A customer can only be checked into one place at a time.</li>\n\t</ul>\n\t</li>\n\t<li><code>void checkOut(int id, string stationName, int t)</code>\n\t<ul>\n\t\t<li>A customer with a card ID equal to <code>id</code>, checks out from the station <code>stationName</code> at time <code>t</code>.</li>\n\t</ul>\n\t</li>\n\t<li><code>double getAverageTime(string startStation, string endStation)</code>\n\t<ul>\n\t\t<li>Returns the average time it takes to travel from <code>startStation</code> to <code>endStation</code>.</li>\n\t\t<li>The average time is computed from all the previous traveling times from <code>startStation</code> to <code>endStation</code> that happened <strong>directly</strong>, meaning a check in at <code>startStation</code> followed by a check out from <code>endStation</code>.</li>\n\t\t<li>The time it takes to travel from <code>startStation</code> to <code>endStation</code> <strong>may be different</strong> from the time it takes to travel from <code>endStation</code> to <code>startStation</code>.</li>\n\t\t<li>There will be at least one customer that has traveled from <code>startStation</code> to <code>endStation</code> before <code>getAverageTime</code> is called.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>You may assume all calls to the <code>checkIn</code> and <code>checkOut</code> methods are consistent. If a customer checks in at time <code>t<sub>1</sub></code> then checks out at time <code>t<sub>2</sub></code>, then <code>t<sub>1</sub> &lt; t<sub>2</sub></code>. All events happen in chronological order.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;getAverageTime&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;]\n[[],[45,&quot;Leyton&quot;,3],[32,&quot;Paradise&quot;,8],[27,&quot;Leyton&quot;,10],[45,&quot;Waterloo&quot;,15],[27,&quot;Waterloo&quot;,20],[32,&quot;Cambridge&quot;,22],[&quot;Paradise&quot;,&quot;Cambridge&quot;],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Leyton&quot;,24],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Waterloo&quot;,38],[&quot;Leyton&quot;,&quot;Waterloo&quot;]]\n\n<strong>Output</strong>\n[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]\n\n<strong>Explanation</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(45, &quot;Leyton&quot;, 3);\nundergroundSystem.checkIn(32, &quot;Paradise&quot;, 8);\nundergroundSystem.checkIn(27, &quot;Leyton&quot;, 10);\nundergroundSystem.checkOut(45, &quot;Waterloo&quot;, 15);  // Customer 45 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 15-3 = 12\nundergroundSystem.checkOut(27, &quot;Waterloo&quot;, 20);  // Customer 27 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 20-10 = 10\nundergroundSystem.checkOut(32, &quot;Cambridge&quot;, 22); // Customer 32 &quot;Paradise&quot; -&gt; &quot;Cambridge&quot; in 22-8 = 14\nundergroundSystem.getAverageTime(&quot;Paradise&quot;, &quot;Cambridge&quot;); // return 14.00000. One trip &quot;Paradise&quot; -&gt; &quot;Cambridge&quot;, (14) / 1 = 14\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 11.00000. Two trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12) / 2 = 11\nundergroundSystem.checkIn(10, &quot;Leyton&quot;, 24);\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 11.00000\nundergroundSystem.checkOut(10, &quot;Waterloo&quot;, 38);  // Customer 10 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 38-24 = 14\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 12.00000. Three trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12 + 14) / 3 = 12\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;]\n[[],[10,&quot;Leyton&quot;,3],[10,&quot;Paradise&quot;,8],[&quot;Leyton&quot;,&quot;Paradise&quot;],[5,&quot;Leyton&quot;,10],[5,&quot;Paradise&quot;,16],[&quot;Leyton&quot;,&quot;Paradise&quot;],[2,&quot;Leyton&quot;,21],[2,&quot;Paradise&quot;,30],[&quot;Leyton&quot;,&quot;Paradise&quot;]]\n\n<strong>Output</strong>\n[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]\n\n<strong>Explanation</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(10, &quot;Leyton&quot;, 3);\nundergroundSystem.checkOut(10, &quot;Paradise&quot;, 8); // Customer 10 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 8-3 = 5\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 5.00000, (5) / 1 = 5\nundergroundSystem.checkIn(5, &quot;Leyton&quot;, 10);\nundergroundSystem.checkOut(5, &quot;Paradise&quot;, 16); // Customer 5 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 16-10 = 6\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 5.50000, (5 + 6) / 2 = 5.5\nundergroundSystem.checkIn(2, &quot;Leyton&quot;, 21);\nundergroundSystem.checkOut(2, &quot;Paradise&quot;, 30); // Customer 2 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 30-21 = 9\nundergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= id, t &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code></li>\n\t<li>All strings consist of uppercase and lowercase English letters and digits.</li>\n\t<li>There will be at most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> to <code>checkIn</code>, <code>checkOut</code>, and <code>getAverageTime</code>.</li>\n\t<li>Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 2128,
        "dislikes": 105,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Design Bitset\", \"titleSlug\": \"design-bitset\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"]\n[[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]]\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Design",
                "slug": "design",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 72}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Barclays\", \"slug\": \"barclays\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class UndergroundSystem {\npublic:\n    UndergroundSystem() {\n        \n    }\n    \n    void checkIn(int id, string stationName, int t) {\n        \n    }\n    \n    void checkOut(int id, string stationName, int t) {\n        \n    }\n    \n    double getAverageTime(string startStation, string endStation) {\n        \n    }\n};\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * UndergroundSystem* obj = new UndergroundSystem();\n * obj->checkIn(id,stationName,t);\n * obj->checkOut(id,stationName,t);\n * double param_3 = obj->getAverageTime(startStation,endStation);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class UndergroundSystem {\n\n    public UndergroundSystem() {\n        \n    }\n    \n    public void checkIn(int id, String stationName, int t) {\n        \n    }\n    \n    public void checkOut(int id, String stationName, int t) {\n        \n    }\n    \n    public double getAverageTime(String startStation, String endStation) {\n        \n    }\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * UndergroundSystem obj = new UndergroundSystem();\n * obj.checkIn(id,stationName,t);\n * obj.checkOut(id,stationName,t);\n * double param_3 = obj.getAverageTime(startStation,endStation);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class UndergroundSystem(object):\n\n    def __init__(self):\n        \n\n    def checkIn(self, id, stationName, t):\n        \"\"\"\n        :type id: int\n        :type stationName: str\n        :type t: int\n        :rtype: None\n        \"\"\"\n        \n\n    def checkOut(self, id, stationName, t):\n        \"\"\"\n        :type id: int\n        :type stationName: str\n        :type t: int\n        :rtype: None\n        \"\"\"\n        \n\n    def getAverageTime(self, startStation, endStation):\n        \"\"\"\n        :type startStation: str\n        :type endStation: str\n        :rtype: float\n        \"\"\"\n        \n\n\n# Your UndergroundSystem object will be instantiated and called as such:\n# obj = UndergroundSystem()\n# obj.checkIn(id,stationName,t)\n# obj.checkOut(id,stationName,t)\n# param_3 = obj.getAverageTime(startStation,endStation)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class UndergroundSystem:\n\n    def __init__(self):\n        \n\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\n        \n\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\n        \n\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\n        \n\n\n# Your UndergroundSystem object will be instantiated and called as such:\n# obj = UndergroundSystem()\n# obj.checkIn(id,stationName,t)\n# obj.checkOut(id,stationName,t)\n# param_3 = obj.getAverageTime(startStation,endStation)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n\ntypedef struct {\n    \n} UndergroundSystem;\n\n\nUndergroundSystem* undergroundSystemCreate() {\n    \n}\n\nvoid undergroundSystemCheckIn(UndergroundSystem* obj, int id, char * stationName, int t) {\n  \n}\n\nvoid undergroundSystemCheckOut(UndergroundSystem* obj, int id, char * stationName, int t) {\n  \n}\n\ndouble undergroundSystemGetAverageTime(UndergroundSystem* obj, char * startStation, char * endStation) {\n  \n}\n\nvoid undergroundSystemFree(UndergroundSystem* obj) {\n    \n}\n\n/**\n * Your UndergroundSystem struct will be instantiated and called as such:\n * UndergroundSystem* obj = undergroundSystemCreate();\n * undergroundSystemCheckIn(obj, id, stationName, t);\n \n * undergroundSystemCheckOut(obj, id, stationName, t);\n \n * double param_3 = undergroundSystemGetAverageTime(obj, startStation, endStation);\n \n * undergroundSystemFree(obj);\n*/",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class UndergroundSystem {\n\n    public UndergroundSystem() {\n        \n    }\n    \n    public void CheckIn(int id, string stationName, int t) {\n        \n    }\n    \n    public void CheckOut(int id, string stationName, int t) {\n        \n    }\n    \n    public double GetAverageTime(string startStation, string endStation) {\n        \n    }\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * UndergroundSystem obj = new UndergroundSystem();\n * obj.CheckIn(id,stationName,t);\n * obj.CheckOut(id,stationName,t);\n * double param_3 = obj.GetAverageTime(startStation,endStation);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "\nvar UndergroundSystem = function() {\n    \n};\n\n/** \n * @param {number} id \n * @param {string} stationName \n * @param {number} t\n * @return {void}\n */\nUndergroundSystem.prototype.checkIn = function(id, stationName, t) {\n    \n};\n\n/** \n * @param {number} id \n * @param {string} stationName \n * @param {number} t\n * @return {void}\n */\nUndergroundSystem.prototype.checkOut = function(id, stationName, t) {\n    \n};\n\n/** \n * @param {string} startStation \n * @param {string} endStation\n * @return {number}\n */\nUndergroundSystem.prototype.getAverageTime = function(startStation, endStation) {\n    \n};\n\n/** \n * Your UndergroundSystem object will be instantiated and called as such:\n * var obj = new UndergroundSystem()\n * obj.checkIn(id,stationName,t)\n * obj.checkOut(id,stationName,t)\n * var param_3 = obj.getAverageTime(startStation,endStation)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "class UndergroundSystem\n    def initialize()\n        \n    end\n\n\n=begin\n    :type id: Integer\n    :type station_name: String\n    :type t: Integer\n    :rtype: Void\n=end\n    def check_in(id, station_name, t)\n        \n    end\n\n\n=begin\n    :type id: Integer\n    :type station_name: String\n    :type t: Integer\n    :rtype: Void\n=end\n    def check_out(id, station_name, t)\n        \n    end\n\n\n=begin\n    :type start_station: String\n    :type end_station: String\n    :rtype: Float\n=end\n    def get_average_time(start_station, end_station)\n        \n    end\n\n\nend\n\n# Your UndergroundSystem object will be instantiated and called as such:\n# obj = UndergroundSystem.new()\n# obj.check_in(id, station_name, t)\n# obj.check_out(id, station_name, t)\n# param_3 = obj.get_average_time(start_station, end_station)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "\nclass UndergroundSystem {\n\n    init() {\n        \n    }\n    \n    func checkIn(_ id: Int, _ stationName: String, _ t: Int) {\n        \n    }\n    \n    func checkOut(_ id: Int, _ stationName: String, _ t: Int) {\n        \n    }\n    \n    func getAverageTime(_ startStation: String, _ endStation: String) -> Double {\n        \n    }\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * let obj = UndergroundSystem()\n * obj.checkIn(id, stationName, t)\n * obj.checkOut(id, stationName, t)\n * let ret_3: Double = obj.getAverageTime(startStation, endStation)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "type UndergroundSystem struct {\n    \n}\n\n\nfunc Constructor() UndergroundSystem {\n    \n}\n\n\nfunc (this *UndergroundSystem) CheckIn(id int, stationName string, t int)  {\n    \n}\n\n\nfunc (this *UndergroundSystem) CheckOut(id int, stationName string, t int)  {\n    \n}\n\n\nfunc (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 {\n    \n}\n\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * obj := Constructor();\n * obj.CheckIn(id,stationName,t);\n * obj.CheckOut(id,stationName,t);\n * param_3 := obj.GetAverageTime(startStation,endStation);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "class UndergroundSystem() {\n\n    def checkIn(id: Int, stationName: String, t: Int) {\n        \n    }\n\n    def checkOut(id: Int, stationName: String, t: Int) {\n        \n    }\n\n    def getAverageTime(startStation: String, endStation: String): Double = {\n        \n    }\n\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * var obj = new UndergroundSystem()\n * obj.checkIn(id,stationName,t)\n * obj.checkOut(id,stationName,t)\n * var param_3 = obj.getAverageTime(startStation,endStation)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class UndergroundSystem() {\n\n    fun checkIn(id: Int, stationName: String, t: Int) {\n        \n    }\n\n    fun checkOut(id: Int, stationName: String, t: Int) {\n        \n    }\n\n    fun getAverageTime(startStation: String, endStation: String): Double {\n        \n    }\n\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * var obj = UndergroundSystem()\n * obj.checkIn(id,stationName,t)\n * obj.checkOut(id,stationName,t)\n * var param_3 = obj.getAverageTime(startStation,endStation)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "struct UndergroundSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl UndergroundSystem {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn check_in(&self, id: i32, station_name: String, t: i32) {\n        \n    }\n    \n    fn check_out(&self, id: i32, station_name: String, t: i32) {\n        \n    }\n    \n    fn get_average_time(&self, start_station: String, end_station: String) -> f64 {\n        \n    }\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * let obj = UndergroundSystem::new();\n * obj.check_in(id, stationName, t);\n * obj.check_out(id, stationName, t);\n * let ret_3: f64 = obj.get_average_time(startStation, endStation);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class UndergroundSystem {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $id\n     * @param String $stationName\n     * @param Integer $t\n     * @return NULL\n     */\n    function checkIn($id, $stationName, $t) {\n        \n    }\n  \n    /**\n     * @param Integer $id\n     * @param String $stationName\n     * @param Integer $t\n     * @return NULL\n     */\n    function checkOut($id, $stationName, $t) {\n        \n    }\n  \n    /**\n     * @param String $startStation\n     * @param String $endStation\n     * @return Float\n     */\n    function getAverageTime($startStation, $endStation) {\n        \n    }\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * $obj = UndergroundSystem();\n * $obj->checkIn($id, $stationName, $t);\n * $obj->checkOut($id, $stationName, $t);\n * $ret_3 = $obj->getAverageTime($startStation, $endStation);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "class UndergroundSystem {\n    constructor() {\n\n    }\n\n    checkIn(id: number, stationName: string, t: number): void {\n\n    }\n\n    checkOut(id: number, stationName: string, t: number): void {\n\n    }\n\n    getAverageTime(startStation: string, endStation: string): number {\n\n    }\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * var obj = new UndergroundSystem()\n * obj.checkIn(id,stationName,t)\n * obj.checkOut(id,stationName,t)\n * var param_3 = obj.getAverageTime(startStation,endStation)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define underground-system%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; check-in : exact-integer? string? exact-integer? -> void?\n    (define/public (check-in id station-name t)\n\n      )\n    ; check-out : exact-integer? string? exact-integer? -> void?\n    (define/public (check-out id station-name t)\n\n      )\n    ; get-average-time : string? string? -> flonum?\n    (define/public (get-average-time start-station end-station)\n\n      )))\n\n;; Your underground-system% object will be instantiated and called as such:\n;; (define obj (new underground-system%))\n;; (send obj check-in id station-name t)\n;; (send obj check-out id station-name t)\n;; (define param_3 (send obj get-average-time start-station end-station))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec underground_system_init_() -> any().\nunderground_system_init_() ->\n  .\n\n-spec underground_system_check_in(Id :: integer(), StationName :: unicode:unicode_binary(), T :: integer()) -> any().\nunderground_system_check_in(Id, StationName, T) ->\n  .\n\n-spec underground_system_check_out(Id :: integer(), StationName :: unicode:unicode_binary(), T :: integer()) -> any().\nunderground_system_check_out(Id, StationName, T) ->\n  .\n\n-spec underground_system_get_average_time(StartStation :: unicode:unicode_binary(), EndStation :: unicode:unicode_binary()) -> float().\nunderground_system_get_average_time(StartStation, EndStation) ->\n  .\n\n\n%% Your functions will be called as such:\n%% underground_system_init_(),\n%% underground_system_check_in(Id, StationName, T),\n%% underground_system_check_out(Id, StationName, T),\n%% Param_3 = underground_system_get_average_time(StartStation, EndStation),\n\n%% underground_system_init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule UndergroundSystem do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec check_in(id :: integer, station_name :: String.t, t :: integer) :: any\n  def check_in(id, station_name, t) do\n\n  end\n\n  @spec check_out(id :: integer, station_name :: String.t, t :: integer) :: any\n  def check_out(id, station_name, t) do\n\n  end\n\n  @spec get_average_time(start_station :: String.t, end_station :: String.t) :: float\n  def get_average_time(start_station, end_station) do\n\n  end\nend\n\n# Your functions will be called as such:\n# UndergroundSystem.init_()\n# UndergroundSystem.check_in(id, station_name, t)\n# UndergroundSystem.check_out(id, station_name, t)\n# param_3 = UndergroundSystem.get_average_time(start_station, end_station)\n\n# UndergroundSystem.init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"138.9K\", \"totalSubmission\": \"188.8K\", \"totalAcceptedRaw\": 138905, \"totalSubmissionRaw\": 188773, \"acRate\": \"73.6%\"}",
        "hints": [
            "Use two hash tables. The first to save the check-in time for a customer and the second to update the total time between two stations."
        ],
        "solution": {
            "id": "921",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"]\n[[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]]",
        "metaData": "{\n  \"classname\": \"UndergroundSystem\",\n  \"constructor\": {\n    \"params\": []\n  },\n  \"methods\": [\n    {\n      \"params\": [\n        {\n          \"type\": \"integer\",\n          \"name\": \"id\"\n        },\n        {\n          \"type\": \"string\",\n          \"name\": \"stationName\"\n        },\n        {\n          \"type\": \"integer\",\n          \"name\": \"t\"\n        }\n      ],\n      \"name\": \"checkIn\",\n      \"return\": {\n        \"type\": \"void\"\n      }\n    },\n    {\n      \"params\": [\n        {\n          \"type\": \"integer\",\n          \"name\": \"id\"\n        },\n        {\n          \"type\": \"string\",\n          \"name\": \"stationName\"\n        },\n        {\n          \"type\": \"integer\",\n          \"name\": \"t\"\n        }\n      ],\n      \"name\": \"checkOut\",\n      \"return\": {\n        \"type\": \"void\"\n      }\n    },\n    {\n      \"params\": [\n        {\n          \"type\": \"string\",\n          \"name\": \"startStation\"\n        },\n        {\n          \"type\": \"string\",\n          \"name\": \"endStation\"\n        }\n      ],\n      \"name\": \"getAverageTime\",\n      \"return\": {\n        \"type\": \"double\"\n      }\n    }\n  ],\n  \"return\": {\n    \"type\": \"boolean\"\n  },\n  \"systemdesign\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "888",
            "date": "2022-04-24",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "921",
        "content": "[TOC]\n\n## Solution\n\n---\n\nIf you were asked this question in a real interview, you should expect to discuss real-world issues related to it. For example, it would not be realistic to store the data in volatile computer memory. In practice, computers fail (e.g. lose power) so we need to store the data in a permanent medium, such as a database. \n\nAdditionally, we might need to consider scalability. In a large city, such as Tokyo, the metro system gets 7 million passenger trips per day! With a little math, we can quickly estimate that during peak travel time, there must be *thousands* of check-ins and check-outs every *second*. This is a lot of data that one computer would need to receive through its network connection! To make this work, we'd probably be using more than one computer. This introduces concurrency issues that would need to be addressed.\n\nIt's also likely that this module would have to fit in with other code in the passenger-tracking system. It's not likely that a little average time tracker will get exclusive use of all resources.\n\nFor your actual implementation, you'll probably be expected to use `HashMap`s. This is common in system design interview questions: you're given a complex real world problem to explore and then are asked to implement a small piece of it.\n\n<br/>\n\n---\n\n#### Approach 1: Two HashMaps\n\n**Intuition**\n\nThe first thing to do when faced with a design problem like this one is to carefully read through what each of the methods needs to do. Observe that two of the methods take input but don't return anything; `checkIn(...)` and `checkOut(...)`. On the other hand, the `getAverageTime(...)` method both takes input and returns a value. \n\nThis effectively means that there's only one place the data structure needs to *output* data. Therefore, a good place to start is by looking at what exactly `getAverageTime(...)` needs to return, and what it needs to do this. `getAverageTime(...)` takes two input parameters; a start station and an end station. It then needs to return the average trip time between these two stations. This means that we need to somehow obtain \"trip times\", collated by a pair of stations; start and end. We could represent this data as a table of some kind. We'll talk more about this in a bit!\n\n![Table of sample trip times](../Figures/1396/trip_times.png)\n\nThe \"trip times\" are obtained, unsurprisingly, through the `checkIn(...)` and `checkOut(...)` methods. A customer with a given `id` checks into station `stationName` at time `t`, using the `checkIn(...)` method. At some point in the future, the customer checks out with the `checkOut(...)` method. The input to the `checkOut(...)` method is the same `id`, but a different `stationName` and `t`, representing the exit station and exit time. The start station, end station, start time, and end time (that were all under the same `id`) can be used to calculate a journey time between the start station and end station, that could be entered into the table we discussed above.\n\n![Table of sample check in times and stations](../Figures/1396/check_in_table.png)\n\nThe `checkIn(...)` and `checkOut(...)` method calls for a customer with a particular `id` aren't necessarily made one-after-the-other. In fact, many other customers could have been processed in-between. We'll need to store the entry station and time that go with a particular customer `id` so that we can then get them back when that same customer `id` does a `checkOut(...)`. One way we could do this is to use `HashMap`s to map `id`s to check-in stations and times.\n\n```text\n\naveragesTable = a table of some kind\ncheckInTimes = a new HashMap (id -> checkInTime)\ncheckInStations = a new HashMap (id -> stationName)\n \ndefine function checkIn(id, stationName, t):\n    checkInTimes.put(id, t)\n    checkInStations.put(id, stationName)\n\ndefine function checkOut(id, stationName, t):\n    startTime = checkInTimes.get(id)\n    startStation = checkInStations.get(id)\n    journeyTime = t - startTime\n    journey = (startTime, startStation)\n    # We'll worry about how exactly this bit works soon...\n    averagesTable.enter(journey, journeyTime)\n```\n\nNow when `getAverageTime(...)` is called, we can look in `averagesTable` for the information needed to answer the query. Let's go back to looking at how we could represent the `averagesTable`.\n\nOne way is to use a `HashMap` that maps pairs of stations to `List`s of journey times. Then when `getAverageTime(...)` is called, it could look up the relevant `List`, add the times in it together, and then divide by the number of times that were in the list (this is the standard way of calculating an average).\n\n![Table of sample trip times with average time column](../Figures/1396/trip_times_with_average_time.png)\n\nInstead of needing to add them up every time though, we could just store the total so far. This will work fine, seeing as we never need to re-access the individual journey times. If we do this, we'll also need to store the total number of journeys. Then with these 2 pieces of information, we can calculate the average time with $$O(1)$$ time complexity. This is a lot better than storing a list of individual journey times; repeated calls to `getAverageTime(...)` would have, in the worst case, repeatedly added thousands of times together. \n\nOur `checkOut(...)` function should be modified as follows.\n\n```text\njourneyTotals = a new HashMap (startStation, endStation -> total)\nnumberOfJourneys = a new HashMap (startStation, endStation -> count) \n\ndefine function checkOut(id, stationName, t):\n    startTime = checkInTimes.get(id)\n    startStation = checkInStations.get(id)\n    journeyTime = t - startTime\n    journey = (startTime, startStation)\n    set journeyTotals.get(journey) to journeyTotals.get(journey) + journeyTime\n    set numberOfJourneys.get(journey) to numberOfJourneys.get(journey) + 1\n```\n\nUsing these new data structures, `getAverageTime(...)` can be implemented as follows.\n\n```text\ndefine function getAverageTime(startStation, endStation):\n    journey = (startTime, startStation)\n    total = journeyTotals.get(journey)\n    count = numberOfJourneys.get(journey)\n    return total / count\n```\n\nOne detail we overlooked earlier was deleting data from `checkInTimes` and `checkInStations` after the corresponding call to `checkOut(...)`. Seeing as we can assume `checkIn(...)` and `checkOut(...)` calls are always valid, we know that if the user with `id` comes back later, after doing their `checkOut(...)`, that they must now be doing a `checkIn(...)`. This will *overwrite* the *old* check-in data, without causing any issues. In short, we don't *have* to explicitly delete the old data.\n\nHowever, it would actually be better to delete the data. We don't need it (hence the reason it being overwritten isn't an issue), and in fact keeping it around will slowly increase the memory usage of the program over time. This is because every `id` that had ever used the program will have an entry in the check-in tables. If, instead, we delete the old entries, then only `id`s that are currently undergoing a journey (have checked-in but not checked-out) will be in the table. Removing old entries is an $$O(1)$$ time complexity operation. Therefore, it's best to remove the entries to save memory.\n\n**Algorithm**\n\nSome of the implementation design decisions here have no \"right\" answer.\n\n***Saving the total time vs the average time***\n\nOne design decision we need to make is whether to *store* the total-time or the average-time for each possible route. The benefit of storing the average-time is that the system will be able to store a lot more data before being affected by overflow (remember, the total-count is always *eventually* going to be affected). The downside of storing average-time though is that we need to update it with division every time a new journey is made on that route. This leads to compounded floating-point error. \n\nGiven that overflow isn't an issue with the problem constraints we're given here, it's safest to store the total-time so that we can avoid the floating-point error. In a real world system, you would use a `Decimal` library that supports arbitrary precision and doesn't suffer from floating-point error.\n\n***Number of HashMaps to use***\n\nIn the discussion above, we broke the data into 4 separate `HashMaps`. While this would be an okay way to implement it, we often group similar data together. This would give us the following two `HashMaps`:\n\n```text\ncheckInData = a new HashMap (id -> startStation, checkInTime)\njourneyData = a new HashMap (startStation, endStation -> total, count)\n```\n\nIn a realistic system, there's likely to be more operations than just `getAverageTime(...)`, and the data will likely be put into and pulled from a database. Database design is another massive area of system design where many factors need to be taken into account to come up with the design that best achieves what is needed for the particular queries that will need to be answered.\n\nHere, we chose to use the `Pair` class for the Java implementation, but whether or not this is good design is probably down to personal preference. It does have the benefit of being less code to write (and less whiteboard space in an interview!). However, it is a bit contextually strange that one member of the `Pair` is known as \"the key\" and the other as \"the value\".\n\nWhere we need to represent a key with both a start station and an end station, the code below appends the strings with a `->` between them to make a single string. This is safe for the constraints we're given, as station names can only be letters or numbers. In a real world system, this would need to be thought through carefully. In Python, we can simply use a tuple as the key (without the code becoming needlessly verbose).\n\nOther options would include using nested `HashMaps` or defining your own objects.\n\n<iframe src=\"https://leetcode.com/playground/HNjQCvno/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"HNjQCvno\"></iframe>\n\n\n**Complexity Analysis**\n\n- Time complexity : $$O(1)$$ for all.\n\n    - `checkIn(...)`: Inserting a key/value pair into a `HashMap` is an $$O(1)$$ operation.  \n\n    - `checkOut(...)`: Additionally, getting the corresponding value for a key from a `HashMap` is also an $$O(1)$$ operation.\n\n    - `getAverageTime(...)`: Dividing two numbers is also an $$O(1)$$ operation.\n\n- Space complexity : $$O(P + S^2)$$, where $$S$$ is the number of stations on the network, and $$P$$ is the number of passengers making a journey concurrently during peak time.\n\n    - The program uses two `HashMap`s. We need to determine the maximum sizes these could become.\n\n    - Firstly, we'll consider `checkInData`. This `HashMap` holds one entry for each passenger who has `checkIn(...)`ed, but not `checkOut(...)`ed. Therefore, the maximum size this `HashMap` could be is the maximum possible number of passengers making a journey at the same time, which we defined to be $$P$$. Therefore, the size of this `HashMap` is $$O(P)$$.\n\n    - Secondly, we need to consider `journeyData`. This `HashMap` has one entry for each pair of stations that has had at least one passenger start and end a journey at those stations. Over time, we could reasonably expect every possible pair of the $$S$$ stations on the network to have an entry in this `HashMap`, which would be $$O(S^2)$$.\n\n    - Seeing as we don't know whether $$S^2$$ or $$P$$ is larger, we need to add these together, giving a total space complexity of $$O(P + S^2)$$.\n\n<br/>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "869",
            "count": 85,
            "average": "4.788",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "design-underground-system",
    "playgroundData": {
        "HNjQCvno": {
            "playground": {
                "testcaseInput": "",
                "name": "design-underground-system-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}