{
    "id": "1794",
    "question": {
        "questionId": "1794",
        "questionFrontendId": "1675",
        "boundTopicId": null,
        "title": "Minimize Deviation in Array",
        "titleSlug": "minimize-deviation-in-array",
        "content": "<p>You are given an array <code>nums</code> of <code>n</code> positive integers.</p>\n\n<p>You can perform two types of operations on any element of the array any number of times:</p>\n\n<ul>\n\t<li>If the element is <strong>even</strong>, <strong>divide</strong> it by <code>2</code>.\n\n\t<ul>\n\t\t<li>For example, if the array is <code>[1,2,3,4]</code>, then you can do this operation on the last element, and the array will be <code>[1,2,3,<u>2</u>].</code></li>\n\t</ul>\n\t</li>\n\t<li>If the element is <strong>odd</strong>, <strong>multiply</strong> it by <code>2</code>.\n\t<ul>\n\t\t<li>For example, if the array is <code>[1,2,3,4]</code>, then you can do this operation on the first element, and the array will be <code>[<u>2</u>,2,3,4].</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>The <strong>deviation</strong> of the array is the <strong>maximum difference</strong> between any two elements in the array.</p>\n\n<p>Return <em>the <strong>minimum deviation</strong> the array can have after performing some number of operations.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You can transform the array to [1,2,3,<u>2</u>], then to [<u>2</u>,2,3,2], then the deviation will be 3 - 2 = 1.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,1,5,20,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You can transform the array after two operations to [4,<u>2</u>,5,<u>5</u>,3], then the deviation will be 5 - 2 = 3.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,10,8]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style=\"font-size: 10.8333px;\">4</span></sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 1630,
        "dislikes": 86,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[1,2,3,4]\n[4,1,5,20,3]\n[2,10,8]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Greedy",
                "slug": "greedy",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Ordered Set",
                "slug": "ordered-set",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Samsung\", \"slug\": \"samsung\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"1\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minimumDeviation(vector<int>& nums) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minimumDeviation(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minimumDeviation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minimumDeviation(self, nums: List[int]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minimumDeviation(int* nums, int numsSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinimumDeviation(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumDeviation = function(nums) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_deviation(nums)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minimumDeviation(_ nums: [Int]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minimumDeviation(nums []int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minimumDeviation(nums: Array[Int]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minimumDeviation(nums: IntArray): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumDeviation($nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minimumDeviation(nums: number[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (minimum-deviation nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec minimum_deviation(Nums :: [integer()]) -> integer().\nminimum_deviation(Nums) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec minimum_deviation(nums :: [integer]) :: integer\n  def minimum_deviation(nums) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"44.1K\", \"totalSubmission\": \"84.1K\", \"totalAcceptedRaw\": 44072, \"totalSubmissionRaw\": 84147, \"acRate\": \"52.4%\"}",
        "hints": [
            "Assume you start with the minimum possible value for each number so you can only multiply a number by 2 till it reaches its maximum possible value.",
            "If there is a better solution than the current one, then it must have either its maximum value less than the current maximum value, or the minimum value larger than the current minimum value.",
            "Since that we only increase numbers (multiply them by 2), we cannot decrease the current maximum value, so we must multiply the current minimum number by 2."
        ],
        "solution": {
            "id": "1064",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,2,3,4]",
        "metaData": "{\n  \"name\": \"minimumDeviation\",\n  \"params\": [\n    {\n      \"name\": \"nums\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "815",
            "date": "2022-02-19",
            "incompleteChallengeCount": 28,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1064",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nThe problem can be solved in many ways. With heap, we can directly solve it by simulation (and a little greedy idea). Also, with some pretreatments, we can transform it into [Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/).\n\nBelow, we will discuss five approaches: *Simulation + Heap*, *Pretreatment + Sorting + Sliding Window*, *Pretreatment + Heap + Sliding Window*, *Pretreatment + Heap + Pointers*, and *Pretreatment + Sorting + Pointers*.\n\nGenerally, we recommend the first approach since it is easy to implement and has good performance. We provide other approaches to explore possibilities and leave them for interested readers. In fact, there are many different approaches to tackle this problem, and the given five approaches are not enough to cover them all.\n\n---\n\n#### Approach 1: Simulation + Heap\n\n**Intuition**\n\nThe problem gives two operations:\n\n1. If the element is even, we can divide it by 2.\n2. If the element is odd, we can multiply it by 2.\n\nConsequently, we have two insights:\n\n1. If the element is even, we can **not** increase it.\n2. If the element is odd, we can **not** decrease it.\n\nWe can try to increase all numbers to their maximum and reduce them step by step.\n\n![Figure 1.1](../Documents/5616/5616_1_1.drawio.svg)\n\nAccording to the problem description:\n\n$$\n\\text{deviation} = \\text{maximum} - \\text{minimum}\n$$\n\nHence, there are only two ways to decrease $$\\text{deviation}$$: decrease $$\\text{maximum}$$, or increase $$\\text{minimum}$$.\n\nIf we have increased all numbers to their maximum, then we can **not** increase $$\\text{minimum}$$. If we want smaller $$\\text{deviation}$$, we can only decrease $$\\text{maximum}$$.\n\n![Figure 1.2](../Documents/5616/5616_1_2.drawio.svg)\n\nIf the maximum is odd, then we can not decrease $$\\text{maximum}$$ neither. In this case, we just return the recorded minimum deviation, since we can not decrease it anymore.\n\nHowever, there is a remaining problem: we need to find the maximum and minimum after each modification. We do not want to iterate the whole list, since it is slow. Luckily, there is a data structure called [heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) that maintains the maximum value in **logarithmic** time and returns the maximum value in **constant** time. \n\nFor the minimum, we just need to update it for each decrease of maximum.\n\n![Figure 1.3](../Documents/5616/5616_1_3.drawio.svg)\n\n> It's also OK to decrease all numbers to their **minimum** and then increase them step by step. Again, there are many possibilities.\n\n**Algorithm**\n\n*Step 1:* Initialize a max-heap `evens`. \n\n   - For an even number in `nums`, put it directly into `evens`; for the odd number in `nums`, multiply by 2 and put it into `evens`.\n\n*Step 2:* Maintain an integer `minimum` to keep tracking the smallest element in `evens`.\n\n*Step 3:* Take out the maximum number in `evens`. Use the maximum and the maintained `minimum` to update the minimum deviation. If the maximum number is even, divide by 2 and push into `evens`.\n\n*Step 4:* Repeat *Step 3* until the maximum number in `evens` is odd. \n\n*Step 5:* Return the minimum deviation.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/UeCFYiZV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"UeCFYiZV\"></iframe>\n\n> Note: in the C++ and Java code, we push `num` into `evens` one by one. You can push them into a list and then change the list into a heap. That would yield faster performance but requires more codes. Our implementation is enough to pass the test.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `nums`, and $$M$$ be the largest number in `nums`. In the worst case when $$M$$ is the power of $$2$$, there are $$\\log(M)$$ possible values for $$M$$. Therefore, in the worst case, the total possible candidate number (denoted by $$K$$) is $$K = N \\cdot \\log(M) = N\\log(M)$$.\n\n* Time Complexity: $$\\mathcal{O}(K\\log(N)) = \\mathcal{O}(N\\log(M)\\log(N))$$. In worst case, we need to push every candidate number into `evens`, and the size of `evens` is $$\\mathcal{O}(N)$$. Hence, the total time complexity is $$\\mathcal{O}(K \\cdot \\log(N)) = \\mathcal{O}(N\\log(M)\\log(N))$$.\n\n* Space Complexity: $$\\mathcal{O}(N)$$, since there are at most $$N$$ elements in `evens`.\n\n---\n\n#### Approach 2: Pretreatment + Sorting + Sliding Window\n\n**Intuition**\n\nIn *Approach 1*, we maintain a list and keep changing the elements of the list. Can we pre-calculate all the changeable candidates?\n\nYes, with a little pretreatment. For each even number, we divide it by $$2$$ until it becomes an odd number; for each odd number, we add itself and the twice of itself.\n\n![Figure 2.1](../Documents/5616/5616_2_1.drawio.svg)\n\nIn this case, we transform it into a similar problem: select one number from each candidate list such that the deviation is minimum.\n\nThat is exactly [Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/). We highly recommend finishing it before continuing reading if you have not solved it.\n\nFrom *Approach 2* to *Approach 5*, we will apply this pretreatment and use different methods to handle the following.\n\nIn this approach, we put all candidates into a single list and then sort the list. Suddenly, it becomes a sliding window problem.\n\n![Figure 2.2](../Documents/5616/5616_2_2.drawio.svg)\n\nAll we need to do is find out the minimum interval such that the interval contains all index's candidates (i.e., contains all colors in the Figure above).\n\nOf course, the length of the interval should be calculated by the difference between the ending value and the starting value.\n\n> Also, we can sort the list from large to small alternatively. That is similar.\n\n**Algorithm**\n\n*Step 1:* Initialize a list `possible`. \n  - Iterate `nums`. For each `nums[i]`, push all possible `[candidate, i]` pairs into the `possible` list.\n\n*Step 2:* Sort `possible`.\n\n*Step 3:* Initialize a vector `needInclude`, where `needInclude[i]` marks if the sliding window includes `i`'s candidates or not (and how many it includes). Initialize an integer `notIncluded` representing the total number of index whose all candidates are not in the sliding window.\n\n*Step 4:* Move the right pointer of the sliding window to one unit right.\n  - If `notIncluded` shows that the sliding window includes every index's candidates (i.e., `notIncluded == 0`), move the left pointer to right until the sliding window does not include them. Update the minimum deviation during this period.\n\n*Step 5:* Repeat *Step 4* until the right pointer reaches the end of `possible`.\n\n*Step 6:* Return the minimum deviation.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/M8XeKifL/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"M8XeKifL\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `nums`, and $$M$$ be the largest number in `nums`. In the worst case when $$M$$ is the power of $$2$$, there are $$\\log(M)$$ candidates for $$M$$. Therefore, in the worst case, the total candidate number (denoted by $$K$$) is $$K = N \\cdot \\log(M) = N\\log(M)$$.\n\n* Time Complexity: $$\\mathcal{O}(K\\log(K)) = \\mathcal{O}(N\\log(M)\\log(N\\log(M)))$$. In the worst case, `possible` has $$K$$ elements, and we need to sort it, which costs $$\\mathcal{O}(K\\log(K))$$. For the sliding window, we need $$\\mathcal{O}(K)$$ time, since the left pointer and the right pointer visit every element in `possible` once.\n\n* Space Complexity: $$\\mathcal{O}(K) = \\mathcal{O}(N\\log(M))$$, since in the worst case, `possible` has $$K$$ elements.\n\n---\n\n#### Approach 3: Pretreatment + Heap + Sliding Window\n\n**Intuition**\n\nIf you do not love sorting all candidates immediately, we can put all of them in a min-heap, and produce the next element on the fly when the right pointer moves to the right.\n\n![Figure 3.1](../Documents/5616/5616_3_1.drawio.svg)\n\nNote that this would not save you time complexity, just show the possibilities of solving this problem.\n\n> Also, we can put all candidates in a max-heap instead of a min-heap. That is similar.\n\n**Algorithm**\n\n*Step 1:* Initialize a list `possible`. \n\n  - Iterate `nums`. For `nums[i]`, push all possible `[candidate, i]` pairs into the `possible` list.\n\n*Step 2:* Initialize a min-heap from `possible`.\n\n*Step 3:* Initialize a vector `needInclude`, where `needInclude[i]` marks if the sliding window includes `i`'s candidates or not (and how many it includes). Initialize an integer `notIncluded` representing the total number of index whose all candidates are not in the sliding window.\n\n*Step 4:* Move the right pointer of the sliding window to one unit right. When the right pointer needs to go right, pop the minimum from the heap as the next element. \n  - If `notIncluded` shows that the sliding window includes every index's candidates (i.e., `notIncluded == 0`), move the left pointer to right until the sliding window does not include them. Update the minimum deviation during this period.\n\n*Step 5:* Repeat *Step 4* until the right pointer reaches the end of `possible`.\n\n*Step 6:* Return the minimum deviation.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/TMM9yifn/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"TMM9yifn\"></iframe>\n\n> Note: The C++ version is likely to yield *Time Limit Exceeded*. This might be because the time limit of C++ is tighter.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `nums`, and $$M$$ be the largest number in `nums`. In the worst case when $$M$$ is the power of $$2$$, there are $$\\log(M)$$ candidates for $$M$$. Therefore, in the worst case, the total candidate number (denoted by $$K$$) is $$K = N \\cdot \\log(M) = N\\log(M)$$.\n\n* Time Complexity: $$\\mathcal{O}(K\\log(K)) = \\mathcal{O}(N\\log(M)\\log(N\\log(M)))$$. In the worst case, `possible` has $$K$$ elements, and we need to pop every elements from it, which costs $$\\mathcal{O}(K\\log(K))$$. For the sliding window, we need $$\\mathcal{O}(K)$$ time, since the left pointer and the right pointer visit every element in `possible` once.\n\n* Space Complexity: $$\\mathcal{O}(K) = \\mathcal{O}(N\\log(M))$$, since in the worst case, `possible` has $$K$$ elements.\n\n---\n\n#### Approach 4: Pretreatment + Heap + Pointers\n\n**Intuition**\n\nStill, with some pretreatments, we transform it into [Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/).\n\nThis time, we borrow some ideas from [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) and *Approach 1*.\n\nFor each index, we initialize a pointer and point it to the top element (i.e., the minimum element).\n\n![Figure 4.1](../Documents/5616/5616_4_1.drawio.svg)\n\nAccording to some ideas in *Approach 1*,\n\n>$$\\text{deviation} = \\text{maximum} - \\text{minimum}$$\n>\n>There are only two ways to decrease $$\\text{deviation}$$: decrease $$\\text{maximum}$$, or increase $$\\text{minimum}$$.\n\nIf we point all the pointers to the minimum element in the candidate list, that is similar to change all the numbers in `num` to the minimum candidate. In this case, we can **not** decrease $$\\text{maximum}$$. We can only increase $$\\text{minimum}$$.\n\n![Figure 4.2](../Documents/5616/5616_4_2.drawio.svg)\n\nTherefore, we can keep getting the minimum pointer from the heap, update the deviation, move the pointer point to the next element, and then push back the pointer to the heap.\n\n> Of course, you can use a max heap instead of a min-heap. That requires some corresponding changes in the code.\n\n> Essentially, this solution is similar to *Approach 1* except we pre-calculate all the candidates.\n\n**Algorithm**\n\n*Step 1:* Initialize a list `possibleList`. \n  - `possibleList[i]` contains a list of all possible candidates of `nums[i]`.\n\n*Step 2:* Initialize a heap `pointers` containing starting pointers. Each starting pointer should point to the start of each candidate list.\n\n*Step 3:* From `pointers` take out the minimum number. Update the minimum deviation. Push the next number of that pointer into `pointers`.\n\n*Step 4:* Repeat *Step 3* until one of the pointers reaches the end. \n\n*Step 5:* Return the minimum deviation.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/oMUyu2iJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"oMUyu2iJ\"></iframe>\n\n> Note: The C++ version is likely to yield *Time Limit Exceeded*. This might be because the time limit of C++ is tighter.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `nums`, and $$M$$ be the largest number in `nums`. In the worst case when $$M$$ is the power of $$2$$, there are $$\\log(M)$$ candidates for $$M$$. Therefore, in the worst case, the total candidate number (denoted by $$K$$) is $$K = N \\cdot \\log(M) = N\\log(M)$$.\n\n* Time Complexity: $$\\mathcal{O}(K\\log(N)) = \\mathcal{O}(N\\log(M)\\log(N))$$. In the worst case, `possibleList` has $$K$$ candidates, and we need to push every candidates into `pointers`, which cost $$\\mathcal{O}(K\\log(N))$$.\n\n* Space Complexity: $$\\mathcal{O}(N)$$, since `pointers` always has $$N$$ elements.\n\n---\n\n#### Approach 5: Pretreatment + Sorting + Pointers\n\n**Intuition**\n\nSimilar to *Approach 4*, if you do not like using the heap, we can pre-sort the pointers in the order we need, and get the next pointer one by one.\n\n![Figure 5.1](../Documents/5616/5616_5_1.drawio.svg)\n\n**Algorithm**\n\n*Step 1:* Initialize a list `possibleList`. \n\n  - `possibleList[i]` contains a list of all possible candidates of `nums[i]`.\n\n*Step 2:* Initialize a list `pointers` containing all pointers. Each pointer should point to one different candidate in `possibleList`.\n\n*Step 3:* Sort `pointers`.\n\n*Step 4:* From `pointers` take out the minimum number. Update the minimum deviation. Get the next pointer in the same candidate list.\n\n*Step 5:* Repeat *Step 4* until one of the candidate lists reaches the end. \n\n*Step 6:* Return the minimum deviation.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/jKtcLqWg/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"jKtcLqWg\"></iframe>\n\n> Note: The C++ version is likely to yield *Time Limit Exceeded*. This might be because the time limit of C++ is tighter.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `nums`, and $$M$$ be the largest number in `nums`. In the worst case when $$M$$ is the power of $$2$$, there are $$\\log(M)$$ candidates for $$M$$. Therefore, in the worst case, the total candidate number (denoted by $$K$$) is $$K = N \\cdot \\log(M) = N\\log(M)$$.\n\n* Time Complexity: $$\\mathcal{O}(K\\log(K)) = \\mathcal{O}(N\\log(M)\\log(N\\log(M)))$$. In the worst case, `possibleList` has $$K$$ candidates, and we need to sort $$K$$ pointers, which cost $$\\mathcal{O}(K\\log(K))$$.\n\n* Space Complexity: $$\\mathcal{O}(K)$$, since `pointers` has $$K$$ elements in the worst case.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1019",
            "count": 38,
            "average": "4.737",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "minimize-deviation-in-array",
    "playgroundData": {
        "UeCFYiZV": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-deviation-in-array-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "M8XeKifL": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-deviation-in-array-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "TMM9yifn": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-deviation-in-array-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "oMUyu2iJ": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-deviation-in-array-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "jKtcLqWg": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-deviation-in-array-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}