{
    "id": "120",
    "question": {
        "questionId": "120",
        "questionFrontendId": "120",
        "boundTopicId": null,
        "title": "Triangle",
        "titleSlug": "triangle",
        "content": "<p>Given a <code>triangle</code> array, return <em>the minimum path sum from top to bottom</em>.</p>\n\n<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The triangle looks like:\n   <u>2</u>\n  <u>3</u> 4\n 6 <u>5</u> 7\n4 <u>1</u> 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[-10]]\n<strong>Output:</strong> -10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= triangle.length &lt;= 200</code></li>\n\t<li><code>triangle[0].length == 1</code></li>\n\t<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= triangle[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you&nbsp;do this using only <code>O(n)</code> extra space, where <code>n</code> is the total number of rows in the triangle?",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 6446,
        "dislikes": 422,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[[2],[3,4],[6,5,7],[4,1,8,3]]\n[[-10]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 9}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"DE Shaw\", \"slug\": \"de-shaw\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minimumTotal(int** triangle, int triangleSize, int* triangleColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinimumTotal(IList<IList<int>> triangle) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} triangle\n# @return {Integer}\ndef minimum_total(triangle)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minimumTotal(_ triangle: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minimumTotal(triangle [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minimumTotal(triangle: List[List[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minimumTotal(triangle: List<List<Int>>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $triangle\n     * @return Integer\n     */\n    function minimumTotal($triangle) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minimumTotal(triangle: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (minimum-total triangle)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec minimum_total(Triangle :: [[integer()]]) -> integer().\nminimum_total(Triangle) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec minimum_total(triangle :: [[integer]]) :: integer\n  def minimum_total(triangle) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"495.9K\", \"totalSubmission\": \"935K\", \"totalAcceptedRaw\": 495897, \"totalSubmissionRaw\": 935008, \"acRate\": \"53.0%\"}",
        "hints": [],
        "solution": {
            "id": "1134",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[2],[3,4],[6,5,7],[4,1,8,3]]",
        "metaData": "{\r\n  \"name\": \"minimumTotal\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"triangle\",\r\n      \"type\": \"list<list<integer>>\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "948",
            "date": "2022-06-13",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1134",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n\r\n#### Overview\r\n\r\nAs it's always better to try and solve problems on your own before you read the official solution, here are a couple of related, but easier, problems you might like to try first if you're stuck on this problem.\r\n\r\n1. `Triangle` is a variant of the falling path sum problem - a classic dynamic programming problem. If you're not at all familiar with dynamic programming, then we recommend starting with [931. Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/), as the idea is the same, but the solution is a bit simpler due to all rows being the same length.\r\n\r\n2. A simpler triangle-related dynamic programming problem is [118. Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/). If you haven't already solved it, then you should do that now.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 1: Dynamic Programming (Bottom-up: In-place)\r\n\r\n**Intuition**\r\n\r\nA good way to get started on a problem like this is to make a very small example, and then figure out how to solve it. After that, make the example a bit bigger, and see if you can still solve it. Try and come up with a general way of solving the problem, regardless of the size.\r\n\r\n!?!../Documents/120_animation_1.json:960,540!?!\r\n\r\n<br/>\r\n\r\nAs you hopefully realized from the animation, we can solve the problem by iterating through each row of the triangle, from top to bottom, updating each number to be the sum of itself + the minimum out of the two numbers above it.\r\n\r\n!?!../Documents/120_animation_2.json:960,540!?!\r\n\r\n<br/>\r\n\r\n\r\n**Algorithm**\r\n\r\nThe simplest way of implementing this is to overwrite the input. In other words, as an in-place algorithm. In Approach 2, we'll look at how to modify the algorithm so that it doesn't overwrite the input, but doesn't require more than $$O(n)$$ extra space.\r\n\r\nWhen this algorithm has finished running, each cell, `(row, col)` of the input triangle will be overwritten with the minimal path sum from `(0, 0)` (the triangle tip), down to and including `(row, col)`.\r\n\r\n> **Interview Tip: In-place Algorithms**\r\n>\r\n> In-place algorithms overwrite the input to save space, but sometimes this can cause problems. Here are a couple of situations where an in-place algorithm might not be suitable.\r\n> 1. The algorithm needs to run in a *multi-threaded* environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.\r\n> 2. Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.\r\n>\r\n> In an interview, you should always check whether or not the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!\r\n\r\nWe need to be quite careful designing our algorithm: the rows and columns are all different sizes, greatly increasing the risk of off-by-one errors. The rows are numbered from top to bottom (so the triangle tip is the first row), and the columns are numbered left to right. Here is a diagram showing the `(row, col)` coordinate for a triangle with `4` rows.\r\n\r\n![img](../Figures/120/triangle_coordinates.png)\r\n\r\nCombining this diagram with what we determined before, we can deduce the following rules for obtaining the cells above a cell with coordinate `(row, col)`.\r\n\r\n1. If `row == 0`: This is the top of the triangle: it stays the same.\r\n2. If `col == 0`: There is only one cell above, located at `(row - 1, col)`.\r\n3. If `col == row`: There is only one cell above, located at `(row - 1, col - 1)`.\r\n4. In all other cases: There are two cells above, located at `(row - 1, col - 1`) and `(row - 1, col)` .\r\n\r\nWe can collapse cases 2, 3, and 4 into two overlapping cases by recognizing that case 4 simply cases 2 and 3 combined.\r\n\r\nPutting everything together, we get the following algorithm.\r\n\r\n- Iterate through each `row` index between `1` and `n - 1` inclusive (where `n` is the number of rows in triangle):\r\n  - Iterate through each `col` index between `0` and `row` inclusive:\r\n    - Initialize a variable `smallestAbove` to positive infinity:\r\n    - If `col > 0`:\r\n      - Set `smallestAbove` to `triangle[row - 1][col - 1]`.\r\n    - If `col < row`:\r\n      - Set `smallestAbove` to be the `min` out of itself and `triangle[row - 1][col]`.\r\n    - Set `triangle[row][col]` to be itself plus `smallestAbove`.\r\nReturn the minimum value in `triangle[n - 1]`.\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/HPoGaA3j/shared\" frameBorder=\"0\" width=\"100%\" height=\"361\" name=\"HPoGaA3j\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$n$$ be the number of rows in the triangle.\r\n\r\n* Time Complexity: $$O(n^2)$$. \r\n\r\n    A triangle with $$n$$ rows and $$n$$ columns contains $$\\dfrac{n (n + 1)}{2} = \\dfrac{n^2 + n}{2}$$ cells. Recall that in big O notaton, we ignore the less significant terms. This gives us $$O\\bigg(\\dfrac{n^2 + n}{2}\\bigg) = O(n^2)$$ cells. For each cell, we are performing a constant number of operatons, therefore giving us a total time complexity of $$O(n^2)$$.\r\n\r\n* Space Complexity: $$O(1)$$.\r\n\r\n    As we're overwriting the input, we don't need any collections to store our calculations.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 2: Dynamic Programming (Bottom-up: Auxiliary Space)\r\n\r\n**Intuition**\r\n\r\nAs mentioned in Approach 1, it isn't always desirable to overwrite the input array. It is quite likely, in fact, that your interviewer will expect you to treat it as read-only.\r\n\r\nThe most obvious solution here is to create a copy of the input, and then run Approach 1's algorithm over it. The downside of this is that it will require $$O(n^2)$$ space, due to there being $$\\dfrac{n^2 + n}{2}$$ cells in the triangle. Seeing as the problem description suggests that we use $$O(n)$$ space, we should be trying to do better.\r\n\r\nObserve that as we worked our way down the rows of the triangle, we only ever needed to look at the row immediately above. This means that we only need to maintain the current row and the previous row. Because a row contains at most $$n$$ cells, this will meet the $$O(n)$$ space requirement.\r\n\r\n**Algorithm**\r\n\r\nThis approach is almost the same as Approach 1. The only difference is that we need to write the new values for the current row into an extra list (or array), and then keep track of the previous one of these lists.\r\n\r\n<iframe src=\"https://leetcode.com/playground/MoMAako8/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"MoMAako8\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time Complexity: $$O(n^{2})$$.\r\n\r\n    Same as Approach 1. We are still performing a constant number of operations for each cell in the input triangle.\r\n\r\n* Space Complexity: $$O(n)$$. \r\n\r\n    We're using two arrays of up to size $$n$$ each: `prevRow` and `currRow`. While this is a higher space complexity than Approach 1, the advantage of this approach is that the input triangle remains unmodified.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 3: Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\r\n\r\n**Intuition**\r\n\r\nThe problem description tells us that we need to find the minimum path sum from top to bottom. This immediately suggests that we should be working from top to bottom, like what we did in Approaches 1 and 2.\r\n\r\n*But is this actually necessary? Could we go from bottom to top instead?*\r\n\r\nIt turns out, we can! The exact same ideas apply - each cell instead becomes the sum of itself plus the minimum of the two cells below it. The only difference is that we need to do the edge case handling a bit differently. \r\n\r\n![img](../Figures/120/upside_down_triangle_coordinates.png)\r\n\r\nThere is a big advantage though: the code turns out a **lot** simpler. Some of the cells only had one cell above them. But every cell has two cells below it! \r\n\r\n> **Interview Tip:** Practice Overriding Your Brains \"Assume\" Mode!\r\n>\r\n> We humans have a habit of making a lot of assumptions - neurobiologists reassure us that this is quite normal! If we didn't make lots of assumptions, our brains would slow to a crawl like a poorly maintained computer, thanks to the overload of additional information they'd have to process. \r\n> \r\n> In an interview situation, where most of us are at least a little nervous, we are even less likely to question our assumptions. The moment most of us realize that we can solve the problem using the top-to-bottom approach, we will be frantically coding it up to show our interviewer that we can solve the problem. \r\n>\r\n> But this isn't ideal! In an interview, and when solving difficult problems in general, you need to learn to identify the assumptions you're making, and question them in your mind. In some problems, this can be things like assuming that input is sorted, that there will be no invalid cases, that they won't mind you overwriting the input, or even that the environment is single-threaded. In this case, the assumption is assuming that the only way of solving this problem is to work from top to bottom.\r\n>\r\n> The only way to get good at challenging your assumptions is lots of practice. Working in a group with other people preparing for code interviews can help too - learning how other people see problems will widen your own way of seeing problems.\r\n\r\n**Algorithm**\r\n\r\nLike before, we can do this either in place or by overwriting the input. This algorithm will assume that we're overwriting the input, although I've provided the actual code below for both.\r\n\r\nWhen we worked from top to bottom, the cells had only one cell above them. But when we work from bottom to top, all cells, except for those in the bottom row (which are our base case and so don't need to be modified anyway) have exactly two cells below them. Where `(row, col)` is the current cell, the cells below are located at `(row + 1, col)` and `(row + 1, col + 1)`. At the end, the answer will be in `triangle[0][0]`.\r\n\r\nPutting everything together, we get the following algorithm.\r\n\r\n- Iterate **up** through each `row` index between `n - 2` and `0` inclusive (where `n` is the number of rows in triangle):\r\n  - Iterate through each `col` index between `0` and `row` inclusive:\r\n    - Set `smallestBelow` to be the `min` out of `triangle[row + 1][col]` and `triangle[row + 1][col + 1]`.\r\n    - Set `triangle[row][col]` to be itself plus `smallestBelow`.\r\n- Return `triangle[0][0]`\r\n\r\nHere is the in-place implementation. When this algorithm has finished running, each cell, `(row, col)` of the input triangle will be overwritten with the minimal path sum from `(row, col)` to any cell on the bottom `row`.\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/XmRYaUUT/shared\" frameBorder=\"0\" width=\"100%\" height=\"276\" name=\"XmRYaUUT\"></iframe>\r\n\r\nAnd here is the auxiliary space implementation.\r\n\r\n<iframe src=\"https://leetcode.com/playground/VhKv5w9f/shared\" frameBorder=\"0\" width=\"100%\" height=\"293\" name=\"VhKv5w9f\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nThe time and space complexity for Approach 3 depends on which implementation you're looking at. The in-place implementation has the same complexity analysis as Approach 1, whereas the auxiliary space implementation has the same complexity analysis as Approach 2.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 4: Memoization (Top-Down)\r\n\r\n**Intuition**\r\n\r\nUsually, for dynamic programming problems, we start with a recursive [memoization-based approach](https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/), and then figure out how to convert it to an iterative dynamic programming (tabulaton) approach. For this particular problem, most people will more naturally think of the problem in terms of iterative dynamic programming from the start though. But it is still worth having a look at how we could instead use memoization.\r\n\r\n**Algorithm**\r\n\r\nWe'll define a recursive helper function `minPath(row, col)` that returns the minimum path sum from the cell at `(row, col)`, down to the base of the triangle. The minimum path sum for the entire triangle, would, therefore, be `minPath(0, 0)`.\r\n\r\nThe recursive case is where there is still at least one row below the current cell. Like before, we simply need to add the current cell to the minimum path sum of the cells below it. That is:\r\n\r\n`return triangle[row][col] + min(minPath(row + 1, col), minPath(row + 1, col + 1))`\r\n\r\nThe base case is where there are no more rows below. In this case, we should simply return the current cell's value:\r\n\r\n`return triangle[row][col]`\r\n\r\nTo avoid re-calculating the same results over and over again, we can use a `memoization` table.\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/hoD5bS2S/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"hoD5bS2S\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$n$$ be the number of rows in the triangle.\r\n\r\n* Time Complexity: $$O(n^2)$$.\r\n\r\n    There are two steps to analyzing the time complexity of an algorithm that uses recursive memoization.\r\n    \r\n    Firstly, determine what the cost of each call to the recursive function is. That is, how much time is spent actively executing instructions within a single call. It does not include time spent in functions called by that function.\r\n    \r\n    Secondly, determine how many times the recursive function is called.\r\n\r\n    Each call to `minPath` is $$O(1)$$, because there are no loops. The memoization table ensures that `minPath` is only called once for each cell.  As there are $$n^2$$ cells, we get a total time complexity of $$O(n^2)$$.\r\n\r\n\r\n* Space Complexity: $$O(n^2)$$. \r\n\r\n    Each time a base case cell is reached, there will be a path of $$n$$ cells on the run-time stack, going from the triangle tip, down to that base case cell. This means that there is $$O(n)$$ space on the run-time stack.\r\n\r\n    Each time a subproblem is solved (a call to `minPath`), its result is stored in a memoization table. We determined above that there are $$O(n^2)$$ such subproblems, giving a total space complexity of $$O(n^2)$$ for the memoization table.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1139",
            "count": 134,
            "average": "4.970",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "triangle",
    "playgroundData": {
        "HPoGaA3j": {
            "playground": {
                "testcaseInput": "",
                "name": "triangle-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "MoMAako8": {
            "playground": {
                "testcaseInput": "",
                "name": "triangle-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "XmRYaUUT": {
            "playground": {
                "testcaseInput": "",
                "name": "triangle-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "VhKv5w9f": {
            "playground": {
                "testcaseInput": "",
                "name": "triangle-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "hoD5bS2S": {
            "playground": {
                "testcaseInput": "",
                "name": "triangle-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}