{
    "id": "276",
    "question": {
        "questionId": "276",
        "questionFrontendId": "276",
        "boundTopicId": null,
        "title": "Paint Fence",
        "titleSlug": "paint-fence",
        "content": "<p>You are painting a fence of <code>n</code> posts with <code>k</code> different colors. You must paint the posts following these rules:</p>\n\n<ul>\n\t<li>Every post must be painted <strong>exactly one</strong> color.</li>\n\t<li>There <strong>cannot</strong> be three or more <strong>consecutive</strong> posts with the same color.</li>\n</ul>\n\n<p>Given the two integers <code>n</code> and <code>k</code>, return <em>the <strong>number of ways</strong> you can paint the fence</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/28/paintfenceex1.png\" style=\"width: 507px; height: 313px;\" />\n<pre>\n<strong>Input:</strong> n = 3, k = 2\n<strong>Output:</strong> 6\n<strong>Explanation: </strong>All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7, k = 2\n<strong>Output:</strong> 42\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li>The testcases are generated such that the answer is in the range <code>[0, 2<sup>31</sup> - 1]</code> for the given <code>n</code> and <code>k</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 1300,
        "dislikes": 362,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber II\", \"titleSlug\": \"house-robber-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House\", \"titleSlug\": \"paint-house\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House II\", \"titleSlug\": \"paint-house-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "3\n2\n1\n1\n7\n2",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"JPMorgan\", \"slug\": \"jpmorgan\", \"timesEncountered\": 2}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int numWays(int n, int k) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int numWays(int n, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def numWays(self, n: int, k: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint numWays(int n, int k){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int NumWays(int n, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar numWays = function(n, k) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer}\ndef num_ways(n, k)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func numWays(_ n: Int, _ k: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func numWays(n int, k int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def numWays(n: Int, k: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun numWays(n: Int, k: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn num_ways(n: i32, k: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer\n     */\n    function numWays($n, $k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function numWays(n: number, k: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (num-ways n k)\n  (-> exact-integer? exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec num_ways(N :: integer(), K :: integer()) -> integer().\nnum_ways(N, K) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec num_ways(n :: integer, k :: integer) :: integer\n  def num_ways(n, k) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"88.8K\", \"totalSubmission\": \"204.4K\", \"totalAcceptedRaw\": 88793, \"totalSubmissionRaw\": 204379, \"acRate\": \"43.4%\"}",
        "hints": [],
        "solution": {
            "id": "1153",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "3\n2",
        "metaData": "{\r\n  \"name\": \"numWays\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"n\",\r\n      \"type\": \"integer\"\r\n    },\r\n    {\r\n      \"name\": \"k\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1153",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n\r\n#### Overview\r\n\r\n**Realizing This is a Dynamic Programming Problem**\r\n\r\nThere are two parts to this problem that tell us it can be solved with dynamic programming. \r\n\r\nFirst, the question is asking for the \"number of ways\" to do something. \r\n\r\nSecond, we need to make decisions that may depend on previously made decisions. In this problem, we need to decide what color we should paint a given post, which may change depending on previous decisions. For example, if we paint the first two posts the same color, then we are not allowed to paint the third post the same color.\r\n\r\nBoth of these things are characteristic of dynamic programming problems.\r\n\r\n**A Framework to Solve Dynamic Programming Problems**\r\n\r\nA dynamic programming algorithm typically has 3 components. Learning these components is extremely valuable, as **most dynamic programming problems can be solved this way**.\r\n\r\nFirst, we need some function or array that represents the answer to the problem for a given state. For this problem, let's say that we have a function `totalWays`, where `totalWays(i)` returns the number of ways to paint `i` posts. Because we only have one argument, this is a one-dimensional dynamic programming problem.\r\n\r\nSecond, we need a way to transition between states, such as `totalWays(3)` and `totalWays(4)`. This is called a **recurrence relation** and figuring it out is usually the hardest part of solving a problem with dynamic programming. We'll talk about the recurrence relation for this problem below.\r\n\r\nThe third component is establishing base cases. If we have one post, there are `k` ways to paint it. If we have two posts, then there are `k * k` ways to paint it (since we are allowed to paint have two posts in a row be the same color). Therefore, `totalWays(1) = k, totalWays(2) = k * k`.\r\n\r\n**Finding The Recurrence Relation**\r\n\r\nWe know the values for `totalWays(1)` and `totalWays(2)`, now we need a formula for `totalWays(i)`, where `3 <= i <= n`. Let's think about how many ways there are to paint the $$i^{th}$$ post. We have two options:\r\n\r\n1. Use a different color than the previous post. If we use a different color, then there are `k - 1` colors for us to use. This means there are `(k - 1) * totalWays(i - 1)` ways to paint the $$i^{th}$$ post a different color than the $$(i - 1)^{th}$$ post.\r\n\r\n2. Use the same color as the previous post. There is only one color for us to use, so there are `1 * totalWays(i - 1)` ways to paint the $$i^{th}$$ post the same color as the $$(i - 1)^{th}$$ post. However, we have the added restriction of not being allowed to paint three posts in a row the same color. Therefore, we can paint the $$i^{th}$$ post the same color as the $$(i - 1)^{th}$$ post **only if** the $$(i - 1)^{th}$$ post is a different color than the $$(i - 2)^{th}$$ post. \r\n\r\n    So, how many ways are there to paint the $$(i - 1)^{th}$$ post a different color than the $$(i - 2)^{th}$$ post? Well, as stated in the first option, there are `(k - 1) * totalWays(i - 1)` ways to paint the $$i^{th}$$ post a different color than the $$(i - 1)^{th}$$ post, so that means there are `1 * (k - 1) * totalWays(i - 2)` ways to paint the $$(i - 1)^{th}$$ post a different color than the $$(i - 2)^{th}$$ post.\r\n\r\nAdding these two scenarios together gives `totalWays(i) = (k - 1) * totalWays(i - 1) + (k - 1) * totalWays(i - 2)`, which can be simplified to: \r\n\r\n`totalWays(i) = (k - 1) * (totalWays(i - 1) + totalWays(i - 2))`\r\n\r\nThis is our recurrence relation which we can use to solve the problem from the base cases.\r\n\r\n</br>\r\n\r\n---\r\n\r\n#### Approach 1: Top-Down Dynamic Programming (Recursion + Memoization)\r\n\r\n**Intuition**\r\n\r\nTop-down dynamic programming starts from the top and works its way down to the base cases. Typically, this is implemented with recursion and then made efficient using _memoization_. Memoization refers to storing the results of expensive function calls to avoid duplicate computations - we'll soon see why this is important for this problem. If you're new to recursion, check out the [recursion explore card](https://leetcode.com/explore/featured/card/recursion-i/).\r\n\r\nWe can implement the function `totalWays(i)` as follows - first, check for the base cases we defined above `totalWays(1) = k, totalWays(2) = k * k`. If `i >= 3`, use our recurrence relation: `totalWays(i) = (k - 1) * (totalWays(i - 1) + totalWays(i - 2))`. However, we will run into a major problem - repeated computation. If we call `totalWays(5)`, that function call will also call `totalWays(4)` and `totalWays(3)`. The `totalWays(4)` call will call `totalWays(3)` again, as illustrated below, we are calculating `totalWays(3)` twice. <br>\r\n\r\n<img src=\"../Figures/276/276_1.png\" width=\"960\"> <br>\r\n\r\nThis may not seem like a big deal with `i = 5`, but imagine if we called `totalWays(6)`. This entire tree would be one child, and we would have to call `totalWays(4)` twice. As `n` increases, the size of the tree grows exponentially - imagine how expensive a call such as `totalWays(50)` would be. This can be solved with _memoization_. When we compute the value of a given `totalWays(i)`, let's store that value in memory. Next time we need to call `totalWays(i)`, we can refer to the value stored in memory instead of having to call the function again and going through the repeated computations.\r\n\r\n**Algorithm**\r\n\r\n1. Define a hash map `memo`, where `memo[i]` represents the number of ways you can paint `i` fence posts.\r\n\r\n2. Define a function `totalWays` where `totalWays(i)` will determine the number of ways you can paint `i` fence posts.\r\n\r\n3. In the function `totalWays`, first check for the base cases. `return k` if `i == 1`, and `return k * k` if `i == 2`. Next, check if the argument `i` has already been calculated and stored in `memo`. If so, `return memo[i]`. Otherwise, use the recurrence relation to calculate `memo[i]`, and then return `memo[i]`.\r\n\r\n4. Simply call and return `totalWays(n)`.\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/FwQ7mB7z/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"FwQ7mB7z\"></iframe>\r\n\r\n\r\n**Extra Notes**\r\n\r\nFor this approach, we are using a hash map as our data structure to memoize function calls. We could also use an array since the calls to `totalWays` are very well defined (between 1 and `n`). However, a hash map is used for most top-down dynamic programming solutions, as there will often be multiple function arguments, the arguments might not be integers, or a variety of other reasons that require a hash map instead of an array. Although using an array is slightly more efficient, using a hash map here is a good practice that can be applied to other problems.\r\n\r\nIn Python, the [functools](https://docs.python.org/3/library/functools.html) module contains functions that can be used to automatically memoize a function. In LeetCode, modules are automatically imported, so you can just add the `@lru_cache(None)` wrapper to any function definition to have it automatically memoize.\r\n\r\n<iframe src=\"https://leetcode.com/playground/4wn8twus/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"4wn8twus\"></iframe>\r\n\r\n\r\nYou can observe that by removing the @lru_cache(None) wrapper, on attempted submission, the code will exceed the time limit.\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(n)$$\r\n\r\n    `totalWays` gets called with each index from `n` to `3`. Because of our memoization, each call will only take $$O(1)$$ time.\r\n\r\n* Space complexity: $$O(n)$$\r\n\r\n    The extra space used by this algorithm is the recursion call stack. For example, `totalWays(50)` will call `totalWays(49)`, which calls `totalWays(48)` etc., all the way down until the base cases at `totalWays(1)` and `totalWays(2)`. In addition, our hash map `memo` will be of size `n` at the end, since we populate it with every index from `n` to `3`.\r\n\r\n---\r\n\r\n#### Approach 2: Bottom-Up Dynamic Programming (Tabulation)\r\n\r\n**Intuition**\r\n\r\nBottom-up dynamic programming is also known as **tabulation** and is done iteratively. Instead of using a function like in top-down, let's use an array `totalWays` instead, where `totalWays[i]` represents the number of ways you can paint `i` fence posts.\r\n\r\nAs the name suggests, we now start at the bottom and work our way up to the top (`n`). Initialize the base cases `totalWays[1] = k, totalWays[2] = k * k`, and then iterate from `3` to `n`, using the recurrence relation to populate `totalWays`.\r\n\r\nBottom-up algorithms are generally considered superior to top-down algorithms. Typically, a top-down implementation will use more space and take longer than the equivalent bottom-up approach.\r\n\r\n**Algorithm**\r\n\r\n1. Define an array `totalWays` of length `n + 1`, where `totalWays[i]` represents the number of ways you can paint `i` fence posts. Initialize `totalWays[1] = k` and `totalWays[2] = k * k`.\r\n\r\n2. Iterate from `3` to `n`, using the recurrence relation to populate `totalWays`: `totalWays[i] = (k - 1) * (totalWays[i - 1] + totalWays[i - 2])`.\r\n\r\n3. At the end, return `totalWays[n]`.\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/64dP59So/shared\" frameBorder=\"0\" width=\"100%\" height=\"344\" name=\"64dP59So\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(n)$$\r\n\r\n    We only iterate from `3` to `n` once, where each iteration requires $$O(1)$$ time.\r\n\r\n* Space complexity: $$O(n)$$\r\n\r\n    We need to use an array `totalWays`, where `totalWays.length` scales linearly with `n`.\r\n    \r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 3: Bottom-Up, Constant Space\r\n\r\n**Intuition**\r\n\r\nYou may have noticed that our recurrence relation from the previous two approaches only cares about 2 steps below the current step. For example, if we are trying to calculate `totalWays[11]`, we only care about `totalWays[9]` and `totalWays[10]`. While we would have needed to calculate `totalWays[3]` through `totalWays[8]` as well, at the time of the actual calculation for `totalWays[11]`, we no longer care about any of the previous steps.\r\n\r\nTherefore, instead of using $$O(n)$$ space to store an array, we can improve to $$O(1)$$ space by using two variables to store the results from the last two steps.\r\n\r\n**Algorithm**\r\n\r\n1. Initialize two variables, `twoPostsBack` and `onePostBack`, that represent the number of ways to paint the previous two posts. Since we start iteration from post three, `twoPostsBack` initially represents the number of ways to paint one post, and `onePostBack` initially represents the number of ways to paint two posts. Set their values `twoPostsBack = k, onePostBack = k * k`, because they are equivalent to our base cases..\r\n\r\n2. Iterate `n - 2` times. At each iteration, simulate moving `i` up by one. Use the recurrence relation to calculate the number of ways for the current step and store it in a variable `curr`. \"Moving up\" means `twoPostsBack` will now refer to `onePostBack`, so update `twoPostsBack = onePostBack`. `onePostBack` will now refer to the current step, so update `onePostBack = curr`.\r\n\r\n3. In the end, return `onePostBack`, since \"moving up\" after the last step would mean `onePostBack` is the number of ways to paint `n` fence posts.\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/RVBYHVms/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"RVBYHVms\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(n)$$.\r\n\r\n    We only iterate from `3` to `n` once, each time doing $$O(1)$$ work.\r\n\r\n* Space complexity: $$O(1)$$\r\n\r\n    The only extra space we use are a few integer variables, which are independent of input size.\r\n    \r\n<br/>\r\n\r\n---\r\n\r\n#### Closing Notes\r\n\r\nIf you're new to dynamic programming, hopefully you learned something from this article. Please post any questions you may have in the comment section below. For additional practice, here's a list of similar dynamic programming questions that are good for beginners.\r\n\r\n[70. Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/)\r\n\r\n[198. House Robber (Medium)](https://leetcode.com/problems/house-robber/)\r\n\r\n[256. Paint House (Medium)](https://leetcode.com/problems/paint-house/)\r\n\r\n[509. Fibonacci Number (Easy)](https://leetcode.com/problems/fibonacci-number/)\r\n\r\n[746. Min Cost Climbing Stairs (Easy)](https://leetcode.com/problems/min-cost-climbing-stairs)\r\n\r\n[931. Minimum Falling Path Sum (Medium)](https://leetcode.com/problems/minimum-falling-path-sum/)\r\n\r\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1158",
            "count": 88,
            "average": "4.898",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "paint-fence",
    "playgroundData": {
        "FwQ7mB7z": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-fence-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "4wn8twus": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-fence-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "64dP59So": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-fence-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "RVBYHVms": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-fence-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}