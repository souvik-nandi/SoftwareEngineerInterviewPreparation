{
    "id": "341",
    "question": {
        "questionId": "341",
        "questionFrontendId": "341",
        "boundTopicId": null,
        "title": "Flatten Nested List Iterator",
        "titleSlug": "flatten-nested-list-iterator",
        "content": "<p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>\n\n<p>Implement the <code>NestedIterator</code> class:</p>\n\n<ul>\n\t<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>\n\t<li><code>int next()</code> Returns the next integer in the nested list.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>\n</ul>\n\n<p>Your code will be tested with the following pseudocode:</p>\n\n<pre>\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\n</pre>\n\n<p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]\n<strong>Output:</strong> [1,1,2,1,1]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [1,[4,[6]]]\n<strong>Output:</strong> [1,4,6]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>\n\t<li>The values of the integers in the nested list is in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 3804,
        "dislikes": 1335,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Flatten 2D Vector\", \"titleSlug\": \"flatten-2d-vector\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Mini Parser\", \"titleSlug\": \"mini-parser\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Array Nesting\", \"titleSlug\": \"array-nesting\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[1,1],2,[1,1]]\n[1,[4,[6]]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Tree",
                "slug": "tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Design",
                "slug": "design",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Queue",
                "slug": "queue",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Iterator",
                "slug": "iterator",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 4}, {\"taggedByAdmin\": true, \"name\": \"Twitter\", \"slug\": \"twitter\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Accolite\", \"slug\": \"accolite\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Coinbase\", \"slug\": \"coinbase\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Lyft\", \"slug\": \"lyft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Spotify\", \"slug\": \"spotify\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Yandex\", \"slug\": \"yandex\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Akuna Capital\", \"slug\": \"akuna-capital\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        \n    }\n    \n    int next() {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return empty list if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\npublic class NestedIterator implements Iterator<Integer> {\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        \n    }\n\n    @Override\n    public Integer next() {\n        \n    }\n\n    @Override\n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.hasNext()) v[f()] = i.next();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger(object):\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#        \"\"\"\n#\n#    def getList(self):\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n#        \"\"\"\n\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        \"\"\"\n        Initialize your data structure here.\n        :type nestedList: List[NestedInteger]\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger:\n#    def isInteger(self) -> bool:\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        \"\"\"\n#\n#    def getInteger(self) -> int:\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        \"\"\"\n#\n#    def getList(self) -> [NestedInteger]:\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        \"\"\"\n\nclass NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        \n    \n    def next(self) -> int:\n        \n    \n    def hasNext(self) -> bool:\n         \n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "/**\n * *********************************************************************\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * *********************************************************************\n *\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\n * bool NestedIntegerIsInteger(struct NestedInteger *);\n *\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\n * // The result is undefined if this NestedInteger holds a nested list\n * int NestedIntegerGetInteger(struct NestedInteger *);\n *\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\n * // The result is undefined if this NestedInteger holds a single integer\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\n *\n * // Return the nested list's size that this NestedInteger holds, if it holds a nested list\n * // The result is undefined if this NestedInteger holds a single integer\n * int NestedIntegerGetListSize(struct NestedInteger *);\n * };\n */\nstruct NestedIterator {\n    \n};\n\nstruct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {\n    \n}\n\nbool nestedIterHasNext(struct NestedIterator *iter) {\n    \n}\n\nint nestedIterNext(struct NestedIterator *iter) {\n    \n}\n\n/** Deallocates memory previously allocated for the iterator */\nvoid nestedIterFree(struct NestedIterator *iter) {\n    \n}\n\n/**\n * Your NestedIterator will be called like this:\n * struct NestedIterator *i = nestedIterCreate(nestedList, nestedListSize);\n * while (nestedIterHasNext(i)) printf(\"%d\\n\", nestedIterNext(i));\n * nestedIterFree(i);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool IsInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     int GetInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     IList<NestedInteger> GetList();\n * }\n */\npublic class NestedIterator {\n\n    public NestedIterator(IList<NestedInteger> nestedList) {\n        \n    }\n\n    public bool HasNext() {\n        \n    }\n\n    public int Next() {\n        \n    }\n}\n\n/**\n * Your NestedIterator will be called like this:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.HasNext()) v[f()] = i.Next();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */\nvar NestedIterator = function(nestedList) {\n    \n};\n\n\n/**\n * @this NestedIterator\n * @returns {boolean}\n */\nNestedIterator.prototype.hasNext = function() {\n    \n};\n\n/**\n * @this NestedIterator\n * @returns {integer}\n */\nNestedIterator.prototype.next = function() {\n    \n};\n\n/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n#\n#class NestedInteger\n#    def is_integer()\n#        \"\"\"\n#        Return true if this NestedInteger holds a single integer, rather than a nested list.\n#        @return {Boolean}\n#        \"\"\"\n#\n#    def get_integer()\n#        \"\"\"\n#        Return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return nil if this NestedInteger holds a nested list\n#        @return {Integer}\n#        \"\"\"\n#\n#    def get_list()\n#        \"\"\"\n#        Return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return nil if this NestedInteger holds a single integer\n#        @return {NestedInteger[]}\n#        \"\"\"\n\nclass NestedIterator\n    # @param {NestedInteger[]} nested_list\n    def initialize(nested_list)\n        \n    end\n\n    # @return {Boolean}\n    def has_next\n        \n    end\n\n    # @return {Integer}\n    def next\n        \n    end\nend\n\n# Your NestedIterator will be called like this:\n# i, v = NestedIterator.new(nested_list), []\n# while i.has_next()\n#    v << i.next\n# end",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public func isInteger() -> Bool\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     public func getInteger() -> Int\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public func setInteger(value: Int)\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public func add(elem: NestedInteger)\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     public func getList() -> [NestedInteger]\n * }\n */\n\nclass NestedIterator {\n\n    init(_ nestedList: [NestedInteger]) {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * let obj = NestedIterator(nestedList)\n * let ret_1: Int = obj.next()\n * let ret_2: Bool = obj.hasNext()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * type NestedInteger struct {\n * }\n *\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\n * func (this NestedInteger) IsInteger() bool {}\n *\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\n * // The result is undefined if this NestedInteger holds a nested list\n * // So before calling this method, you should have a check\n * func (this NestedInteger) GetInteger() int {}\n *\n * // Set this NestedInteger to hold a single integer.\n * func (n *NestedInteger) SetInteger(value int) {}\n *\n * // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n * func (this *NestedInteger) Add(elem NestedInteger) {}\n *\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\n * // The list length is zero if this NestedInteger holds a single integer\n * // You can access NestedInteger's List element directly if you want to modify it\n * func (this NestedInteger) GetList() []*NestedInteger {}\n */\n\ntype NestedIterator struct {\n    \n}\n\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\n    \n}\n\nfunc (this *NestedIterator) Next() int {\n    \n}\n\nfunc (this *NestedIterator) HasNext() bool {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * trait NestedInteger {\n *\n *   // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *   def isInteger: Boolean\n *\n *   // Return the single integer that this NestedInteger holds, if it holds a single integer.\n *   def getInteger: Int\n *\n *   // Set this NestedInteger to hold a single integer.\n *   def setInteger(i: Int): Unit\n *\n *   // Return the nested list that this NestedInteger holds, if it holds a nested list.\n *   def getList: Array[NestedInteger]\n *\n *   // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *   def add(ni: NestedInteger): Unit\n * }\n */\n\nclass NestedIterator(_nestedList: List[NestedInteger]) {\n    def next(): Int = {\n        \n    }\n    \n    def hasNext(): Boolean = {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * var obj = new NestedIterator(nestedList)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     constructor()\n *\n *     // Constructor initializes a single integer.\n *     constructor(value: Int)\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     fun isInteger(): Boolean\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     fun getInteger(): Int?\n *\n *     // Set this NestedInteger to hold a single integer.\n *     fun setInteger(value: Int): Unit\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     fun add(ni: NestedInteger): Unit\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     fun getList(): List<NestedInteger>?\n * }\n */\n\nclass NestedIterator(nestedList: List<NestedInteger>) {\n    fun next(): Int {\n        \n    }\n    \n    fun hasNext(): Boolean {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * var obj = NestedIterator(nestedList)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "// #[derive(Debug, PartialEq, Eq)]\n// pub enum NestedInteger {\n//   Int(i32),\n//   List(Vec<NestedInteger>)\n// }\nstruct NestedIterator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NestedIterator {\n\n    fn new(nestedList: Vec<NestedInteger>) -> Self {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * let obj = NestedIterator::new(nestedList);\n * let ret_1: i32 = obj.next();\n * let ret_2: bool = obj.has_next();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *\n *     // if value is not specified, initializes an empty list.\n *     // Otherwise initializes a single integer equal to value.\n *     function __construct($value = null)\n *\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     function isInteger() : bool\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     function getInteger()\n *\n *     // Set this NestedInteger to hold a single integer.\n *     function setInteger($i) : void\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     function add($ni) : void\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     function getList() : array\n * }\n */\n\nclass NestedIterator {\n    /**\n     * @param NestedInteger[] $nestedList\n     */\n    function __construct($nestedList) {\n        \n    }\n    \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n    \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * $obj = NestedIterator($nestedList);\n * $ret_1 = $obj->next();\n * $ret_2 = $obj->hasNext();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     If value is provided, then it holds a single integer\n *     Otherwise it holds an empty nested list\n *     constructor(value?: number) {\n *         ...\n *     };\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     isInteger(): boolean {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     getInteger(): number | null {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a single integer equal to value.\n *     setInteger(value: number) {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n *     add(elem: NestedInteger) {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds,\n *     or an empty list if this NestedInteger holds a single integer\n *     getList(): NestedInteger[] {\n *         ...\n *     };\n * };\n */\n\nclass NestedIterator {\n    constructor(nestedList: NestedInteger[]) {\n\t\t\n    }\n\n    hasNext(): boolean {\n\t\t\n    }\n\n\tnext(): number {\n\t\t\n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new NestedIterator(nestedList)\n * var a: number[] = []\n * while (obj.hasNext()) a.push(obj.next());\n */",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"332.4K\", \"totalSubmission\": \"544.7K\", \"totalAcceptedRaw\": 332411, \"totalSubmissionRaw\": 544660, \"acRate\": \"61.0%\"}",
        "hints": [],
        "solution": {
            "id": "917",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,1],2,[1,1]]",
        "metaData": "{\n  \"name\": \"\",\n  \"params\": [\n    {\n      \"name\": \"nestedList\",\n      \"type\": \"list<NestedInteger>\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  },\n  \"manual\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "907",
            "date": "2022-05-08",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "917",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nIf you aren't at all familiar with Iterators, then we suggest having a go at [Peeking Iterator](https://leetcode.com/problems/peeking-iterator/). Additionally, the [Solution Article for Peeking Iterator](https://leetcode.com/problems/peeking-iterator/solution/) has a special introduction section that introduces you to what Iterators are.\n\nIf you're still having trouble, have a go at writing a function that simply flattens a nested list (i.e. not as an iterator). Then, think about how you could adapt it to be an iterator.\n\nIn this article, we cover 5 approaches. Approach 4 is primarily for Java programmers, and Approach 5 is for programmers of languages where generators are supported.\n\n<br/>\n\n---\n\n#### Approach 1: Make a Flat List with Recursion\n\n**Intuition**\n\nThe simplest way of solving this problem is to flatten the entire input list, in the constructor. Then the actual iterator methods can simply work with this flattened list instead of needing to worry about the input structure.\n\nThis approach splits the coding into two parts:\n\n1. A function that the constructor can call to make a flattened list. \n2. `next()` and `hasNext()` methods that iterate over a plain list, by keeping track of the current position within it.\n\nThe first part is best done with recursion (iteration is more complicated, and if you were going to use it, then you may as well look at approaches 2, 3, and 4 instead). This approach is the only recursive one that works in any programming language (as of the time of writing this article, things are changing!).\n\nTo flatten the list recursively, notice that we can look at the input as a tree. The integers are the leaf nodes, and the order they should be returned is from left to right.\n\n!?!../Documents/341_flatten_tree_expansion.json:960,540!?!\n\nTherefore, we can use a recursive depth-first search to flatten it.\n\n```text\nintegers = []\n\ndefine function flattenList(nestedList):\n    for nestedInteger in nestedList:\n        if nestedInteger.isInteger():\n            append nestedInteger.getInteger() to integers\n        else:\n            recursively call flattenList on nestedInteger.getList()\n```\n\nHere is an animation showing the flattening algorithm.\n\n!?!../Documents/341_flatten_tree.json:960,600!?!\n\n**Algorithm**\n\n<iframe src=\"https://leetcode.com/playground/eSjMjErq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"eSjMjErq\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the total number of *integers* within the nested list, $$L$$ be the total number of *lists* within the nested list, and $$D$$ be the maximum nesting depth (maximum number of lists inside each other).\n\n- Time complexity:\n\n    We'll analyze each of the methods separately.\n\n    \n    - **Constructor:** $$O(N + L)$$.\n\n        The constructor is where all the time-consuming work is done.\n\n        For each list within the nested list, there will be one call to `flattenList(...)`. The loop within `flattenList(...)` will then iterate $$n$$ times, where $$n$$ is the number of integers within that list. Across all calls to `flattenList(...)`, there will be a total of $$N$$ loop iterations. Therefore, the time complexity is the number of lists plus the number of integers, giving us $$O(N + L)$$.\n\n        Notice that the maximum depth of the nesting does not impact the time complexity.\n        \n\n    - **next():** $$O(1)$$.\n        \n        Getting the next element requires incrementing `position` by 1 and accessing an element at a particular index of the `integers` list. Both of these are $$O(1)$$ operations.\n\n    - **hasNext():** $$O(1)$$.\n\n        Checking whether or not there is a next element requires comparing the length of the `integers` list to the `position` variable. This is an $$O(1)$$ operation.\n        \n\n- Space complexity : $$O(N + D)$$.\n\n    The most obvious auxiliary space is the `integers` list. The length of this is $$O(N)$$.\n\n    The less obvious auxiliary space is the space used by the `flattenList(...)` function. Recall that recursive functions need to keep track of where they're up to by putting stack frames on the runtime stack. Therefore, we need to determine what the maximum number of stack frames there could be at a time is. Each time we encounter a nested list, we call `flattenList(...)` and a stack frame is added. Each time we finish processing a nested list, `flattenList(...)` returns and a stack frame is removed. Therefore, the maximum number of stack frames on the runtime stack is the maximum nesting depth, $$D$$. \n\n    Because these two operations happen one-after-the-other, and either could be the largest, we add their time complexities together giving a final result of $$O(N + D)$$.\n\n<br/>\n\n---\n\n#### Approach 2: Stack\n\n**Intuition**\n\nThe downside of Approach 1 is that it creates a new data structure instead of simply iterating over the given one. Instead, we should find a way to step through the integers, one at a time, keeping track of where we're currently up to in `nestedList`.\n\nA better way is to do an iterative depth-first search, based on the following tree traversal algorithm:\n\n```text\ndefine function iterativeDepthFirstSearch(nestedList):\n    result = []\n\n    stack = a new Stack\n    push all items in nestedList onto stack, in reverse order\n\n    while stack is not empty:\n        nestedInteger = pop top of stack\n        if nestedInteger.isInteger():\n            append nestedInteger.getInteger() to result\n        else:\n            list = nestedInteger.getList()\n            push all items in list onto stack, in reverse order\n\n    return result\n```\n\nWhile we could use this algorithm in the constructor like before, a better way would be to store `stack` on the iterator object and progress the algorithm on each call to `next()` to get the next integer out.\n\nNotice that if the top of the stack is an integer, then we've already found the next integer. Otherwise, if it's a list, then the `else` is adding the list contents to `stack`. On the next loop iteration, the same will happen. We could write an algorithm to get the next integer as follows.\n\n```text\nstack = a new Stack\npush all items in nestedList onto stack, in reverse order\n\ndefine function getNextInteger():\n    while stack is not empty:\n        nestedInteger = pop top off stack\n        if nestedInteger.isInteger():\n            RETURN nestedInteger.getInteger()\n        else:\n            list = nestedInteger.getList()\n            push all items in list onto stack, in reverse order\n\n```\n\nNotice that the `stack` is shared between calls. This means that `getNextInteger()` will find an integer and return it, while still preserving the state of the stack. We can then call `getNextInteger()` again to get the next integer, and so forth.\n\nTo simplify the code a bit, we can change our loop condition so that it checks if the top of the stack is still a list. The loop body should push the contents of the list onto the stack (in reverse). Eventually, there will be an integer on the top of the stack, OR the stack will be empty. Being able to get the next integer to the top of the stack allows the `next()` and `hasNext()` methods to access it.\n\n```text\nstack = a new Stack\npush all items in nestedList onto stack, in reverse order\n\ndefine function makeStackTopAnInteger():\n    while stack is not empty AND the nestedInteger at top of stack is a list:\n        nestedInteger = pop top off stack\n        list = nestedInteger.getList()\n        push all items in list onto stack, in reverse order\n```\n\n\n**Algorithm**\n\nLet's define a private method called `makeStackTopAnInteger()` that contains the algorithm to make the stack top an integer (as described above). The `makeStackTopAnInteger()` method never *removes* integers. \n\nThe `next()` and `hasNext()` methods should call `makeStackTopAnInteger()` before doing anything else. This means that they can then *assume* that either the stack top is an integer, *or* the stack is empty. Then, their definitions are as follows:\n\n- **hasNext():** Returns `true` if the stack still contains items, `false` if not.\n- **next():** If the stack still contains items, then it is guaranteed the top is an integer. This integer is popped and returned. If the stack is empty, then the behavior is language-dependent. For example, in Java, a `NoSuchElementException` should be throw.\n\n\n<iframe src=\"https://leetcode.com/playground/TP2VJHdq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"TP2VJHdq\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the total number of *integers* within the nested list, $$L$$ be the total number of *lists* within the nested list, and $$D$$ be the maximum nesting depth (maximum number of lists inside each other).\n\n- Time complexity.\n\n    - **Constructor:** $$O(N + L)$$.\n\n        The worst-case occurs when the initial input nestedList consists entirely of integers and empty lists (everything is in the top-level). In this case, every item is reversed and stored, giving a total time complexity of $$O(N + L)$$.\n\n    - **makeStackTopAnInteger():** $$O(\\dfrac{L}{N})$$ or $$O(1)$$.\n\n        If the top of the stack is an integer, then this function does nothing; taking $$O(1)$$ time.\n\n        Otherwise, it needs to process the stack until an integer is on top. The best way of analyzing the time complexity is to look at the total cost across all calls to `makeStackTopAnInteger()` and then divide by the number of calls made. Once the iterator is exhausted `makeStackTopAnInteger()` must have seen every integer at least once, costing $$O(N)$$ time. Additionally, it has seen every list (except the first) on the stack at least once also, so this costs $$O(L)$$ time. Adding these together, we get $$O(N + L)$$ time.\n\n        The amortized time of a single `makeStackTopAnInteger` is the total cost, $$O(N + L)$$, divided by the number of times it's called. In order to get all integers, we need to have called it $$N$$ times. This gives us an amortized time complexity of $$\\dfrac{O(N + L)}{N} = O(\\dfrac{N}{N} + \\dfrac{L}{N}) = O(\\dfrac{L}{N})$$.\n\n    - **next():** $$O(\\dfrac{L}{N})$$ or $$O(1)$$.\n\n        All of this method is $$O(1)$$, except for possibly the call to `makeStackTopAnInteger()`, giving us a time complexity the same as `makeStackTopAnInteger()`.\n\n    - **hasNext():** $$O(\\dfrac{L}{N})$$ or $$O(1)$$.\n\n        All of this method is $$O(1)$$, except for possibly the call to `makeStackTopAnInteger()`, giving us a time complexity the same as `makeStackTopAnInteger()`.\n\n- Space complexity : $$O(N + L)$$.\n\n    In the worst case, where the top list contains $$N$$ integers, or $$L$$ empty lists, it will cost $$O(N + L)$$ space. Other expensive cases occur when the nesting is very deep. However, it's useful to remember that $$D \u2264 L$$ (because each layer of nesting requires another list), and so we don't need to take this into account.\n\n<br/>\n\n---\n\n#### Approach 3: Two Stacks\n\n**Intuition**\n\nReversing the lists to put them onto the stack can be an expensive operation, and it turns out it isn't necessary.\n\nInstead of pushing every item of a sub-list onto the stack, we can instead associate an index pointer with each sub-list, that keeps track of how far along that sub-list we are. Adding a new sub-list to the stack now becomes an $$O(1)$$ operation instead of a $$O(length of sublist)$$ one. \n\nHere is an animation showing this approach.\n\n!?!../Documents/341_flatten_tree_two_stacks.json:960,400!?!\n\nThe *total* time complexity across all method calls for using up the entire iterator remains the same, *but* work is only done when it's necessary, thus improving performance when we only use part of the iterator. This is a desirable property for an iterator.\n\n**Algorithm**\n\nThis approach can be implemented as either one stack of pairs/ tuples, or two stacks with one for `NestedInteger`s and the other for indexes. The best decision for this is language-dependent. I tried both for the Java and found that attempting to put `Pair` objects onto a single stack doesn't work well because updating an index count requires popping and then reconstructing the entire `Pair` due to immutability (alternatives such as using length-2 `Lists`s as pairs are possible, but I don't think ideal). Using two stacks is cleaner.\n\n<iframe src=\"https://leetcode.com/playground/kw9U2WL6/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"kw9U2WL6\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the total number of *integers* within the nested list, $$L$$ be the total number of *lists* within the nested list, and $$D$$ be the maximum nesting depth (maximum number of lists inside each other).\n\n- Time complexity:\n\n    - **Constructor:** $$O(1)$$.\n\n        Pushing a list onto a `stack` is *by reference* in all the programming languages we're using here. This means that instead of creating a new list, some information about how to get to the existing list is put onto the stack. The list is not traversed, as it doesn't need reversing this time, and we're not pushing the items on one-by-one. This is, therefore, an $$O(1)$$ operation.\n\n    - **makeStackTopAnInteger() / next() / hasNext():** $$O(\\dfrac{L}{N})$$ or $$O(1)$$.\n\n        Same as Approach 2.\n\n- Space complexity : $$O(D)$$.\n\n    At any given time, the stack contains only *one* nestedList reference for each level. This is unlike the previous approach, wherein the worst case we need to put almost all elements onto the stack.\n\n    Because there's one reference on the stack at each level, the worst case is when we're looking at the deepest leveled list, giving a space complexity is $$O(D)$$.\n\n<br/>\n\n---\n\n#### Approach 4: Stack of Iterators\n\n**Intuition**\n\n*This approach works best in Java but isn't well suited to other languages. Have a look at Approach 5 if you're looking for an elegant Python and JavaScript approach.*\n\nIf you're using Java, a very elegant approach is to maintain a stack of `ListIterators`. This approach is closely based on Approach 3. \n\nInstead of keeping a `Stack` of indexes to keep track of where we are in each `List`, we can simply make each `List` a `ListIterator`, thus keeping a `Stack` of `ListIterator`s. Then, we can use the `next()` and `hasNext()` methods on those `ListIterators`. Internally, the `ListIterator` is storing the index.\n\nA downside to this approach is that for `hasNext()` to work correctly, it needs to know whether or not there are any *integers* remaining (empty lists don't count!). The only way it can do this is to remove items from the `ListIterator` and check whether or not they are an integer. It cannot, however, put the integers back again. Therefore, if it removes an integer it will need to put it into a `peeked` field so that the `next()` function can return that integer. This is the same as in the [Peeking Iterator](https://leetcode.com/problems/peeking-iterator/) problem.\n\nA clean design is to have a `setPeeked()` method that is analogous to the `makeStackTopAnInteger()` method. This method should firstly check if `peeked` is empty, and if it is empty, then find the next integer to put in it. This integer is *removed* from the stack (as explained above).\n\nRegardless of the need for `peeked`, this is probably the best design if you're coding in Java.\n\n**Algorithm**\n\n<iframe src=\"https://leetcode.com/playground/uMiDg5K9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"uMiDg5K9\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the total number of *integers* within the nested list, $$L$$ be the total number of *lists* within the nested list, and $$D$$ be the maximum nesting depth (maximum number of lists inside each other).\n\n- Time complexity:\n\n    - **Constructor:** $$O(1)$$.\n\n        Same as Approach 3.\n\n    - **makeStackTopAnInteger() / next() / hasNext():** $$O(\\dfrac{L}{N})$$ or $$O(1)$$.\n\n        Same as Approach 3.\n\n- Space complexity : $$O(D)$$.\n\n    Same as Approach 3.\n\nIn practice, this code runs faster than Approach 3, probably because most of the functionality relies on `ListIterator`; an optimized API class. Approach 3 was really just our own implementation of `ListIterator`s.\n\n<br/>\n\n---\n\n#### Approach 5: Using a Generator\n\n**Intuition**\n\n*This approach will only work in programming languages that support **generator functions**, for example, **Python**, **JavaScript** and **C#**. At the time of writing this article, **C++** doesn't support it, but it is expected to support them soon.* \n\nIn a nutshell, generator functions are a special type of function that can \"return\" multiple values. When you call a **generator function**, you get back a special object called a **generator**. This **generator** can then be used to get each value from the function, one at a time.\n\nTo \"return\" multiple values from these **generator functions**, a special keyword, `yield`, is used. `yield` behaves similarly to a `return` statement, except that it does not terminate the function. Instead, it pauses the function, and \"returns\" the `yield`ed value. Then, when we need another value, the function resumes from where it left off. It continues until it gets to another `yield`, just like before. When the function gets to the end (no more code left to run), it stops. \n\nFor example in Python, if we have a **generator** `gen`, we can tell it to resume the function and get the next value by calling `next(gen)`.\n\nAs an example, the **generators** created by this Python **generator function** can be used to get all numbers from `a` to `b`:\n\n```python\n# This is effectively how range works in Python. We're implementing our own\n# version of it here to see how generators work.\n# Many Python 3 library functions are generators.\ndef range_generator(a, b):\n    current = a\n    while current < b:\n        # This yield \"returns\" a value from the function and pauses it\n        yield current\n        # Once the function is \"woken up\" by another call to next(...), it will resume\n        # by continuing with the next statement (current += 1), until it either\n        # hits another yield or reaches the end of the function\n        current += 1\n    # When we get here, the generator is finished.\n\n# Create a new range_generator object for the numbers 10 to 20.\nten_to_twenty_generator = range_generator(10, 20)\n\n# Get the first 3 values out of the range_generator object we made.\nprint(next(ten_to_twenty_generator)) # 10\nprint(next(ten_to_twenty_generator)) # 11\nprint(next(ten_to_twenty_generator)) # 12\n\n# Here's another example of using the generator with a loop. As we said, it's\n# the same as the range function.\n# This is a new generator object, not the 10-20 one from above.\nfor number in range_generator(5, 9):\n    print(number)\nprint(\"Done!\")\n# Will print\n# 5\n# 6\n# 7\n# 8\n# Done\n```\n\n\nEnd-of-function behaviour for **generators** is language-dependent. For example, in Python, once the end of the function is reached, a `StopIteration` exception is raised. When you use your generator in a loop, e.g. `for number in range_generator(5, 9):`, it will simply stop when it gets this exception. The programmer doesn't need to explicitly handle it.\n\nNow that we know what a **generator** is, we'll use one to implement a `NestedIterator`. \n\nBack in Approach 1, we started by flattening the entire list with the following recursive algorithm:\n\n```python\nintegers = []\ndef flatten_list(nested_list):\n    for nested_integer in nested_list:\n        if nested_integer.isInteger():\n            integers.append(nested_integer.getInteger())\n        else:\n            flatten_list(nested_integer.getList())\n```\n\nSomething cool about **generator functions** is that they can be recursive.\n\nSo, instead of pushing each integer to a list, we could just `yield` them. This way, when we want the next integer, the function will resume from after the `yield` until it finds the next one. \n\nLet's replace the list append with `yield`.\n\n```python\ndef flatten_list(nested_list):\n    for nested_integer in nested_list:\n        if nested_integer.isInteger():\n            yield nested_integer.getInteger()\n        else:\n            flatten_list(nested_integer.getList())\n```\n\nThis has a mistake though; because `flatten_list` is now a generator function, the recursive call to `flatten_list` only *creates a new generator*; it doesn't actually `yield` the values from the nested generator.\n\nTo fix this, we can loop over each item of the recursive generator and `yield` them instead.\n\n```python\ndef flatten_list(nested_list):\n    for nested_integer in nested_list:\n        if nested_integer.isInteger():\n            yield nested_integer.getInteger()\n        else:\n            for integer in flatten_list(nested_integer.getList()):\n                yield integer\n```\n\nSome languages, such as Python, offer a shorthand for this looping, in Python called `yield from`. Here is its usage.\n\n```python\ndef flatten_list(nested_list):\n    for nested_integer in nested_list:\n        if nested_integer.isInteger():\n            yield nested_integer.getInteger()\n        else:\n            yield from flatten_list(nested_integer.getList())\n```\n\nNote that, not all languages that support `yield` also support `yield from`. For example, **C#** has `yield`, but no `yield from` equivalent. JavaScript supports it, but instead calls it `yield*`.\n\n**Algorithm**\n\nFor this approach, we also need to add a `peeked` field, much like in the [Peeking Iterator](https://leetcode.com/problems/peeking-iterator/) problem. This is because the only way to know if there *is* a next value is to take it out of the generator, and generators can only go forwards, not backward.\n\n<iframe src=\"https://leetcode.com/playground/T6oKpBQF/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"T6oKpBQF\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the total number of *integers* within the nested list, $$L$$ be the total number of *lists* within the nested list, and $$D$$ be the maximum nesting depth (maximum number of lists inside each other).\n\n- Time complexity:\n\n    - **Constructor:** $$O(1)$$.\n\n        In the constructor, we only create a generator object. Simply creating a generator object doesn't invoke any code in the generator function itself (only calls to next do).\n\n        Because the time taken to create the generator doesn't vary with the size of the input, the time complexity is $$O(1)$$.\n\n    - **next() / hasNext():** $$O(\\dfrac{L}{N})$$ or $$O(1)$$.\n\n        Same as approaches 2, 3, and 4.\n\n\n- Space complexity : $$O(D)$$.\n\n    We recursively call `_int_generator` within itself for nested lists. Therefore, the runtime stack uses memory proportional to the current depth of the list. Seeing as the largest depth is $$D$$, the space complexity is $$O(D)$$.\n\n<br/>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "865",
            "count": 112,
            "average": "4.946",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "flatten-nested-list-iterator",
    "playgroundData": {
        "eSjMjErq": {
            "playground": {
                "testcaseInput": "",
                "name": "flatten-nested-iterator-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "TP2VJHdq": {
            "playground": {
                "testcaseInput": "",
                "name": "flatten-nested-iterator-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "kw9U2WL6": {
            "playground": {
                "testcaseInput": "",
                "name": "flatten-nested-iterator-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "uMiDg5K9": {
            "playground": {
                "testcaseInput": "",
                "name": "flatten-nested-iterator-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "T6oKpBQF": {
            "playground": {
                "testcaseInput": "",
                "name": "flatten-nested-iterator-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}