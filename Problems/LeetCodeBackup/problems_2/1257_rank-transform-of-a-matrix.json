{
    "id": "1257",
    "question": {
        "questionId": "1257",
        "questionFrontendId": "1632",
        "boundTopicId": null,
        "title": "Rank Transform of a Matrix",
        "titleSlug": "rank-transform-of-a-matrix",
        "content": "<p>Given an <code>m x n</code> <code>matrix</code>, return <em>a new matrix </em><code>answer</code><em> where </em><code>answer[row][col]</code><em> is the </em><em><strong>rank</strong> of </em><code>matrix[row][col]</code>.</p>\n\n<p>The <strong>rank</strong> is an <strong>integer</strong> that represents how large an element is compared to other elements. It is calculated using the following rules:</p>\n\n<ul>\n\t<li>The rank is an integer starting from <code>1</code>.</li>\n\t<li>If two elements <code>p</code> and <code>q</code> are in the <strong>same row or column</strong>, then:\n\t<ul>\n\t\t<li>If <code>p &lt; q</code> then <code>rank(p) &lt; rank(q)</code></li>\n\t\t<li>If <code>p == q</code> then <code>rank(p) == rank(q)</code></li>\n\t\t<li>If <code>p &gt; q</code> then <code>rank(p) &gt; rank(q)</code></li>\n\t</ul>\n\t</li>\n\t<li>The <strong>rank</strong> should be as <strong>small</strong> as possible.</li>\n</ul>\n\n<p>The test cases are generated so that <code>answer</code> is unique under the given rules.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/18/rank1.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2],[3,4]]\n<strong>Output:</strong> [[1,2],[2,3]]\n<strong>Explanation:</strong>\nThe rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.\nThe rank of matrix[0][1] is 2 because matrix[0][1] &gt; matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][0] is 2 because matrix[1][0] &gt; matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][1] is 3 because matrix[1][1] &gt; matrix[0][1], matrix[1][1] &gt; matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/18/rank2.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[7,7],[7,7]]\n<strong>Output:</strong> [[1,1],[1,1]]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/18/rank3.jpg\" style=\"width: 601px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\n<strong>Output:</strong> [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[row][col] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 643,
        "dislikes": 45,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Rank Transform of an Array\", \"titleSlug\": \"rank-transform-of-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"GCD Sort of an Array\", \"titleSlug\": \"gcd-sort-of-an-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[1,2],[3,4]]\n[[7,7],[7,7]]\n[[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Greedy",
                "slug": "greedy",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Union Find",
                "slug": "union-find",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Graph",
                "slug": "graph",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Topological Sort",
                "slug": "topological-sort",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}], \"2\": [], \"3\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int[][] matrixRankTransform(int[][] matrix) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def matrixRankTransform(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** matrixRankTransform(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int[][] MatrixRankTransform(int[][] matrix) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar matrixRankTransform = function(matrix) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @return {Integer[][]}\ndef matrix_rank_transform(matrix)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func matrixRankTransform(_ matrix: [[Int]]) -> [[Int]] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func matrixRankTransform(matrix [][]int) [][]int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def matrixRankTransform(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun matrixRankTransform(matrix: Array<IntArray>): Array<IntArray> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn matrix_rank_transform(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return Integer[][]\n     */\n    function matrixRankTransform($matrix) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function matrixRankTransform(matrix: number[][]): number[][] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (matrix-rank-transform matrix)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec matrix_rank_transform(Matrix :: [[integer()]]) -> [[integer()]].\nmatrix_rank_transform(Matrix) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec matrix_rank_transform(matrix :: [[integer]]) :: [[integer]]\n  def matrix_rank_transform(matrix) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"17.8K\", \"totalSubmission\": \"43.7K\", \"totalAcceptedRaw\": 17805, \"totalSubmissionRaw\": 43672, \"acRate\": \"40.8%\"}",
        "hints": [
            "Sort the cells by value and process them in increasing order.",
            "The rank of a cell is the maximum rank in its row and column plus one.",
            "Handle the equal cells by treating them as components using a union-find data structure."
        ],
        "solution": {
            "id": "1035",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,2],[3,4]]",
        "metaData": "{\n  \"name\": \"matrixRankTransform\",\n  \"params\": [\n    {\n      \"name\": \"matrix\",\n      \"type\": \"integer[][]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer[][]\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1035",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nThis problem is an extension of the original problem, [Rank Transform of an Array](https://leetcode.com/problems/rank-transform-of-an-array/). However, the original method in the original problem does not work. To tackle this, we need to add some similar methods used in [Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/). Moreover, to avoid *Time Limit Exceeded*, some optimization tricks should be applied.\n\nIt's indeed a hard problem, so please don't be frustrated if you can not solve it.\n\nBelow, we will discuss three approaches: *Sorting + BFS*, *Sorting + DFS*, and *Sorting + Union-Find*.\n\nIt's recommended to start reading from approach 1. Also, it's a long article, so take your time to read it.\n\n---\n\n#### Approach 1: Sorting + BFS\n\n**Intuition**\n\nLet's recall the method used in the original [Rank Transform of an Array](https://leetcode.com/problems/rank-transform-of-an-array/). The idea is simple: sort the values in the array, and arrange the ranks from the lowest value to the highest value.\n\nIt's natural to consider applying the same thing to our matrix: **sort the values in the matrix, and arrange the ranks from the lowest one to the highest one**.\n\nHowever, this method does not work. In this problem, we are only required to rank values according to row and column, and not to the whole matrix. The condition is looser.\n\nIf we arrange the ranks according to the whole matrix, the resulting rank will be huger than what we want.\n\nFor example, consider this case:\n\n![Figure 1](../Figures/5156/5156_1.png)\n\nIn this case, if we just rank `[2, 3, 4, 5]` by their values as `[1, 2, 3, 4]`, we will get a larger rank for some elements.\n\nWe need to make some modifications to get our solution to work.\n\nThe idea of sorting and ranking from small value to large value is good. The only problem is that the rank is larger than required. We want to reduce the rank to as small as possible.\n\nWhen arranging ranks, we can check existing ranks in the same row and the same column, and let the rank be the largest rank checked plus one. \n\nFor example, in the above matrix, when we fill in the rank of value `4` (corresponding order is `3`):\n\n![Figure 2](../Figures/5156/5156_2.png)\n\nThe pseudo-code is as below. Let the required rank matrix be `answer`.\n\n<pre>\ninitial answer to all zero\nfor (i, j) in sorted_order:\n    rank = -1\n    for row in 0...m-1:\n        rank = max(rank, answer[row][j] + 1)\n    for col in 0...n-1:\n        rank = max(rank, answer[i][col] + 1)\n    answer[i][j] = rank\n</pre>\n\nHowever, this approach still can not achieve the target rank matrix. There are two problems, and we will discuss that later.\n\nNow, let's analyze the complexity first.\n\n> It's recommended to find out an entire working approach and then optimize it. However, for the convenience of writing, we do the optimization here.\n\nLet $$M$$ be the number of rows and $$N$$ be the number of columns.\n\nSince there is $$\\mathcal{O}(NM)$$ points in the matrix, and for each point, we are required to search the row and column to determine its rank, the overall time complexity is $$\\mathcal{O}(NM\\cdot(N+M))$$.\n\nIn the worst cases, where $$M=500$$ and $$N=500$$, $$NM\\cdot(N+M) = 500 \\cdot 500 \\cdot (500 + 500) = 2.5 * 10^8$$.\n\nGenerally, to avoid *Time Limit Exceeded*, a complexity less than $$10^9$$ is needed. $$10^8$$ is dangerous. Can we simplify it?\n\nNotice that we calculated the max of each row and each column many times. We can pre-calculate the maximum before iteration and update that max during the iteration.\n\nWe can use two arrays, `rowMax`  and `colMax`, to record the maximum rank of each row and each column, respectively.\n\n> `rowMax[i]` means the max rank in `i` row, and `colMax[j]` means the max rank in `j` column.\n\nTake the above example again. If we use these two arrays, we calculate ranks in this way:\n\n![Figure 3](../Figures/5156/5156_3.png)\n\nThe pseudo-code is as below.\n\n<pre>\ninitial answer to all zero\ninitial rowMax and colMax to all zero\nfor (i, j) in sorted_order:\n    rank = max(rowMax[i], colMax[i]) + 1\n    answer[i][j] = rank\n    update rowMax and colMax\n</pre>\n\nGood. Now we only need $$\\mathcal{O}(1)$$ for each point. The overall complexity is $$\\mathcal{O}(NM)$$ for this part. Notice that sorting requires $$\\mathcal{O}(NM\\log(NM))$$, so the complexity so far is $$\\mathcal{O}(NM\\log(NM))$$.\n\nGo back to our approach. In the above, we mention that there are two problems in the code.\n\nThe first one is that the minimal rank is not always the maximum of other ranks in the same row and columns plus one. It might be the same as the maximum.\n\nFor instance, consider this case:\n\n![Figure 4](../Figures/5156/5156_4.png)\n\nWe can see that, if the value is the same, we may not need to add one to the maximum rank.\n\nWell... we can use some if-conditions to solve this problem.\n\nThe second problem is even worse: we may need to adjust the previous rank we set before.\n\nTake the below case as an example. In this case, we have filled all the rank matrix except the right-down corner.\n\n![Figure 5](../Figures/5156/5156_5.png)\n\nSince points with the same value in the same row or same column should share the same rank, we need to adjust the other 33.\n\nSo, how to solve this problem?\n\nLet's dig into what parts should be adjusted.\n\nConsider this case:\n\n![Figure 6](../Figures/5156/5156_6.png)\n\nNote that the connected points should share the same rank, since they are connected by some \"same row or same column\" connections.\n\nAlso, there is one single `11` and one single `33` that do not connect to any other points, since they do not have such connection.\n\nIn conclusion, the points with the same value connected by the \"same row or same column\" connection should share the same rank. Let's call those points \"**connected part**\".\n\n> **Connected part** means a group of points with the same value, where any two points can be linked by a path consisting of horizontal lines (\"the same row\" connection) and vertical lines (\"the same column\" connection).\n\nTo avoid adjusting, we can find out the whole connected part's maximum rank first and then update that rank to each point in the part.\n\nIn this way, we can also avoid the first problem because the ranks in different connected parts are always different.\n\nNow the question remaining is how to find the \"connected parts\"?\n\nThis question is similar to [Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/), where we need to find the *numbers* of connected parts.\n\nIn [Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/), there are three methods to locate the connected parts: BFS, DFS, and Union-Find. Here, we discuss BFS first.\n\n> In approach 1, we discuss BFS first and discuss the remaining two in approach 2 and approach 3, respectively.\n\nThe idea of BFS is simple: from a starting point, add all the directly connected points (i.e., with the same row or same column) into a waiting queue, pop points from the waiting queue, add new directly connected points into the queue, and repeat until the queue is empty.\n\n<pre>\nadd starting points to Queue q\nwhile q is not empty:\n    point p = q.pop()\n    add p's adjacent points to q, skip visited points\n</pre>\n\nThis search costs $$\\mathcal{O}(V + E)$$, where $$V$$ is the number of points and $$E$$ is the number of edges in the graph, since we visit each point and each edge constant times.\n\nWe have $$\\mathcal{O}(NM)$$ points, and if every two points are connected, the number of edges are $$\\mathcal{O}((NM)^2)$$.  Therefore, in worst case, $$\\mathcal{O}(V + E) = \\mathcal{O}((NM)^2) = 500^4 = 6.25 * 10^{10}$$. This will absolutely cause *Time Limit Exceeded*.\n\nCan we simplify it?\n\nInstead of connecting point to point, we can connect **row** to **column**, and **column** to **row**.\n\nConsider viewing a point `(i, j)` as an **edge** linking `i`-th row and `j`-th column.\n\nFor example, see this case:\n\n![Figure 7](../Figures/5156/5156_7.png)\n\nFor a point `(i, j)`, we connect `i`-th row and `j`-th column together. With this graph, we can easily find the connected parts.\n\n> For example, in the graph above, starting from `(0, 0)`, searching the neighbors of Row 0, we can find Col 0, and Col 2. Therefore, `(0, 0)` and `(0, 2)` are connected.\n>\n> Continue searching the neighbors of Col2, we can find Row 0 and Row 2. We have visited Row 0, but Row 2 is new. Hence, `(0, 0)`, `(0, 2)`, and `(2, 2)` are connected. Search the neighbors of Row 2, we find nothing new. For `(0, 0)`, we can also search the neighbors of Col 0.\n>\n> After this search, we get `(0, 0)`'s connected parts: `(0, 0)`, `(0, 2)`, and `(2, 2)`.\n\nNow we need to store the graph. We can have a map `graphRow`, where `graphRow[i]` represent the columns linked to `i`-th row, and a map `graphCol`, where `graphCol[j]` represent the columns linked to `j`-th col.\n\nWait a minute. Can we combine those two maps into a single map? \n\nNote that the indexes of row start from 0 and occupy positive numbers. There are negative numbers that remain unused. We can store indexes of columns in negative numbers.\n\nA natural idea is to use the negative of column index $$-\\text{col}$$. But both row and column indexes use zero, resulting in duplication of number zero. We need to shift one unit to avoid repetition: using $$-\\text{col} - 1$$.\n\nLuckily, we happen to have an operator called \"**complement**\" ($$\\sim$$), where $$\\sim\\text{col} = -\\text{col} - 1$$. What's more, simple math shows $$\\sim(\\sim\\text{col}) = \\text{col}$$.\n\nTherefore, we can use a single graph to store the connections between row and column:\nif `i >= 0`, `graph[i]` represents `i`-th row's neighbors (the complement of indexes of linked columns), and if `i < 0`, `graph[~i]` gives `~i`-th column's adjacent points (the indexes of linked rows).\n\n> It's also OK to use two single maps to represent the connection relationship. People just use this trick to make implementation a bit simpler.\n\nNow, only $$M$$ points (represent rows) and $$N$$ points (represent columns) are in the graph. Since we can not have edges between rows or between columns, the largest number of edges are $$\\mathcal{O}(NM) = 2.5 * 10^5$$. The number is small enough to pass the test.\n\nSo, we successfully achieved finding connected parts by BFS. The remaining part is to fill our rank matrix `answer` by connected parts, in the sorted value order.\n\n<pre>\ninitial answer to all zero\ninitial rowMax and colMax to all zero\nfor connected_part in sorted_connected_parts:\n    rank = -1\n    for point (i, j) in connected_part:\n        rank = (rank, max(rowMax[i], colMax[i]) + 1)\n    for point (i, j) in connected_part:\n        answer[i][j] = rank\n        update rowMax and colMax\n</pre>\n\nBy far, we solve every problem we encounter and cleverly avoid *Time Limit Exceeded* by some optimization. The essence of this algorithm is to separate points into different connected parts, sort them by values, and finally fill in the rank matrix from the lowest value to the highest value.\n\nFor the detail of the algorithm, check the \"Algorithm\" part.\n\n**Algorithm**\n\n> For convenience, \n> - We refer \"points\" to indexes in the matrix, in the form `(row_number, column_number)`.\n> - We refer \"value\" to the values in the matrix. In other words, the value of point `(i, j)` is `matrix[i][j]`.\n> - We say two points are \"connected\" if and only if they have the same values and are in the same row or column, or they are all connected to the same point.\n> - A \"connected part\" represents a group of connected points.\n\n*Step 1:* Initialize graphs for different values. Iterate `matrix` and link the rows and columns in the corresponding graph.\n\n*Step 2:* Initialize a `value2index` map to store connected parts.\n\n- This map will contain the value - index mapping. In the index part, separate points to put the connected points in the same array, and to put non-connected points in different arrays. (one array represents a connected part.)\n- Therefore, `value2index` should be in this form: `{v1: [[point1, point2, ...], [point11, point12, ...], ...], v2: ...}`, where `point1, point2, ...` are connected, and `point11, point21, ...` are also connected, but none of points from different array are connected.\n\n*Step 3:* Fill in `value2index` map by iterating over `matrix` again.\n\n- For each point, use BFS to find out all the other connected points. Put all of them into `value2index`  as an array.\n- Remember to mark those points visited to avoid duplicate additions.\n\n*Step 4:* Sort the keys in `value2index` (i.e., all values in `matrix`).\n\n*Step 5:* Initialize our `answer` matrix. Iterate `value2index` in the order of sorted keys to fill in `answer`.\n\n- For a given key (i.e., a value in `matrix`), we fill in `answer` by connected parts (i.e., one array).\n- Note that for points in the same connected part, they share the same rank.\n- For a connected part, Find out the minimum possible rank and update that rank.\n- To reduce the time for searching the minimum possible rank, we need two arrays to record the maximum rank of each row and each column, respectively.\n\n*Step 6:* Return `answer`.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/Kyv3i4Yf/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Kyv3i4Yf\"></iframe>\n\n**Complexity Analysis**\n\nLet $$M$$ be the number of rows in `matrix` and $$N$$ be the number of columns in `matrix`.\n\n* Time Complexity: $$\\mathcal{O}(NM\\log(NM))$$.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `matrix` to build `graphs`.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `matrix` to build `value2index`. We only visit points at most twice, since we skip points visited in BFS.\n  - We need $$\\mathcal{O}(NM\\log(NM))$$ to sort the keys in `value2index`, since there are at most $$\\mathcal{O}(NM)$$ different keys.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `value2index` to build `answer`.\n  - Adding together, the time we needed is $$\\mathcal{O}(NM\\log(NM))$$.\n\n* Space Complexity: $$\\mathcal{O}(NM)$$.\n  - For `graphs`, we store $$\\mathcal{O}(NM)$$ edges (viewing each point as an edge). \n  - For `value2index`, we store $$\\mathcal{O}(NM)$$ points.\n  - For `rowMax` and `columnMax`, they have size of $$\\mathcal{O}(M)$$ and $$\\mathcal{O}(N)$$, respectively.\n  - In total, the size we needed is $$\\mathcal{O}(NM)$$.\n\n---\n\n#### Approach 2: Sorting + DFS\n\n**Intuition**\n\nDFS is similar to BFS but differs in the order of searching. In most cases, when the search space is not huge, you can replace BFS with DFS.\n\nIn approach 1, we used BFS to find out the connected parts of each point. Now, we use DFS instead.\n\n**Algorithm**\n\n*Step 1:* Initialize graphs for different values. Iterate `matrix` and link the rows and columns in the corresponding graph.\n\n*Step 2:* Initialize a `value2index` map to store connected parts.\n\n- This map will contain the value - index mapping. In the index part, separate points to put the connected points in the same array, and to put non-connected points in different arrays. (one array represents a connected part.)\n- Therefore, `value2index` should be in this form: `{v1: [[point1, point2, ...], [point11, point12, ...], ...], v2: ...}`, where `point1, point2, ...` are connected, and `point11, point21, ...` are also connected, but none of the points from different array are connected.\n\n*Step 3:* Fill in `value2index` map by iterating over the `matrix` again.\n\n- For each point, use **DFS** to find out all the other connected points. Put all of them into `value2index`  as an array.\n- Remember to mark those points visited to avoid duplicate additions.\n\n*Step 4:* Sort the keys in `value2index` (i.e., all values in `matrix`).\n\n*Step 5:* Initialize our `answer` matrix. Iterate `value2index` in the order of sorted keys to fill in `answer`.\n\n- For a given key (i.e., a value in `matrix`), we fill in `answer` by connected parts (i.e., one array).\n- Note that for points in the same connected part, they share the same rank.\n- For a connected part, Find out the minimum possible rank and update that rank.\n- To reduce the time for searching the minimum possible rank, we need two arrays to record the maximum rank of each row and each column, respectively.\n\n*Step 6:* Return `answer`.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/nakpRbKB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"nakpRbKB\"></iframe>\n\n**Complexity Analysis**\n\nLet $$M$$ be the number of rows in `matrix` and $$N$$ be the number of columns in `matrix`.\n\n* Time Complexity: $$\\mathcal{O}(NM\\log(NM))$$.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `matrix` to build `graphs`.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `matrix` to build `value2index`. We only visit points at most twice, since we skip points visited in DFS.\n  - We need $$\\mathcal{O}(NM\\log(NM))$$ to sort the keys in `value2index`, since there are at most $$\\mathcal{O}(NM)$$ different keys.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `value2index` to build `answer`.\n  - Adding together, the time we needed is $$\\mathcal{O}(NM\\log(NM))$$.\n\n* Space Complexity: $$\\mathcal{O}(NM)$$.\n  - For `graphs`, we store $$\\mathcal{O}(NM)$$ edges (viewing each point as an edge). \n  - For `value2index`, we store $$\\mathcal{O}(NM)$$ points.\n  - For `rowMax` and `columnMax`, they have size of $$\\mathcal{O}(M)$$ and $$\\mathcal{O}(N)$$, respectively.\n  - In total, the size we needed is $$\\mathcal{O}(NM)$$.\n\n---\n\n#### Approach 3: Sorting + Union-Find\n\n**Intuition**\n\nAs we mentioned in approach 1, [Union-Find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) (or UF, Disjoint Set) can be applied to find the connected parts.\n\nSince Union-Find is not the essence of this problem (and considering the length of the article), we will not provide a very detailed explanation of Union-Find here. You can find some tutorials on other problems that require Union-Find, such as [Redundant Connection](https://leetcode.com/problems/redundant-connection/) or [Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/).\n\nNow, we will have a quick review of Union-Find, and explain how we can use Union-Find to find the connected parts.\n\nSimilar to approach 1, we view the matrix points as **edges** that connect rows and columns.\n\nAs we know, we can view Union-Find as a forest-like structure (forest represents many trees). For example:\n\n![Figure 8](../Figures/5156/5156_8.png)\n\nTo store this structure, we can store the node's parents in a map or an array. The root's parent is itself. A map is used here for illustration.\n\nThis structure provides two methods, `find` and `union`.\n\n- For function `find`, it returns the root of the given node.\n\n- For function `union`, it accepts two nodes and merges the two trees that the nodes belong to.\n\nFor example, if we want to union node Row2 and node Col1, we will have something like this:\n\n![Figure 9](../Figures/5156/5156_9.png)\n\nWhat `union` needs to do is to assure that `find(Row2)` and `find(Col1)` yield the same value. That's it.\n\nThere are two main optimizations we can do in Union-Find: path compression and union by rank.\n\n- Path compression means that when we apply `find`, we can link the nodes on our search path to the root directly, which will reduce the search time for the next time.\n\n- For union by rank, when we merge two trees, what we do is to link a tree's root to the other tree's leaf. But which tree's root should be linked? We can assign each tree a rank, and link the low-rank tree's root to the high-rank tree's leaf. The rank can be the size of the tree or the number of layers of the tree.\n\nWith path compression and union by rank, if we perform `find` and `union` $$N$$ times, it can be done in almost $$\\mathcal{O}(N)$$.\n\n> In fact, the time complexity is $$\\mathcal{O}(N\\alpha(N))$$, where function $$\\alpha(n)$$ is [inverse Ackermann function](https://en.wikipedia.org/wiki/Ackermann_function#Inverse), which is much smaller than $$\\log(n)$$ and approximately constant. The proof of the complexity is complicated, and interested readers can go to [Wikipedia](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) to check the detail.\n\nNow, back to our problem. We need to find the connected parts.\n\nWe can use the `union` function to union rows and columns together and use `find` to determine which connected parts the given point belongs to.\n\nSimilar to approach 1, we use 0 and positive numbers to mark the row, and the complement numbers to mark the column.\n\n**Algorithm**\n\n*Step 1:* Implement `find` and `union` for Union-Find.\n\n- `find` receives an integer and returns the \"root\" of that integer.\n- `union` accepts two integers and merges them into the same union.\n\n*Step 2:* Initialize Union-Finds (UFs) for different values. Iterate `matrix` and union the rows and columns in the corresponding Union-Find.\n\n*Step 3:* Initialize a `value2index` map to store connected parts.\n\n- This map will contain the value - index mapping. In the index part, separate points to put the connected points in the same array, and to put non-connected points in different arrays. (one array represents a connected part.)\n- We mark those array by the \"root\" of points in Union-Find (so `value2index` is actually a nested map).\n- Therefore, `value2index` should be in this form: `{v1: {root1: [point1, point2, ...], root2: [point11, point12, ...], ...}, v2: ...}`, where `point1, point2, ...` are connected, and `point11, point21, ...` are also connected, but none of points from different set are connected.\n\n*Step 4:* Fill in `value2index` map by iterate `matrix` again.\n\n- For a point, use `find` to calculate its \"root\". Put the point in the corresponding set.\n\n*Step 5:* Sort the keys in `value2index` (i.e., all values in `matrix`).\n\n*Step 6:* Initialize our `answer` matrix. Iterate `value2index` in the order of sorted keys to fill in `answer`.\n\n- For a given key (i.e., a value in `matrix`), we fill in `answer` by connected parts (i.e., one array).\n- Note that for points in the same connected part, they share the same rank.\n- For a connected part, Find out the minimum possible rank and update that rank.\n- To reduce the time for searching the minimum possible rank, we need two arrays to record the maximum rank of each row and each column, respectively.\n\n*Step 7:* Return `answer`.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n> For convenience, we only implement path compression in the code above, and that's enough to pass the test.\n\n<iframe src=\"https://leetcode.com/playground/PtUaKPvy/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"PtUaKPvy\"></iframe>\n\n**Complexity Analysis**\n\nLet $$M$$ be the number of rows in `matrix` and $$N$$ be the number of columns in `matrix`.\n\n* Time Complexity: $$\\mathcal{O}(NM\\log(NM))$$.\n  - We need $$\\mathcal{O}(NM\\log(NM))$$ to iterate `matrix` to build `UFs`. However, with both union by rank and path compression, we can achieve $$\\mathcal{O}(NM\\alpha(NM))$$, where function $$\\alpha(n)$$ is [inverse Ackermann function](https://en.wikipedia.org/wiki/Ackermann_function#Inverse), which is much smaller than $$\\log(n)$$ and approximately constant.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `matrix` to build `value2index`.\n  - We need $$\\mathcal{O}(NM\\log(NM))$$ to sort the keys in `value2index`, since there are at most $$\\mathcal{O}(NM)$$ different keys.\n  - We need $$\\mathcal{O}(NM)$$ to iterate `value2index` to build `answer`.\n  - Adding together, the time we needed is $$\\mathcal{O}(NM\\log(NM))$$.\n\n* Space Complexity: $$\\mathcal{O}(NM)$$.\n  - For `UFs`, we store $$\\mathcal{O}(NM)$$ edges (viewing each point as an edge). \n  - For `value2index`, we store $$\\mathcal{O}(NM)$$ points.\n  - For `rowMax` and `columnMax`, they have size of $$\\mathcal{O}(M)$$ and $$\\mathcal{O}(N)$$, respectively.\n  - In total, the size we needed is $$\\mathcal{O}(NM)$$.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "990",
            "count": 47,
            "average": "4.532",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "rank-transform-of-a-matrix",
    "playgroundData": {
        "Kyv3i4Yf": {
            "playground": {
                "testcaseInput": "",
                "name": "rank-transform-of-a-matrix-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "nakpRbKB": {
            "playground": {
                "testcaseInput": "",
                "name": "rank-transform-of-a-matrix-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "PtUaKPvy": {
            "playground": {
                "testcaseInput": "",
                "name": "rank-transform-of-a-matrix-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}