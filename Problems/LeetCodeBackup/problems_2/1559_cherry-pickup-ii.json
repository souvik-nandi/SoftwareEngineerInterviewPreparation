{
    "id": "1559",
    "question": {
        "questionId": "1559",
        "questionFrontendId": "1463",
        "boundTopicId": null,
        "title": "Cherry Pickup II",
        "titleSlug": "cherry-pickup-ii",
        "content": "<p>You are given a <code>rows x cols</code> matrix <code>grid</code> representing a field of cherries where <code>grid[i][j]</code> represents the number of cherries that you can collect from the <code>(i, j)</code> cell.</p>\n\n<p>You have two robots that can collect cherries for you:</p>\n\n<ul>\n\t<li><strong>Robot #1</strong> is located at the <strong>top-left corner</strong> <code>(0, 0)</code>, and</li>\n\t<li><strong>Robot #2</strong> is located at the <strong>top-right corner</strong> <code>(0, cols - 1)</code>.</li>\n</ul>\n\n<p>Return <em>the maximum number of cherries collection using both robots by following the rules below</em>:</p>\n\n<ul>\n\t<li>From a cell <code>(i, j)</code>, robots can move to cell <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, or <code>(i + 1, j + 1)</code>.</li>\n\t<li>When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.</li>\n\t<li>When both robots stay in the same cell, only one takes the cherries.</li>\n\t<li>Both robots cannot move outside of the grid at any moment.</li>\n\t<li>Both robots should reach the bottom row in <code>grid</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png\" style=\"width: 374px; height: 501px;\" />\n<pre>\n<strong>Input:</strong> grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n<strong>Output:</strong> 24\n<strong>Explanation:</strong> Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png\" style=\"width: 500px; height: 452px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n<strong>Output:</strong> 28\n<strong>Explanation:</strong> Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>rows == grid.length</code></li>\n\t<li><code>cols == grid[i].length</code></li>\n\t<li><code>2 &lt;= rows, cols &lt;= 70</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 2226,
        "dislikes": 22,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n[[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Samsung\", \"slug\": \"samsung\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int cherryPickup(vector<vector<int>>& grid) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int cherryPickup(int[][] grid) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint cherryPickup(int** grid, int gridSize, int* gridColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int CherryPickup(int[][] grid) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar cherryPickup = function(grid) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef cherry_pickup(grid)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func cherryPickup(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func cherryPickup(grid [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def cherryPickup(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun cherryPickup(grid: Array<IntArray>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn cherry_pickup(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function cherryPickup($grid) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function cherryPickup(grid: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (cherry-pickup grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec cherry_pickup(Grid :: [[integer()]]) -> integer().\ncherry_pickup(Grid) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec cherry_pickup(grid :: [[integer]]) :: integer\n  def cherry_pickup(grid) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"64K\", \"totalSubmission\": \"90.8K\", \"totalAcceptedRaw\": 64046, \"totalSubmissionRaw\": 90756, \"acRate\": \"70.6%\"}",
        "hints": [
            "Use dynammic programming, define DP[i][j][k]: The maximum cherries that both robots can take  starting on the ith row, and column j and k of Robot 1 and 2 respectively."
        ],
        "solution": {
            "id": "1019",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[3,1,1],[2,5,1],[1,5,5],[2,1,1]]",
        "metaData": "{\n  \"name\": \"cherryPickup\",\n  \"params\": [\n    {\n      \"name\": \"grid\",\n      \"type\": \"integer[][]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "768",
            "date": "2022-01-08",
            "incompleteChallengeCount": 25,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1019",
        "content": "[TOC]\n\n#### Overview\nYou probably can guess from the problem title that this problem is an extension of the original [Cherry Pickup](https://leetcode.com/problems/cherry-pickup/). \n\nIn this problem, we do not need to return to the starting point but have two robots instead of one. However, the essence of this problem does not change, and the same method is still available.\n\nBelow, we will discuss two similar approaches: *Dynamic Programming (Top Down)* and *Dynamic Programming (Bottom Up)*.\n\nThe first one is also known as dfs with memoization or memoization dp, and the second one is also known as tabulation dp. They have the same main idea but different coding approaches.\n\n---\n#### Approach #1: Dynamic Programming (Top Down)\n\n**Intuition**\n\n>In this part, we will explain how to think of this approach step by step.\n>\n>If you are only interested in the pure algorithm, you can jump to the algorithm part.\n\nWe need to move two robots! Note that the order of moving robot1 or robot2 does not matter since it would not impact the cherries we can pick. The number of cherries we can pick only depends on the tracks of our robots.\n\nTherefore, we can move the robot1 and robot2 in any order we want. We aim to apply DP, so we are looking for an order that suitable for DP.\n\nLet's try a few possible moving orders.\n\nCan we move robot1 firstly to the bottom row, and then move robot2?\n\nMaybe not. In this case, the movement of robot1 will impact the movement of robot2. In other words, the optimal track of robot2 depends on the track of robot1. If we want to apply DP, we need to record the whole track of robot1 as the state. The number of sub-problems is too much.\n\nIn fact, in any case, when we move one robot several steps earlier than the other, the movement of the first robot will impact the movement of the second robot.\n\nUnless we move them **synchronously** (i.e., move one step of robot1 and robot2 at the same time).\n\nLet's define the DP state as `(row1, col1, row2, col2)`, where `(row1, col1)` represents the location of robot1, and `(row2, col2)` represents the location of robot2.\n\nIf we move them synchronously, robot1 and robot2 will always on the same row. Therefore, `row1 == row2`.\n\nLet `row = row1`. The DP state is simplified to `(row, col1, col2)`, where `(row, col1)` represents the location of robot1, and `(row, col2)` represents the location of robot2.\n\nOK, time to define the DP function.\n\n>Since it's a top-down DP approach, we try to solve the problem with the DP function. Check approach 2 for DP array (bottom-up).\n\nLet `dp(row, col1, col2)` return the maximum cherries we can pick if robot1 starts at `(row, col1)` and robot2 starts at `(row, col2)`.\n\n>You can try changing different `dp` meaning to yield some other similar approaches. For example, let `dp(row, col1, col2)` mean the maximum cherries we can pick if robot1 **ends** at `(row, col1)` and robot2 **ends** at `(row, col2)`.\n\nThe base cases are that robot1 and robot2 both start at the bottom line. In this case, they do not need to move. All we need to do is to collect the cherries at current cells. Remember not to double count if robot1 and robot2 are at exactly the same cell.\n\nIn other cases, we need to add the maximum cherries robots can pick in the future. Here comes the transition function.\n\nSince we move robots synchronously, and each robot has three different movements for one step, we totally have $$3*3 = 9$$ possible movements for two robots:\n\n```text\n    ROBOT1 | ROBOT2\n------------------------\n LEFT DOWN |  LEFT DOWN\n LEFT DOWN |       DOWN\n LEFT DOWN | RIGHT DOWN\n      DOWN |  LEFT DOWN\n      DOWN |       DOWN\n      DOWN | RIGHT DOWN\nRIGHT DOWN |  LEFT DOWN\nRIGHT DOWN |       DOWN  \nRIGHT DOWN | RIGHT DOWN  \n```\n\nThe maximum cherries robots can pick in the future would be the max of those 9 movements, which is the maximum of `dp(row+1, new_col1, new_col2)`, where `new_col1` can be `col1`, `col1+1`, or `col1-1`, and `new_col2` can be `col2`, `col2+1`, or `col2-1`.\n\nRemember to use a map or an array to store the results of our `dp` function to prevent redundant calculating.\n\n**Algorithm**\n\nDefine a `dp` function that takes three integers `row`, `col1`, and `col2` as input.\n\n`(row, col1)` represents the location of robot1, and `(row, col2)` represents the location of robot2.\n\nThe `dp` function returns the maximum cherries we can pick if robot1 starts at `(row, col1)` and robot2 starts at `(row, col2)`.\n\nIn the `dp` function:\n\n- Collect the cherry at `(row, col1)` and `(row, col2)`. Do not double count if `col1 == col2`.\n\n- If we do not reach the last row, we need to add the maximum cherries we can pick in the future.\n\n- The maximum cherries we can pick in the future is the maximum of `dp(row+1, new_col1, new_col2)`, where `new_col1` can be `col1`, `col1+1`, or `col1-1`, and `new_col2` can be `col2`, `col2+1`, or `col2-1`.\n\n- Return the total cherries we can pick.\n\nFinally, return `dp(row=0, col1=0, col2=last_column)` in the main function.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/LGhm6CAh/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"LGhm6CAh\"></iframe>\n\n**Complexity Analysis**\n\nLet $$M$$ be the number of rows in `grid` and $$N$$ be the number of columns in `grid`.\n\n* Time Complexity: $$\\mathcal{O}(MN^2)$$, since our `helper` function have three variables as input, which have $$M$$, $$N$$, and $$N$$ possible values respectively. In the worst case, we have to calculate them all once, so that would cost $$\\mathcal{O}(M \\cdot N \\cdot N) = \\mathcal{O}(MN^2)$$. Also, since we save the results after calculating, we would not have repeated calculation.\n\n* Space Complexity: $$\\mathcal{O}(MN^2)$$, since our `helper` function have three variables as input, and they have $$M$$, $$N$$, and $$N$$ possible values respectively. We need a map with size of $$\\mathcal{O}(M \\cdot N \\cdot N) = \\mathcal{O}(MN^2)$$ to store the results.\n\n---\n\n#### Approach #2: Dynamic Programming (Bottom Up)\n\n**Intuition**\n\nSimilarly, we need a three-dimension array `dp[row][col1][col2]` to store calculated results:\n\n`dp[row][col1][col2]` represents the maximum cherries we can pick if robot1 starts at `(row, col1)` and robot2 starts at `(row, col2)`.\n\nRemember, we move robot1 and robot2 synchronously, so they are always on the same row.\n\nThe base cases are that robot1 and robot2 both start at the bottom row. In this case, we only need to calculate the cherry at current cells.\n\nOtherwise, apply the transition equation to get the maximum cherries we can pick in the future.\n\nSince the base case is at the bottom row, we need to iterate from the bottom row to the top row when filling the `dp` array.\n\n>You can use state compression to save the first dimension since we only need `dp[row+1]` when calculating `dp[row]`.\n\n>You can change the meaning of `dp[row][col1][col2]` and some corresponding codes to get some other similar approaches. For example, let `dp[row][col1][col2]` mean the maximum cherries we can pick if robot1 **ends** at `(row, col1)` and robot2 **ends** at `(row, col2)`.\n\n**Algorithm**\n\nDefine a three-dimension `dp` array where each dimension has a size of `m`, `n`, and `n` respectively.\n\n`dp[row][col1][col2]` represents the maximum cherries we can pick if robot1 starts at `(row, col1)` and robot2 starts at `(row, col2)`.\n\nTo compute `dp[row][col1][col2]` (transition equation):\n\n- Collect the cherry at `(row, col1)` and `(row, col2)`. Do not double count if `col1 == col2`.\n\n- If we are not in the last row, we need to add the maximum cherries we can pick in the future.\n\n- The maximum cherries we can pick in the future is the maximum of `dp[row+1][new_col1][new_col2]`, where `new_col1` can be `col1`, `col1+1`, or `col1-1`, and `new_col2` can be `col2`, `col2+1`, or `col2-1`.\n\nFinally, return `dp[0][0][last_column]`.\n\n>State compression can be used to save the first dimension: `dp[col1][col2]`. Just reuse the dp array after iterating one row.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/Hug4fxEw/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Hug4fxEw\"></iframe>\n\n**Complexity Analysis**\n\nLet $$M$$ be the number of rows in `grid` and $$N$$ be the number of columns in `grid`.\n\n* Time Complexity: $$\\mathcal{O}(MN^2)$$, since our dynamic programming has three nested for-loops, which have $$M$$, $$N$$, and $$N$$ iterations respectively. In total, it costs $$\\mathcal{O}(M \\cdot N \\cdot N) = \\mathcal{O}(MN^2)$$.\n\n* Space Complexity: $$\\mathcal{O}(MN^2)$$ if not use state compression, since our `dp` array has $$\\mathcal{O}(M \\cdot N \\cdot N) = \\mathcal{O}(MN^2)$$ elements. $$\\mathcal{O}(N^2)$$ if use state compression, since we can reuse the first dimension, and our `dp` array only has $$\\mathcal{O}(N \\cdot N) = \\mathcal{O}(N^2)$$ elements.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "964",
            "count": 82,
            "average": "4.963",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "cherry-pickup-ii",
    "playgroundData": {
        "LGhm6CAh": {
            "playground": {
                "testcaseInput": "",
                "name": "cherry-pickup-ii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "Hug4fxEw": {
            "playground": {
                "testcaseInput": "",
                "name": "cherry-pickup-ii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}