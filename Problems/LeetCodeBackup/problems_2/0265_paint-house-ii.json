{
    "id": "265",
    "question": {
        "questionId": "265",
        "questionFrontendId": "265",
        "boundTopicId": null,
        "title": "Paint House II",
        "titleSlug": "paint-house-ii",
        "content": "<p>There are a row of <code>n</code> houses, each house can be painted with one of the <code>k</code> colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>\n\n<p>The cost of painting each house with a certain color is represented by an <code>n x k</code> cost matrix costs.</p>\n\n<ul>\n\t<li>For example, <code>costs[0][0]</code> is the cost of painting house <code>0</code> with color <code>0</code>; <code>costs[1][2]</code> is the cost of painting house <code>1</code> with color <code>2</code>, and so on...</li>\n</ul>\n\n<p>Return <em>the minimum cost to paint all houses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [[1,5,3],[2,9,4]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [[1,3],[2,4]]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>costs[i].length == k</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 20</code></li>\n\t<li><code>1 &lt;= costs[i][j] &lt;= 20</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it in <code>O(nk)</code> runtime?</p>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Hard",
        "likes": 1052,
        "dislikes": 33,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Product of Array Except Self\", \"titleSlug\": \"product-of-array-except-self\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Paint House\", \"titleSlug\": \"paint-house\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint Fence\", \"titleSlug\": \"paint-fence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[1,5,3],[2,9,4]]\n[[1,3],[2,4]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Walmart Global Tech\", \"slug\": \"walmart-labs\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minCostII(vector<vector<int>>& costs) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minCostII(int[][] costs) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minCostII(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minCostII(self, costs: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minCostII(int** costs, int costsSize, int* costsColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinCostII(int[][] costs) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} costs\n * @return {number}\n */\nvar minCostII = function(costs) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} costs\n# @return {Integer}\ndef min_cost_ii(costs)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minCostII(_ costs: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minCostII(costs [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minCostII(costs: Array[Array[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minCostII(costs: Array<IntArray>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn min_cost_ii(costs: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $costs\n     * @return Integer\n     */\n    function minCostII($costs) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minCostII(costs: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (min-cost-ii costs)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec min_cost_ii(Costs :: [[integer()]]) -> integer().\nmin_cost_ii(Costs) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec min_cost_ii(costs :: [[integer]]) :: integer\n  def min_cost_ii(costs) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"99.6K\", \"totalSubmission\": \"193K\", \"totalAcceptedRaw\": 99560, \"totalSubmissionRaw\": 193024, \"acRate\": \"51.6%\"}",
        "hints": [],
        "solution": {
            "id": "862",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,5,3],[2,9,4]]",
        "metaData": "{\r\n  \"name\": \"minCostII\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"costs\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "862",
        "content": "[TOC]\n\n## Solution\n\n**Paint House II** is a follow up question of [Paint House](https://leetcode.com/problems/paint-house/). In the original Paint House problem, `k` was always `3`. In this problem, `k` is no longer fixed and instead can be any non-negative integer.\n\nIf you haven't yet attempted the original [Paint House](https://leetcode.com/problems/paint-house/) question and are having trouble with this question, go attempt Paint House first and come back. There is also an in-depth [Paint House Solution Article](https://leetcode.com/articles/paint-house/). This solution article will assume you are already comfortable with the memoization and dynamic programming solutions for Paint House.\n\n---\n\n#### Approach 1: Memoization\n\n**Intuition**\n\nRemembering that we already know how to solve this problem using memoization when `k = 3` (check the [Paint House Solution Article](https://leetcode.com/articles/paint-house/)) if you can't remember how), let's think through some of the other possible values of `k`.\n\nFor this explanation, we'll call a way of painting the houses *valid* if, and only if, there are no adjacent houses painted the same color. We'll call an input *valid* if it is possible to paint the houses in a *valid* way. **The test cases here on Leetcode are all valid inputs**. In an interview however, you'd need to ensure that it is safe to assume that the input is always valid though.\n\nIf `k = 0`, then this means we have no colors. If there are no colors, it's probably reasonable to assume there are no houses either, i.e. `n = 0`. In other words, the input is `[]`. **For this question here on Leetcode, this is a safe assumption**. In an interview though it could be a good idea to ask the interviewer whether or not the input is *guaranteed* to be valid. For example, could you get a test case such as `[[],[],[],[]]`? This would be `k = 0` and `n = 4`. Of course, this case doesn't make much sense, because we are supposed to be painting houses, but can't with no paint. Either you'd be told it could never happen, or that you needed to do something special for it, such as returning `-1`.\n\nIf `k = 1` (all houses have to be the same color), then it's probably safe to assume that `n = 1`. Otherwise, the problem would be impossible to solve without breaking the adjacent color rule. Again, this is a safe assumption here, but do consider asking the interviewer whether or not you could get an invalid input that had `k = 1` and `n > 1`. So, assuming that `k = 1` and `n = 1`, the total cost will be the cost of painting that one house the only color available.\n\nIf `k = 2` (there are two colors), then we know the problem is always solvable, because we can simply paint the houses alternating colors. For example, when `n = 5` and `k = 2`, here are the only 2 valid ways of painting the houses. Anything else would be invalid.\n\n![The only 2 ways of painting 5 houses with 2 colors.](../Figures/265/two_colors.png)\n\nThe answer will be the one that leads to the lowest cost. It'd be easy to check both.\n\nWhen `k = 3`, the problem is equivalent to [Paint House](https://leetcode.com/problems/paint-house/). In the Solution Article for that question, we worked through an example where `n = 4`.\n\n```\n[[17, 2, 17], [8, 4, 10], [6, 3, 19], [4, 8, 12]]\n```\n\nA good way to visualize all of the valid painting permutations is to use a tree. Each root-to-leaf path represents one valid way of painting the houses.\n\n![A tree showing all the valid permutations.](../Figures/256/permutation_tree.png)\n\nThe cheapest cost of painting the houses is, therefore, the root-to-leaf path with the lowest total sum of its nodes. This animation shows the algorithm we used to solve this problem for Paint House.\n\n!?!../Documents/256_brute_force_tree.json:960,540!?!\n\nLuckily, we didn't actually need to create the tree itself\u2014there is a simpler way using recursion.\n\nSay we have a `paint` function that takes 2 parameters: a house number and a color to paint that house. The output is the ***total*** **cost of painting that house and all the ones after it**. For example `paint(1, red)` would be the cost of painting house `1` red, along with the cost of painting the houses after it (taking into account restrictions caused by painting house `1` red).\n\nTherefore the cheapest way of painting all the houses can be expressed as follows, where `0` is the first house.\n\n`min(paint(0, \"red\"), paint(0, \"green\"), paint(0, \"blue\"))`\n\nThe `paint` function has a recursive implementation. `costs` refers to the *input* table.\n\n```text\ndef paint(i, color):\n    ### BASE CASE ###\n    if i is the last house number:\n        return costs[i][color]\n    ### RECURSIVE CASE ###\n    lowest_cost = Infinity\n    for each next_color in [\"red\", \"green\", \"blue\"]:\n       if next_color != color: # No adjacent houses can be same color.\n           this_cost = costs[i][color] + paint(i + 1, next_color) # <- Recursive call\n           lowest_cost = min(lowest_cost, this_cost)\n    return lowest_cost\n```\n\nThe **base case** is where `i` refers to the *last house*. Painting the last house a particular color can be obtained from the `costs` table.\n\nThe **recursive case** is where we also need to consider the houses after `i`. It is obtained by looking up the cost of painting house `i` the given color (in the `costs` table) and then by determining the cost of painting the houses after it. The cost of painting the houses after requires making recursive paint calls to determine the cost of painting house `i + 1` each of the 2 other colors and then finding the minimum of those 2 values.\n\nThis algorithm is inefficient though. There is a lot of repetition in the tree, meaning we're doing the same calculations over and over again. For example, the total cost of painting the *second* house blue will be the same regardless of whether the first house was red or green. For example, both these branches of the tree are identical.\n\n![Repetition in the tree.](../Figures/265/same_branches.png)\n\nThis should also be apparent from the definition of the `paint` function. The parameters are simply a house number and a color. It doesn't require any information about *where* exactly in the tree it is.\n\nTo solve this problem, we add **memoization** to the `paint` function. Recall that memoization is where before returning an answer, the recursive function writes the answer into a dictionary with the input parameters as the key and the answer as the value. Then before doing a calculation, it checks whether or not that particular calculation has already been done. For the example above, the function would only calculate the cost of painting the second house blue *once*, and then the second time it would look it up in the dictionary.\n\nHere is a visualization that shows the calculations that need to be done when using memoization. The brighter circles show where the function body runs, and the duller circles show where a lookup was done and the function immediately returned. These are the only times the function is called.\n\n![A visualization showing what recursive calls the memoization approach actually makes.](../Figures/256/visualisation_memo.png)\n\n**If this explanation wasn't thorough enough for you**, then please check out the full [Paint House Solution Article](https://leetcode.com/articles/paint-house/). In that article I go into a lot more depth about memoization and how this algorithm was derived.\n\nThe `k > 3` case is really no different to this. The only difference is that instead of only considering 2 possible colors for the *next* house, we're considering `k - 1` colors (all colors except for the color of the current house).\n\n**Algorithm**\n\nUnlike the pseudocode above, we don't need to worry about the names of the colors. Instead, they are represented by numbers between `0` and `k - 1`. Additionally, we're also using memoization (`lru_cache` in Python, and a dictionary in Java).\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/UkjtvsGQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"UkjtvsGQ\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n \\cdot k ^ 2)$$.\n\n    Determining the total time complexity of a recursive memoization algorithm requires looking at how many calls are made to the `paint` function, and how much each call costs (remember that the memoization lookups are $$O(1)$$). The function is called once for each possible pair of house number and color. This gives $$n \\cdot k$$ calls. Then, each call has a loop that loops over each of the $$k$$ colors. Therefore, we have $$n \\cdot k \\cdot k = n \\cdot k ^2$$ which is $$O(n \\cdot k ^ 2)$$.\n\n    The part outside of the recursive function is $$O(k)$$ and therefore does not impact the overall complexity.\n\n* Space complexity : $$O(n \\cdot k)$$.\n\n    There are 2 different places memory is being used that we need to consider.\n\n    Firstly, the memoization is storing the answers for each pair of house number and color. There are $$n \\cdot k$$ of these, and so $$O(n \\cdot k)$$ memory used.\n\n    Secondly, we need to consider the memory used on the run-time stack. In the worst case, there's a stack frame for each house number on the stack. This is a total of $$O(n)$$.\n\n    The $$O(n)$$ is insignficant to the $$O(n \\cdot k)$$, so we're left with a total of $$O(n \\cdot k)$$.\n\n<br />\n\n---\n\n#### Approach 2: Dynamic Programming\n\n**Intuition**\n\nLet's look at a bigger example now, and view the problem in a different way to how we did before. For this example, `k = 6` and `n = 5`.\n\n`[[10, 6, 16, 25, 7, 28], [7, 16, 18, 30, 16, 25], [8, 26, 6, 22, 26, 19], [10, 23, 14, 17, 23, 9], [12, 14, 27, 7, 8, 9]]`\n\nAnd here is a diagram of the input grid.\n\n![A picture of the input grid.](../Figures/265/large_input.png)\n\nEach row represents the different colors a house could be. *Remember that the colors are represented by numbers*. The actual colors are only to make the table easier to read.\n\nThe problem we're trying to solve is equivalent to the following: **pick exactly one number from each row** such that the **sum of those numbers is minimized**. Because 2 adjacent houses cannot be the same color, **adjacent rows must be picked from different columns**. This is a straightforward variant of one of those \"classic\" minimum-path-in-a-grid dynamic programming problems.\n\nThe way that we solve it is to iterate over the cells and determine what the cheapest way of getting to that cell is. We'll work from top to bottom.\n\nTo begin with, we say the first row (house 0) is already completed. We don't need to make any changes to it.\n\nThen, for each cell in the second row, we work out the cheapest way of getting to it from the first row is. For example, to get to `[1][red]` we have to go through any of the non-red cells from the row above. We want to go through the minimum.\n\n![Choosing the best path to house 1, red.](../Figures/265/dynamic_programming_1.png)\n\nWe show our decision by updating `[1][red]`  to `7 + 6 = 13`.\n\nWe can repeat this for the rest of the second row, and then work down each of the remaining rows.\n\nHere's an animation of the algorithm being carried out.\n\nWhen we're finished, the final answer is the **minimum value in the last row**.\n\n**Algorithm**\n\nWe'll do this in the same way we did in the animation above\u2014an in-place algorithm that over-writes the input grid.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/b4J2BxyQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"b4J2BxyQ\"></iframe>\n\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n \\cdot k ^ 2)$$.\n\n    We iterate over each of the $$n \\cdot k$$ cells. For each of the cells, we're finding the minimum of the $$k$$ values in the row above, excluding the one that is in the same column. This operation is $$O(k)$$. Multiplying this out, we get $$O(n \\cdot k ^ 2)$$.\n\n* Space complexity : $$O(1)$$ if done in-place, $$O(n \\cdot k)$$ if input is copied.\n\n    We're not creating any new data structures in the code above, and so it has a space complexity of $$O(1)$$. This is, however, overwriting the given input, which might not be ideal in some situations.\n\n    If we don't want to overwrite the input, we could instead create a copy of it first and then do the calculations in the copy. This will require an additional $$O(n \\cdot k)$$ space.\n\n<br />\n\n---\n\n#### Approach 3: Dynamic Programming with O(k) additional Space.\n\n**Intuition**\n\nImplementing the algorithm in-place meant that we only needed $$O(1)$$ additional space. This, however required modifying the input, which could be a problem in some situations.\n\nThe easiest solution is to make a copy of the input array and then do the calculations in that instead. This would require $$O(n \\cdot k)$$ additional space.\n\nThere is a way that uses less space though. We're only ever working with 2 rows at a time: the current row, and the row before it. The rows before that are never looked at again, and the rows after are still the same as the input array. Therefore, we can take advantage of this to only use $$O(k)$$ space.\n\n**Algorithm**\n\nInstead of writing the updated costs into the input array, the algorithm writes them into a k-length array. The k-length array from the previous row is held onto in-order to do these calculations.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/aoF5nVA8/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"aoF5nVA8\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n \\cdot k ^ 2)$$.\n\n    Same as above.\n\n* Space complexity : $$O(k)$$.\n\n    The previous row and the current row are represented as k-length arrays.\n\n    This approach does *not* modify the input grid.\n\n<br />\n\n---\n\n#### Approach 4: Dynamic programming with Optimized Time\n\n**Intuition**\n\nDespite Paint House II being listed as a hard question, and the problem statement listing $$O(n \\cdot k)$$ time as a \"follow up\", you'd possibly be expected to come up with this solution at top companies as it's still a fairly basic dynamic programming algorithm. You should, therefore, ensure you're comfortable with this approach and could identify and apply similar observations in other dynamic programming problems. At the very least, it'll make you look awesome!\n\nSo far, all of our approaches have had a $$O(n \\cdot k^2)$$ time complexity. This is because calculating the new value for each of the $$O(n \\cdot k)$$ cells required looking at each of the $$k$$ cells in the row immediately below.\n\nHowever, we don't need to look at the entire previous row for every cell. Let's look again at the large example from above. When we're calculating the values for the second row, we're adding the minimum from the first row onto them. The only cell we can't do this for is the one that was *directly below the minimum*, as this would break the adjacency rule. For this one, it makes sense to add the second minimum.\n\n![We're only ever adding 2 different numbers.](../Figures/265/dynamic_programming_2.png)\n\nHere's an animation of the entire algorithm.\n\n!?!../Documents/265_dp_min_finding.json:960,540!?!\n\n**Algorithm**\n\nThe simplest way of implementing this algorithm is to base it on the animation above. This requires overwriting the input.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/DpMTLirQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"DpMTLirQ\"></iframe>\n\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n \\cdot k)$$.\n\n    The first loop that finds the minimums of the first row is $$O(k)$$ because it looks at each of the $$k$$ values in the first row exactly once. The second loop is $$O(n \\cdot k)$$ because the outer loop loops $$n$$ times, and the inner loop loops $$k$$ times. $$O(n \\cdot k) + O(k) = O(n \\cdot k)$$. We know it is *impossible* to ever do better here, because we cannot solve the problem without at least looking at each of the $$n \\cdot k$$ cells once.\n\n* Space complexity : $$O(1)$$.\n\n    Like approach 2, this approach also modifies the input instead of allocating its own space.\n\n<br />\n\n---\n\n#### Approach 5: Dynamic programming with Optimized Time and Space\n\n**Intuition**\n\nThere is another way we can still solve the problem in $$O(1)$$ space and $$O(n \\cdot k)$$ time complexity, *and* preserving the input.\n\nThe only thing the algorithm in the previous approach is really doing is going through the rows, and finding the 2 minimums of each row. It does this by calculating all the new costs for the row, writing them into the input, and then finding the minimums. This overwriting isn't necessary though\u2014we can simply keep track of the 2 smallest values we've seen so far, as we go, in the current row. We also need to remember the 2 from the previous row.\n\n**Algorithm**\n\nThe approach is a hybrid of approach 3 and 4. Like approach 4, it finds the minimums once instead of repeatedly. Like approach 3, it keeps track of information only from the current and previous rows. Unlike approach 3 though, the only information kept is the minimums.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/CTrSisdw/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"CTrSisdw\"></iframe>\n\nThere are many ways to compact the code a bit more, particularly in the case of the Python. I haven't done this here as it could be problematic for those less familiar with the 2 languages I have provided solutions in, however feel free to post your own solutions in the comments. I'm excited to see the elegance you can come up with!\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n \\cdot k)$$.\n\n    Same as the previous approach.\n\n* Space complexity : $$O(1)$$.\n\n    The only additional working memory we're using is a constant number of single-value variables to keep track of the 2 minimums in the current and previous row, and to calculate the cost of the current cell. Because the memory usage is constant, we say it is $$O(1)$$. Unlike the previous approach one though, this one does not overwrite the input.\n\n<br />",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "820",
            "count": 74,
            "average": "4.878",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "paint-house-ii",
    "playgroundData": {
        "UkjtvsGQ": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-house-ii-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "b4J2BxyQ": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-house-ii-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "aoF5nVA8": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-house-ii-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "DpMTLirQ": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-house-ii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "CTrSisdw": {
            "playground": {
                "testcaseInput": "",
                "name": "paint-house-ii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}