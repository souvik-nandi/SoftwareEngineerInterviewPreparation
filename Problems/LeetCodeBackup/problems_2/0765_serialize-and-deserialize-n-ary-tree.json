{
    "id": "765",
    "question": {
        "questionId": "765",
        "questionFrontendId": "428",
        "boundTopicId": null,
        "title": "Serialize and Deserialize N-ary Tree",
        "titleSlug": "serialize-and-deserialize-n-ary-tree",
        "content": "<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n<p>Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n<p>For example, you may serialize the following <code>3-ary</code> tree</p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 500px; max-width: 300px; height: 321px;\" />\n<p>&nbsp;</p>\n\n<p>as <code>[1 [3[5 6] 2 4]]</code>. Note that this is just an example, you do not necessarily need to follow this format.</p>\n\n<p>Or you can follow LeetCode&#39;s level order traversal serialization format, where each group of children is separated by the null value.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 500px; height: 454px;\" />\n<p>&nbsp;</p>\n\n<p>For example, the above tree may be serialized as <code>[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</code>.</p>\n\n<p>You do not necessarily need to follow the above-suggested formats, there are many more different formats that work so please be creative and come up with different approaches yourself.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [1,null,3,2,4,null,5,6]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Hard",
        "likes": 877,
        "dislikes": 50,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Serialize and Deserialize Binary Tree\", \"titleSlug\": \"serialize-and-deserialize-binary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Serialize and Deserialize BST\", \"titleSlug\": \"serialize-and-deserialize-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Encode N-ary Tree to Binary Tree\", \"titleSlug\": \"encode-n-ary-tree-to-binary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n[1,null,3,2,4,null,5,6]\n[]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Tree",
                "slug": "tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Zillow\", \"slug\": \"zillow\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Zoom\", \"slug\": \"zoom\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"DoorDash\", \"slug\": \"doordash\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n    string serialize(Node* root) {\n        \n    }\n\t\n    // Decodes your encoded data to tree.\n    Node* deserialize(string data) {\n        \n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.deserialize(codec.serialize(root));",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Codec {\n    // Encodes a tree to a single string.\n    public String serialize(Node root) {\n        \n    }\n\t\n    // Decodes your encoded data to tree.\n    public Node deserialize(String data) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: Node\n        :rtype: str\n        \"\"\"\n\t\t\n    \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: Node\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.deserialize(codec.serialize(root))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Codec:\n    def serialize(self, root: 'Node') -> str:\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: Node\n        :rtype: str\n        \"\"\"\n        \n\t\n    def deserialize(self, data: str) -> 'Node':\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: Node\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.deserialize(codec.serialize(root))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, IList<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n*/\n\npublic class Codec {\n    // Encodes a tree to a single string.\n    public string serialize(Node root) {\n        \n    }\n\t\n    // Decodes your encoded data to tree.\n    public Node deserialize(string data) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\nclass Codec {\n  \tconstructor() {\n        \n    }\n    \n    /** \n     * @param {Node|null} root\n     * @return {string}\n     */\n    // Encodes a tree to a single string.\n    serialize = function(root) {\n        \n    };\n\t\n    /** \n     * @param {string} data \n     * @return {Node|null}\n     */\n    // Decodes your encoded data to tree.\n    deserialize = function(data) {\n        \n    };\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :children\n#     def initialize(val=0, children=[])\n#         @val = val\n#         @children = children\n#     end\n# end\n\nclass Codec\n    # Encodes a tree to a single string.\n    # @param {Node} root\n\t# @return {String}\n    def serialize(root)\n    \t\n    end\n    \n    # Decodes your encoded data to tree.\n    # @param {String} data\n\t# @return {Node}\n    def deserialize(data)\n        \n    end\nend\n\n# Your Codec object will be instantiated and called as such:\n# obj = Codec.new()\n# data = obj.seralize(root)\n# ans = obj.desrialize(data)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "/**\n * Definition for a Node.\n * public class Node {\n *     public var val: Int\n *     public var children: [Node]\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.children = []\n *     }\n * }\n */\n\nclass Codec {\n    func serialize(_ root: Node?) -> String {\n    \t\n    }\n    \n    func deserialize(_ data: String) -> Node? {\n    \t\n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * let obj = Codec()\n * let ret_1: TreeNode? = obj.serialize(root)\n * let ret_2: Node? = obj.decode(data)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\n\ntype Codec struct {\n    \n}\n\nfunc Constructor() *Codec {\n    \n}\n\nfunc (this *Codec) serialize(root *Node) string {\n    \n}\n\nfunc (this *Codec) deserialize(data string) *Node {\n    \n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * obj := Constructor();\n * data := obj.serialize(root);\n * ans := obj.deserialize(data);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var children: List[Node] = List()\n * }\n */\n\nclass Codec {\n    // Encodes a tree to a single string.\n    def serialize(root: Node): String = {\n        \n    }\n    \n    // Decodes your encoded data to tree.\n    def deserialize(data: String): Node = {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = new Codec()\n * var data = obj.serialize(root)\n * var ans = obj.deserialize(data)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "/**\n * Definition for a Node.\n * class Node(var `val`: Int) {\n *     var children: List<Node?> = listOf()\n * }\n */\n\nclass Codec {\n    // Encodes a tree to a single string.\n    fun serialize(root: Node?): String {\n        \n    }\n    \n    // Decodes your encoded data to tree.\n    fun deserialize(data: String): Node? {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = Codec()\n * var data = obj.serialize(root)\n * var ans = obj.deserialize(data)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $children = null;\n *     function __construct($val = 0) {\n *         $this->val = $val;\n *         $this->children = array();\n *     }\n * }\n */\n\nclass Codec {\n    /**\n     * Encodes a tree to a single string.\n     * @param Node $root\n     * @return String\n     */\n    function serialize($root) {\n\t\t\n    }\n  \t\n    /**\n     * Decodes your encoded data to tree.\n     * @param String $data\n     * @return Node\n     */\n    function deserialize($data) {\n    \t\n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $obj = Codec();\n * $ret_1 = $obj->serialize($root);\n * $ret_2 = $obj->deserialize($data);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "/**\n * Definition for node.\n * class Node {\n *     val: number\n *     children: Node[]\n *     constructor(val?: number) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.children = []\n *     }\n * }\n */\n\nclass Codec {\n  \tconstructor() {\n        \n    }\n    \n    // Encodes a tree to a single string.\n    serialize(root: Node | null): string {\n        \n    };\n\t\n    // Decodes your encoded data to tree.\n    deserialize(data: string): Node | null {\n        \n    };\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"68.5K\", \"totalSubmission\": \"105.8K\", \"totalAcceptedRaw\": 68520, \"totalSubmissionRaw\": 105820, \"acRate\": \"64.8%\"}",
        "hints": [],
        "solution": {
            "id": "854",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
        "metaData": "{\n  \"name\": \"CodecDriver\",\n  \"params\": [\n    {\n      \"name\": \"root\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  },\n  \"languages\": [\n    \"cpp\",\n    \"java\",\n    \"python\",\n    \"csharp\",\n    \"javascript\",\n    \"python3\",\n    \"golang\",\n    \"kotlin\",\n    \"ruby\",\n    \"scala\",\n    \"php\",\n    \"swift\",\n    \"typescript\"\n  ],\n  \"manual\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "854",
        "content": "[TOC]\n\n## Solution\n\n**Template**\n\nThis is one of the most interesting problems on the leetcode platform simply because there are a lot of different ways of solving this problem. There is no `incorrect` approach here. Some approaches are much easier to code-up and are more efficient as opposed to others. However, the variations for serialization and deserialization are endless. The following article is a collection of my own approaches for solving this problem and the solutions, learnings I got from some amazing posts in the discussion section. \n\nBefore we get on with the solutions themselves, we need to look at a basic template that shall be followed throughout this article. After all, the serialization method produces a string as an output and the deserialization method takes that string as input and reconstructs the tree. So, the general code template that we will be following is as follows:\n\n<iframe src=\"https://leetcode.com/playground/xAgd5CFN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"xAgd5CFN\"></iframe>\n\nThere are some important things in this template which need to be addressed before moving on with the algorithms and their implementations. \n\n**Wrappable Int**\n\nFirst of all, we need to look at the nested class `WrappableInt`. If you read the problem constrains carefully, you'll see that we are asked to make our functions stateless. \n\n> Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\n\nSome implementations out there actually split the input string and convert it into a queue. That seems rather unnecessary for this problem and is more time consuming. Instead, we can simply use an index to iterate over the data in the input string during deserialization and that would be much faster. So, the nested class is simply to provide us with an iterator during our recursive calls. Note that if your approach doesn't involve any kind of recursion, then we don't need any such custom object because we can simply iterate over the input string one character at a time in a `for` loop.  \n\nThis custom class is used in the deserialization method. We need to process one character at a time and in case we are following a recursive approach, we need a variable that preserves the updates across function calls. As we all know, primitives are pass by value and in no circumstance will they maintain their values. So, we create a custom class which is a thin wrapper around an integer. Basically, for objects, the function calls are pass by value, but the object itself is not copied. Instead, a new reference of the object is created and passed around in function calls. As long as we don't assign this new reference to some other object, we should be good and the changes made within recursive calls shall be preserved. Again, there may be more elegant ways of achieving what is being done here, but this is an implementation detail and this is how I decided to implement the solutions. \n\n**String Builder**\n\nThere are many ways of producing the serialized string from the data given to us. Not in terms of the algorithmic approach we take. But in terms of the way we choose to implement the same. Sure, we can go about the normal, easiest of operations which is string concatenation\n\n<pre>\nserializedStr += data;\n</pre>\n\nIf you don't already know, then it's time to read more on this topic. Even though, the `+` method for string concatenation is one of the fastest out there (performance wise!), it does consume a shit ton of memory especially if there are a lot of such concatenations. This is mostly because parts of the resulting string are copied multiple times. Indeed, on every `+` operator, String class allocates a new block in memory and copies everything it has into it; plus a suffix being concatenated.\n\nHence, to save up on precious memory, we will be avoiding this approach. The next interesting approach is to use a dynamic list of strings (it's actually characters but we'll get to that in a bit) and finally, use string join method to stitch all the data together. Even though, these days, a `+` operation and a `join` operation are both super optimized by the Java compiler internally, still, we may not have similar optimizations in other languages. \n\nIn any case, building a list of strings and then joining them would consume much less memory than the string concatenation using the `+` operator. The final method, which is only applicable for Java is by using a `StringBuilder`. It is said that if we have an array of strings *already built*, then a `join` operation may be faster than a StringBuilder. However, for our implementation, we can use the StringBuilder on the fly and that turns out giving us the best performance according to leetcode stats. Unfortunately, we be using the `join` method in Python since we don't have an equivalent of `StringBuilder` there.\n\n**You mentioned a list of characters? How so?**\n\nYeah, so this is a trick I learned in one of the fastest of Java solutions. Unfortunately, I don't have a profile to tag it with for credit here. The data provided to us in the nodes of the tree are integers. Sure, we can represent each integer as a string of digits. However, if we do that, then we would need some sort of a delimiter to separate the numbers themselves. After all `1234` could be `12` and `34` or it could be `1` and `234`. Without a delimiter to separate them, the deserializer won't know. \n\nIf we do add a delimiter, it would add to the length of the overall string, which is fine. However, in the deserializer then, we would have to use the `split` operation and form a list of strings (more like a queue since that is how we will process them) and that is a relatively costly operation in terms of time and not to mention the extra space that the list would use. \n\n> Instead, we can use this neat trick which is to represent each number as a unicode character.\n\nOf course there are limitations to this approach:\n\n* Won't work on negative numbers\n* Won't work if the numbers are > 65536\n\nSo, it's not really something that we can rely on 100% for correctness. It just so happens that for the test cases in this problem, this trick works perfectly fine and it is something to remember for solving other programming problems as well.\n\nEssentially, we can represent each number as a unicode character. In Java, an integer is essentially the same as a unicode character and all we need is an explicit typecast and we'll be good to go. In Python we have a special function called `unichr()` which does this job. Starting Python 3.6, the more commonly known function `chr()` does the task. And for converting the character back to an integer, we can use `ord()` in Python and a simple implicit typecast does the trick in Java. This implementation has many advantages as you can think of:\n\n* We don't need to use any special delimiters just for separating numbers. \n* We don't need costly split operations and instead, we can iterate on the input string one character at a time and form our tree.\n* It's blazingly fast! On one of the solutions, I saw the run time come down to `2ms` down from a whooping `10ms` in Java. That's a 5X jump and definitely worthy of note. \n\nNow that we have the basics out of the way, let's finally get on with our algorithms themselves for serializing and deserializing an n-ary tree. It goes without saying that there may be a lot of different approaches out of there which are surely not explored in this article and if you feel you have a great new take on this problem, do let us know in the comments section and we'd love to enhance the article! That being said, let's get on.\n\n#### Approach 1: Parent Child relationships\n\n**Intuition**\n\nThe intuition for this approach is pretty straightforward. The serialized string would contain the parent child information for each of the nodes in the tree and we will use that to reconstruct the tree. Given a serialized string we will construct a hash map with a node being the key and the value being it's parent. Since we will have all the parent child relationships, we can just keep creating nodes as required and update the children array. Let's see how the serialized string would look like for a given tree and the corresponding hash map that would be created using the serialized string.\n\n<center>\n<img src=\"../Figures/428/img1.png\" width=\"600\"/>\n</center>\n\nAs mentioned in the image, with this simple serialization, we will run into problems since there can be nodes with duplicate data and we can't rely on just the values for deserialization. We need a way of differentiating different nodes. For that, we will be using a unique identifier for each node. Again, the `WrappableInt` data structure will come in handy here in the implementation. Let's see what the serialized string looks like with these unique Ids.\n\n<center>\n<img src=\"../Figures/428/img2.png\" width=\"600\"/>\n</center>\n\nNote that the Ids assigned in the above example make sense if we do a level order traversal in the code. If we do a depth first traversal, then the order of processing the nodes would change and so would the Ids and the final serialized string. Note that even though we can process the serialized string in any order and recreate the original tree, we have to stick to the inherent ordering defined in the string itself. \n\n> The important thing is that we need to maintain not only the correct children's list but also the correct ordering of the children. So, for the above example, the children's list for the root node cannot be [5, 3, 3, 7]. It has to be [3, 5, 3, 7].\n\nNow let's look at the hash map as formed using the serialized string containing the unique Ids.\n\n<center>\n<img src=\"../Figures/428/img3.png\" width=\"600\"/>\n</center>\n\n**Algorithm**\n\n`Serialization`\n\n1. We'll do a simple depth first traversal of the tree starting from the root node and the StringBuilder (list in case of Python).\n2. The helper function would take one `WrappableInt` as an input in addition to the node itself. The custom integer would represent the unique Id of the current node. As for the parent node, we pass a simple `Integer` object since we don't want retention for parentIds across recursion.\n3. For every node, we will add 3 values to the serialized string. The first would be the unique Id of the current node. Next we add the actual value of the node and finally, we add the unique Id of the parent node. \n4. Remember to use the unicode character trick discussed in the introduction section of this article. We will be using it heavily to keep down the overall length of the serialized string. \n5. For the root node, we will be using a special dummy value `N`. We can use a negative value as well since the test cases don't have any negative value. However, for achieving as much generalization as possible, let's use a dummy character.\n\n`Deserialization`\n\n1. For deserialization, we are given the string as an input. We will always be processing the input in triplets since 3 characters represent the information for one node. \n2. We will initialize a HashMap that will contain the data from the string. It's the hash map from the figures before. \n3. For every triplet in the input string (a, b, c), we will create a new entry in the hash map with `a` being the key and a pair of `b, c` being the value. Remember, `a` represents the unique Id for the node, `b` represents its actual value and `c` represents the Id of the parent node. Also, in addition to the 2 values `b, c`, we will also be adding new `TreeNode` or `Node` data structures to the dictionary. This is because we will be re-using this dictionary to fill up the children lists for each node. So the actual entry in the hash map would be\n\n    <pre>a -> (b, c, Node(a, []))</pre>\n    \n4. Once we are done constructing the dictionary, we have to construct the original tree. We have already constructed all the nodes of the tree. All that remains is establishing the right connections in the `right order`. Remember when we mentioned about the ordering of the children nodes, we have to ensure we don't mess that up here.\n5. We can't process nodes in any random order. So, we use the original string itself and use every third entry as the node to process. \n\n<iframe src=\"https://leetcode.com/playground/LyitpNVb/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"LyitpNVb\"></iframe>\n\n**Complexity Analysis**\n\n*Time Complexity*\n \n- `Serialization`: $$O(N)$$ where $$N$$ are the number of nodes in the tree. For every node, we add 3 different values to the final string and every node is processed exactly once.\n- `Deserialization`: Well technically, it is $$3N$$ for the first for loop and $$N$$ for the second one. However, constants are ignored in asymptotic complexity analysis. So, the overall time complexity for deserialization is $$O(N)$$. \n\n*Space Complexity*\n \n- `Serialization`: The space occupied by the serialization helper function is through recursion stack and the final string that is produced. Usually, we don't take into consideration the space of the output. However, in this case, the output is something which is not fixed. For all we know, someone might be able to generate a string of size N/2. We don't know! So, the size of the final string is a part of the space complexity here. Overall, the space is $$4N$$ = $$O(N)$$.\n- `Deserialization`: The space occupied by the deserialization helper function is through the hash map. For each entry, we have 3 values. Thus, we can say the space is $$3N$$. But again, the constants don't really matter in asymptotic complexity. So, the overall space is $$O(N)$$.\n\nNote that for this particular problem, the `asymptotic` time and space will remain the same across all the approaches. The only thing that will change are the constants and that does impact the runtime in a major way. So, we will be focusing on the constants rather than the final complexity in all these approaches.\n\n#### Approach 2: Depth First Search with Children Sizes!\n\n**Intuition**\n\nThat previous approach works well, however, the problem is that we end up generating a serialized string which is three times the size of the tree. The reason for that is, we need unique identities for every node since we have no way of differentiating them just on the basis of values. So in this approach we will be incorporating two things into the serialized string per node - it's value, and the number of children it has. Let's quickly look at what that looks like on a sample tree.\n\n<center>\n<img src=\"../Figures/428/img4.png\" width=\"550\"/>\n</center>\n\nThe next part is, how do we use this information and rebuild the correct tree during deserialization. In this approach, the deserialization simply tries to `run` the same recursion that we did during serialization. Except, now instead of tree nodes, we simply have information from the input string. Let's look at the pseudocode of how this approach would work.\n\n<pre>\nfunc deserialize(data, index)\n{\n    if (index == data.length)\n    {\n        return null\n    }\n    \n    node = Construct new node using value at data[index]\n    for i in range 0...data[index+1] \n    {\n        node.add(deserialize(data, index+2))\n    }\n}\n</pre>\n\nIn addition to this pseudocode, let's also look at a figure explaining this on the serialized string from above. It goes without saying that the `index` above is actually a `WrappableInt` since we need to to maintain where it has reached in the input string exactly, across recursions.\n\n<center>\n<img src=\"../Figures/428/img5.png\"/>\n</center>\n\n**Algorithm**\n\n`Serialization`\n\n1. Like before, we will initialize a `StringBuilder` (or a list in Python). We don't need our custom integer wrapper here since we don't need any unique identities. \n2. We will be doing a depth first traversal on the input tree.\n3. For every node, we will add it's value and also the number of children it has, to the string.\n4. Again, we will be using the unicode character trick as explained in the introduction of the article. That will come in handy as we try to bound the size of the output string by some constant factor of the number of nodes in the tree.\n\n`Deserialization`\n\n1. The deserialization is simple as well. We simply need to rebuild the tree using the same recursion as we used in the serialization function. \n2. We will need our `WrappableInt` index here since we need to keep track of what characters have already been processed in the string.\n3. For a given index, `i`, we will create a new Node using `data[i]` as the value where `data` represents the input string. \n4. Next, we will have a loop equal to the number of children this node has. That is given by `data[i+1]`. Remember, for every node in the tree, we added two pieces of information in the string. One is its original value and the other is the number of children it has.\n5. Within this loop, we will make further recursive calls, one for each child of the current node. The deserialization helper function will return a node which will be the root of a fully constructed tree.\n\n<iframe src=\"https://leetcode.com/playground/Qae8c3JM/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Qae8c3JM\"></iframe>\n\n**Complexity Analysis**\n\n*Time Complexity*\n\n- `Serialization`: $$O(N)$$ where $$N$$ are the number of nodes in the tree. For every node, we add 2 different values to the final string and every node is processed exactly once.\n- `Deserialization`: For deserialization, we process the entire string, one character at a time and also construct the tree along the way. So, the overall time complexity for deserialization is $$2N$$ = $$O(N)$$\n\n*Space Complexity*\n\n- `Serialization`: The space occupied by the serialization helper function is through recursion stack and the final string that is produced. We know the size of the final string to be $$2N$$. So, that is one part of the space complexity. The other part is the one occupied by the recursion stack which is $$O(N)$$. Overall, the space is $$O(N)$$. \n- `Deserialization`: For deserialization, the space occupied is by the recursion stack only. We don't use any other intermediate data structures like we did in the previous approach and simply rely on the information in the string and recursion to work it's magic. So, the space complexity would be $$O(N)$$ since this is not a `balanced` tree of any sort. It's not even binary.\n\nThis is one of the simplest algorithms for solving this problem. The serialization and deserialization have a very similar format and the overall space and time complexity are also very low. Also, what's nice is that it's easy to code up quickly in an interview!\n\n#### Approach 3: Depth First Search with a Sentinel\n\n**Intuition**\n\nThis approach is very similar to the previous approach. The only difference is that instead of adding the number of children a node has, to the serialized string, we add a sentinel value when all the children have been added to the final string. Let's look at the serialized string for the sample tree we've been looking at throughout the article.\n\n<center>\n<img src=\"../Figures/428/img6.png\" width=\"700\"/>\n</center>\n\nThe next part is, how do we use this information and rebuild the correct tree during deserialization. In this approach, the deserialization simply tries to `run` the same recursion that we did during serialization. Except that now, instead of tree nodes, we simply have information from the input string. Let's look at the pseudocode of how this approach would work.\n\n<pre>\nfunc deserialize(data, index)\n{\n    if (index == data.length)\n    {\n        return null\n    }\n    \n    node = Construct new node using value at data[index]\n    while data[index] != '#' \n    {\n        node.add(deserialize(data, index+1))\n    }\n    \n    index++\n}\n</pre>\n\n\nHere we need to move along the input string in accordance with the recursion from serialization before. Also, once we encounter the corresponding sentinel, we discard it. Just like during serialization we added a sentinel value `after` all the child nodes had been processed, similarly, we will encounter and discard the sentinel once all the child subtrees have been built completely. This is ensured by the recursion we write.\n\n<iframe src=\"https://leetcode.com/playground/yz95J2uQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"yz95J2uQ\"></iframe>\n\n**Complexity Analysis**\n\n*Time Complexity*\n\n- `Serialization`: $$O(N)$$ where $$N$$ are the number of nodes in the tree. For every node, we add 2 different values to the final string and every node is processed exactly once.\n- `Deserialization`: For deserialization, we process the entire string, one character at a time and also construct the tree along the way. So, the overall time complexity for deserialization is $$2N$$ = $$O(N)$$\n\n*Space Complexity*\n\n- `Serialization`: The space occupied by the serialization helper function is through recursion stack and the final string that is produced. We know the size of the final string to be $$2N$$. So, that is one part of the space complexity. The other part is the one occupied by the recursion stack which is $$O(N)$$. Overall, the space is $$O(N)$$. \n- `Deserialization`: For deserialization, the space occupied is by the recursion stack only. We don't use any other intermediate data structures like we did in the previous approach and simply rely on the information in the string and recursion to work it's magic. So, the overall space complexity would be $$O(N)$$.\n\n#### Approach 4: Level order traversal\n\n**Intuition**\n\nThis approach is based on the suggestion given by the problem statement itself. It's very similar to the strategy used by leetcode for serializing and deserializing a tree structure in problem statements. Essentially, we use level order traversal for serializing the tree and when deserializing, we construct one level at a time. The two main pieces of information that have to be infused somehow in the serialized string are:\n\n- Which node has what children since a level can contain a lot nodes and we need to know the parent of each one of them.\n- Second, and the more common information is the switch from one level to another. We need to add this information somehow in the string which helps the deserializer know that a level has finished and a new one has begun. \n\nFor the first piece, we will be using a sentinel value of $$ $ $$ and whenever we start adding children of a different node, we add this sentinel value to the string and then start adding the children. For the next piece of information, we add another sentinel $$ \\# $$ to the string. Before we switch to the next level of the tree during serialization, we add this sentinel value to the string so that the deserializer knows that one level has ended and a new one has started. Let's look at what the serialized string looks like for the sample tree. \n\n<center>\n<img src=\"../Figures/428/img7.png\"/>\n</center>\n\nWe can get rid of the extra, unwanted string in the end. However, instead of doing another iteration and performing a substring operation or using some other tricky logic to not add that to the final string, we decided to handle it in the deserializer itself. Sure, if we can get rid of that extra portion, the string length would reduce.\n\n**Algorithm**\n\n`Serialization`\n\n1. Since this is a level-order traversal, we will be making use of a queue here for traversing the tree one level at a time. \n2. For Java, since our queue is composed of nodes, we cannot add the sentinel characters as is to the queue. So we create two dummy nodes and call them `childNode` and `endNode`. By using object comparison we know if a node is a sentinel node or a normal tree node. \n3. We perform a normal level order traversal. The only change is that we add the `childNode` to the queue whenever we are done adding the children of a particular node to the queue. \n4. Also, when a particular level ends, we add an `endNode` to the queue. \n5. *Only when we pop a sentinel node from the queue do we add the corresponding characters to the final serialized string*.\n6. As for the nodes in the tree, we use the unicode character trick we've been following all along.\n\n`Deserialization`\n\n1. For deserialization, we will go one level at a time for reconstructing the tree. \n2. For this purpose, we maintain two lists `currentLevel` and `prevLevel`. The `prevLevel` contains the nodes from the previous level while we add the nodes on the current level to the corresponding list. Once we have these two lists figured out, we establish the corresponding connections. \n3. The sentinel values come in handy since whenever we encounter a $$ $ $$, the child switch sentinel, we pop a new parent node from `prevLevel` and any children encountered from this point to the next  $$ $ $$ belong to this parent node. \n4. Similarly, whenever we encounter the level end sentinel $$ \\# $$, we assign `prevLevel` to `currentLevel` since the nodes in the current level now become parents for the next level. \n\n<iframe src=\"https://leetcode.com/playground/rEhvSKDw/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"rEhvSKDw\"></iframe>\n\n**Complexity Analysis**\n\n*Time Complexity*\n\n- `Serialization`: $$O(N)$$ where $$N$$ are the number of nodes in the tree. For every node, we add 2 different values to the final string and every node is processed exactly once. We add the value of the node itself and we also add the child switch sentinel. Also, for the nodes that end a particular level, we add the level end sentinel.\n- `Deserialization`: For deserialization, we process the entire string, one character at a time and also construct the tree along the way. So, the overall time complexity for deserialization is $$2N$$ = $$O(N)$$\n\n*Space Complexity*\n\n- `Serialization`: The space occupied by the serialization helper function is through the queue and the final string that is produced. We know the size of the final string to be $$2N$$. So that is one part of the space complexity. The other part is the one occupied by the queue which is $$O(N)$$. Overall, the space is $$O(N)$$. \n- `Deserialization`: For deserialization, the space is mostly occupied by the two lists that we use. The space complexity there is $$O(N)$$. Note that when we re-initialize a list, the memory that was allocated earlier is deallocated by the garbage collector and it's essentially equal to a single list of size $$O(N)$$.\n<br>\n<br>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "812",
            "count": 68,
            "average": "4.485",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "serialize-and-deserialize-n-ary-tree",
    "playgroundData": {
        "xAgd5CFN": {
            "playground": {
                "testcaseInput": "",
                "name": "serialize-and-deserialize-n-ary-tree-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "LyitpNVb": {
            "playground": {
                "testcaseInput": "",
                "name": "serialize-and-deserialize-n-ary-tree-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "Qae8c3JM": {
            "playground": {
                "testcaseInput": "",
                "name": "serialize-and-deserialize-n-ary-tree-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "yz95J2uQ": {
            "playground": {
                "testcaseInput": "",
                "name": "serialize-and-deserialize-n-ary-tree-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "rEhvSKDw": {
            "playground": {
                "testcaseInput": "",
                "name": "serialize-and-deserialize-n-ary-tree-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}