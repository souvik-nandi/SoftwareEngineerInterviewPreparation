{
    "id": "2438",
    "question": {
        "questionId": "2438",
        "questionFrontendId": "2359",
        "boundTopicId": null,
        "title": "Find Closest Node to Given Two Nodes",
        "titleSlug": "find-closest-node-to-given-two-nodes",
        "content": "<p>You are given a <strong>directed</strong> graph of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, where each node has <strong>at most one</strong> outgoing edge.</p>\n\n<p>The graph is represented with a given <strong>0-indexed</strong> array <code>edges</code> of size <code>n</code>, indicating that there is a directed edge from node <code>i</code> to node <code>edges[i]</code>. If there is no outgoing edge from <code>i</code>, then <code>edges[i] == -1</code>.</p>\n\n<p>You are also given two integers <code>node1</code> and <code>node2</code>.</p>\n\n<p>Return <em>the <strong>index</strong> of the node that can be reached from both </em><code>node1</code><em> and </em><code>node2</code><em>, such that the <strong>maximum</strong> between the distance from </em><code>node1</code><em> to that node, and from </em><code>node2</code><em> to that node is <strong>minimized</strong></em>. If there are multiple answers, return the node with the <strong>smallest</strong> index, and if no possible answer exists, return <code>-1</code>.</p>\n\n<p>Note that <code>edges</code> may contain cycles.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png\" style=\"width: 321px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> edges = [2,2,3,-1], node1 = 0, node2 = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png\" style=\"width: 195px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> edges = [1,2,-1], node1 = 0, node2 = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n\t<li><code>0 &lt;= node1, node2 &lt; n</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 1639,
        "dislikes": 390,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[2,2,3,-1]\n0\n1\n[1,2,-1]\n0\n2",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Graph",
                "slug": "graph",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": null,
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def closestMeetingNode(self, edges, node1, node2):\n        \"\"\"\n        :type edges: List[int]\n        :type node1: int\n        :type node2: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "int closestMeetingNode(int* edges, int edgesSize, int node1, int node2) {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int ClosestMeetingNode(int[] edges, int node1, int node2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} edges\n * @param {number} node1\n * @param {number} node2\n * @return {number}\n */\nvar closestMeetingNode = function(edges, node1, node2) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function closestMeetingNode(edges: number[], node1: number, node2: number): number {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $edges\n     * @param Integer $node1\n     * @param Integer $node2\n     * @return Integer\n     */\n    function closestMeetingNode($edges, $node1, $node2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func closestMeetingNode(_ edges: [Int], _ node1: Int, _ node2: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Dart",
                "langSlug": "dart",
                "code": "class Solution {\n  int closestMeetingNode(List<int> edges, int node1, int node2) {\n    \n  }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func closestMeetingNode(edges []int, node1 int, node2 int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} edges\n# @param {Integer} node1\n# @param {Integer} node2\n# @return {Integer}\ndef closest_meeting_node(edges, node1, node2)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def closestMeetingNode(edges: Array[Int], node1: Int, node2: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn closest_meeting_node(edges: Vec<i32>, node1: i32, node2: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (closest-meeting-node edges node1 node2)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec closest_meeting_node(Edges :: [integer()], Node1 :: integer(), Node2 :: integer()) -> integer().\nclosest_meeting_node(Edges, Node1, Node2) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec closest_meeting_node(edges :: [integer], node1 :: integer, node2 :: integer) :: integer\n  def closest_meeting_node(edges, node1, node2) do\n    \n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"74.2K\", \"totalSubmission\": \"162.8K\", \"totalAcceptedRaw\": 74191, \"totalSubmissionRaw\": 162804, \"acRate\": \"45.6%\"}",
        "hints": [
            "How can you find the shortest distance from one node to all nodes in the graph?",
            "Use BFS to find the shortest distance from both node1 and node2 to all nodes in the graph. Then iterate over all nodes, and find the node with the minimum max distance."
        ],
        "solution": {
            "id": "1623",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[2,2,3,-1]\n0\n1",
        "metaData": "{\n  \"name\": \"closestMeetingNode\",\n  \"params\": [\n    {\n      \"name\": \"edges\",\n      \"type\": \"integer[]\"\n    },\n    {\n      \"type\": \"integer\",\n      \"name\": \"node1\"\n    },\n    {\n      \"type\": \"integer\",\n      \"name\": \"node2\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 17 </code> using the latest C++ 20 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code>OpenJDK 21</code>. Using compile arguments: <code>--enable-preview --release 21</code></p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 11</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12\\\" target=\\\"_blank\\\">C# 12</a> with .NET 8 runtime</p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 20.10.0</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use 5.4.0 version of <a href=\\\"https://github.com/datastructures-js/priority-queue/blob/v5/README.md\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and 4.2.3 version of <a href=\\\"https://github.com/datastructures-js/queue/tree/v4.2.3\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.2</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.9</code>.</p>\\r\\n\\r\\n<p>You may use <a href=\\\"https://github.com/apple/swift-algorithms/tree/1.2.0\\\" target=\\\"_blank\\\">swift-algorithms 1.2.0</a> and <a href=\\\"https://github.com/apple/swift-collections/tree/1.0.6\\\" target=\\\"_blank\\\">swift-collections 1.0.6</a>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.21</code></p>\\r\\n<p>Support <a href=\\\"https://github.com/emirpasic/gods/tree/v1.18.1\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods@v1.18.1</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.11</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.9.0</code>.</p>\\r\\n\\r\\n<p>We are using an experimental compiler provided by JetBrains.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.74.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.2</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 5.1.6, Node.js 20.10.0</code>.</p>\\r\\n\\r\\n<p>Compile Options: <code>--alwaysStrict --strictBindCallApply --strictFunctionTypes --target ES2022</code></p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2022 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p><a href=\\\"https://docs.racket-lang.org/guide/performance.html#%28tech._c%29\\\" target=\\\"_blank\\\">Racket CS</a> v8.11</p>\\r\\n\\r\\n<p>Using <code>#lang racket</code></p>\\r\\n\\r\\n<p>Required <code>data/gvector data/queue data/order data/heap</code> automatically for your convenience</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 26\"], \"elixir\": [\"Elixir\", \"Elixir 1.15 with Erlang/OTP 26\"], \"dart\": [\"Dart\", \"<p>Dart 3.2</p>\\r\\n\\r\\n<p>Your code will be run directly without compiling</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1623",
        "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe problem presents a directed unweighted graph with `n` nodes. Each node can have at most one outgoing edge. Our task is to find the closest node from two given nodes, `node1` and `node2` so that the maximum between the distances from `node1` and `node2` to that node is minimized over all the nodes. If there are multiple answers, we need to return the node with the smallest index, and if no possible answer exists, we need to return `-1`.\n\n---\n\n### Approach 1: Breadth First Search\n\n#### Intuition\n\nWe can see intuitively that if we have the distances from `node1` and `node2` to all the nodes, then we can iterate over all the nodes and choose a node that has the smallest maximum value between the distances from `node1` to that node and from  `node2` to that node.\n\nA breadth-first search (BFS) is a good algorithm to use if we want to find the shortest path in an unweighted graph. The path used in BFS traversal always has the least number of edges. The BFS algorithm does a level-wise iteration of the graph. As a result, it first finds all paths that are one edge away from the source node, followed by all paths that are two edges away from the source node, and so on. This allows BFS to find the shortest path in terms of steps from the source node to any other node. It is implemented with a queue.\n\nHere is an example with steps:\n\n![img](../Figures/2359/2359-bfs.png)\n\nIn this approach, we begin BFS traversals for both `node1` and `node2` to compute the shortest distances from `node1` and `node2` to all other nodes. We store the results in arrays labeled `dist1` and `dist2`, respectively. We also set two variables: `minDistNode = -1`, which is the answer to our problem, and `minDistTillNow`, which is the maximum between the distances from `node1` to `minDistNode` and from `node2` to `minDistNode`.\n\nNow, we iterate over all of the nodes from `0` to `n - 1`. For each node, say `currNode` we check if the maximum distance from `node1` and `node2` is smaller than the other nodes previously seen. If `minDistTillNow > max(dist1[currNode], dist2[currNode])`, we have a node `currNode` with a smaller maximum value between the distances from `node1` to `currNode` and from `node2` to `currNode`. In this case, we update the `minDistTillNow` to `minDistTillNow = max(dist1[currNode], dist2[currNode])` and update the `minDistNode` to `minDistNode = currNode`.\n\nOtherwise, if `minDistTillNow <= max(dist1[currNode], dist2[currNode])` we do not do anything. We return `minDistNode` at the end of all the iterations over every node. We would never update the variable `currNode` if we couldn't reach any node that is reachable from `node1` and `node2`. In that case, we'd return the `currNode` variable with its original value of `-1`.\n\n#### Algorithm\n\n1. Initialize two arrays, `dist1` and `dist2` storing the shortest distances from `node1` and `node2` to all the nodes. Initialize them with large values.\n2. Start a BFS traversal.\n    - We use a function `bfs` to perform the traversal. It requires `startNode, edges, dist` as the parameters, where `dist` is the array that stores the shortest distances from `startNode` to all the nodes.\n    - Start with `node1, edges, dist1`.\n    - Initialize a queue with `startNode` in the queue.\n3. Initialize an array `visit`, storing a boolean for each node to indicate if a node is visited. Initialize it with `false` for all the nodes.\n4. Then, while the queue is not empty:\n    - Dequeue the first `node` from the queue. If it has not been visited, mark it as visited. Otherwise, if it has been visited, repeat step 4.\n    - Check if `node` has an outgoing edge. If there is no outgoing edge, we don't do anything.\n    - If the `node` has an outgoing edge to another node called `neighbor`, and `neighbor` has not yet been visited, update the `dist[neighbor]` to `dist[neighbor] = 1 + dist[node]` and push the `neighbor` into the queue.\n5. Perform another BFS traversal with `node2, edges, dist2` to get the shortest distances from `node2` to every other node in `dist2`.\n6. Initialize two variables: `minDistNode = -1`, which is the answer to our problem, and `minDistTillNow`, which is the maximum between the distances from `node1` to `minDistNode` and from `node2` to `minDistNode`.\n7. Run a loop over all the nodes and check each node called `currNode`.\n    - If `minDistTillNow > max(dist1[currNode], dist2[currNode])`, update `minDistTillNow` to `minDistTillNow = max(dist1[currNode], dist2[currNode])` and update `minDistNode` to `minDistNode = currNode`.\n    - Otherwise, we do not update anything.\n8. Return `minDistNode`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/8dxTbBWd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"8dxTbBWd\"></iframe>\n\n#### Complexity Analysis\n\nHere, $n$ is the number of nodes.\n\n* Time complexity: $O(N)$\n\n    - The complexity would be similar to the standard BFS algorithm since we are performing the BFS traversal twice.\n    - For the BFS algorithm, each node is only queued once, which takes $O(1)$ time for each node. We also iterate over the edge of every node once (since we only visit each node once, we won't iterate over a node's edge multiple times), which adds $O(n)$ time since we have at most $n$ edges.\n    - We also require $O(n)$ time to initialize each `dist1`, the `dist2` and the `visit` arrays.\n    - We also require $O(n)$ time to run a loop over all the nodes in the end to compute the answer.\n\n* Space complexity: $O(n)$\n\n    - Because each node only has one outgoing edge, the queue size will never exceed `1`. As such, we don't actually need the queue, but we've used it here to show the template code implementation for BFS.\n    - However, we still require $O(n)$ space each for the `dist1`, the `dist2` and the `visit` arrays.\n\n---\n\n### Approach 2: Depth First Search\n\n#### Intuition\n\nAn interesting property of the graph mentioned in the problem is that each node can have at most one outgoing edge. We can see intuitively that if every node has at most one outgoing edge, there can only be one path from a node to any other node. This is because we only have one way to proceed from one node to another node by using the outgoing edge, if one exists. If there is no outgoing edge or the node has a self-loop (an edge that connects a node to itself), we cannot move ahead. So, if we are able to move, we can only move in one direction. Due to this property, we would be able to use the depth-first search (DFS) algorithm to find the shortest path from a node to all the other nodes in this scenario.\n\nIn DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring. Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.\n\nHere is an example with steps:\n\n![img](../Figures/2359/2359-dfs.png)\n\nWe can only have one branch as per our problem. So, DFS works for our use case to find the shortest distance from a node to all other nodes.\n\nNote that, we cannot use DFS in a standard unweighted graph to find the shortest distance from a node to any other node. For example, let's take a graph with three edges: `1 -> 2`, `1 -> 3` and `2 -> 3`. Let's say we start with node `1` and mark its distance as `0`. We move forward, visit node `2` and mark its distance as `1`. As mentioned in DFS, we explore nodes as far as possible along the branch, so from node `2` we will go to node `3`. We will mark its distance as `2`, which is incorrect. We can visit node `3` via `1 -> 3` with a distance of `1`. \n\nIf you are new to Depth First Search, please see our [Leetcode Explore Card](https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/) for more information on it!\n\nIn this approach, we begin DFS traversals for both `node1` and `node2` to compute the shortest distances from `node1` and `node2` to all other nodes. We will store the results in arrays labelled `dist1` and `dist2`, respectively.\n\nThen, we will iterate over all the nodes and find a node `minDistNode` with the smallest maximum value between the distances from `node1` to `minDistNode` and `node2` to `minDistNode` similar to the BFS approach.\n\n#### Algorithm\n\n1. Initialize two arrays, `dist1` and `dist2` storing the shortest distances from `node1` and `node2` to all the nodes. Initialize them with large values. Set `dist1[node1] = 0` and `dist2[node2] = 0`.\n2. Initialize two boolean arrays, `visit1` and `visit2` to indicate if a node is visited or not in a DFS traversal, starting from `node1` and `node2` respectively. Initialize them with false.\n3. Start a DFS traversal.\n    - We use a function `dfs` to perform the traversal. For each call, pass the `node, edges, dist, visit` as the parameters.\n    - Start with `node1, edges, dist, visit1` to get the shortest distances from `node1` to every node in `dist1`.\n    - Mark `node` as visited.\n    - If the `node` has an outgoing edge to another node called `neighbor`, and `neighbor` has not yet been visited, update the `dist[neighbor]` to `dist[neighbor] = 1 + dist[node]`. We also recursively call the dfs with `neighbor, dges, dist, visit`.\n4. Perform another DFS traversal with `node2, edges, dist2, visit2` to get the shortest distances from `node2` to every node. The distances will be stored in `dist2`.\n6. Initialize two variables: `minDistNode = -1`, which is the answer to our problem, and `minDistTillNow`, which is the maximum between the distances from `node1` to `minDistNode` and from `node2` to `minDistNode`.\n7. Run a loop over all the nodes and check each node called `currNode`.\n    - If `minDistTillNow > max(dist1[currNode], dist2[currNode])`, update `minDistTillNow` to `minDistTillNow = max(dist1[currNode], dist2[currNode])` and update `minDistNode` to `minDistNode = currNode`.\n    - Otherwise, we do not update anything.\n8. Return `minDistNode`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/kQKyWEuV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"kQKyWEuV\"></iframe>\n\n#### Complexity Analysis\n\nHere, $n$ is the number of nodes.\n\n* Time complexity: $O(n)$\n\n    - The complexity would be similar to the standard DFS algorithm since we\u2019re performing the DFS traversal twice.\n    - Each node is visited by the `dfs` function once, which takes $O(n)$ time in total. We also iterate over the edge of every node once (since we only visit each node once, we won't iterate over a node's edge multiple times), which adds $O(n)$ time since we have at most $n$ edges.\n    - We also require $O(n)$ time to initialize each `dist1`, the `dist2` and the `visit` arrays.\n    - We also require $O(n)$ time to run a loop over all the nodes in the end to compute the answer.\n\n* Space complexity: $O(n)$\n\n    - The recursion call stack used by `dfs` can have no more than $n$ elements in the worst-case scenario. It would take up $O(n)$ space in that case.\n    - We also require $O(n)$ space each for the `dist1`, the `dist2` and the `visit` arrays.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1625",
            "count": 41,
            "average": "4.317",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "find-closest-node-to-given-two-nodes",
    "playgroundData": {
        "8dxTbBWd": {
            "playground": {
                "testcaseInput": "",
                "name": "find-closest-node-to-given-two-nodes-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "kQKyWEuV": {
            "playground": {
                "testcaseInput": "",
                "name": "find-closest-node-to-given-two-nodes-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}