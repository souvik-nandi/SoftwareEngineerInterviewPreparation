{
    "id": "1745",
    "question": {
        "questionId": "1745",
        "questionFrontendId": "1602",
        "boundTopicId": null,
        "title": "Find Nearest Right Node in Binary Tree",
        "titleSlug": "find-nearest-right-node-in-binary-tree",
        "content": "<p>Given the <code>root</code> of a binary tree and a node <code>u</code> in the tree, return <em>the <strong>nearest</strong> node on the <strong>same level</strong> that is to the <strong>right</strong> of</em> <code>u</code><em>, or return</em> <code>null</code> <em>if </em><code>u</code> <em>is the rightmost node in its level</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/24/p3.png\" style=\"width: 241px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,4,5,6], u = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The nearest node on the same level to the right of node 4 is node 5.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/23/p2.png\" style=\"width: 101px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> root = [3,null,4,2], u = 2\n<strong>Output:</strong> null\n<strong>Explanation:</strong> There are no nodes to the right of 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>All values in the tree are <strong>distinct</strong>.</li>\n\t<li><code>u</code> is a node in the binary tree rooted at <code>root</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 270,
        "dislikes": 9,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[1,2,3,null,4,5,6]\n4\n[3,null,4,2]\n2",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Tree",
                "slug": "binary-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode findNearestRightNode(TreeNode root, TreeNode u) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findNearestRightNode(self, root, u):\n        \"\"\"\n        :type root: TreeNode\n        :type u: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findNearestRightNode(self, root: TreeNode, u: TreeNode) -> Optional[TreeNode]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* findNearestRightNode(struct TreeNode* root, struct TreeNode* u){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode FindNearestRightNode(TreeNode root, TreeNode u) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} u\n * @return {TreeNode}\n */\nvar findNearestRightNode = function(root, u) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {TreeNode} u\n# @return {TreeNode}\ndef find_nearest_right_node(root, u)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func findNearestRightNode(_ root: TreeNode?, _ u: TreeNode?) -> TreeNode? {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findNearestRightNode(root *TreeNode, u *TreeNode) *TreeNode {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def findNearestRightNode(root: TreeNode, u: TreeNode): TreeNode = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun findNearestRightNode(root: TreeNode?, u: TreeNode?): TreeNode? {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param TreeNode $u\n     * @return TreeNode\n     */\n    function findNearestRightNode($root, $u) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} u\n * @return {TreeNode}\n */\nfunction findNearestRightNode(root: TreeNode, u: TreeNode): TreeNode | null {\n    \n};",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"19K\", \"totalSubmission\": \"25.3K\", \"totalAcceptedRaw\": 19034, \"totalSubmissionRaw\": 25280, \"acRate\": \"75.3%\"}",
        "hints": [
            "Use BFS, traverse the tree level by level and always push the left node first",
            "When you reach the target node, mark  a boolean variable true",
            "If you meet another node in the same level after marking the boolean true, return this node.",
            "If you did not meet new nodes in the same level and started traversing a new level, return Null"
        ],
        "solution": {
            "id": "1024",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": true,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,2,3,null,4,5,6]\n4",
        "metaData": "{\n  \"name\": \"findNeartestRightNode\",\n  \"params\": [\n    {\n      \"name\": \"root\",\n      \"type\": \"TreeNode\"\n    },\n    {\n      \"type\": \"TreeNode\",\n      \"name\": \"u\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"TreeNode\"\n  },\n  \"languages\": [\n    \"cpp\",\n    \"java\",\n    \"python\",\n    \"c\",\n    \"csharp\",\n    \"javascript\",\n    \"ruby\",\n    \"swift\",\n    \"golang\",\n    \"python3\",\n    \"scala\",\n    \"kotlin\",\n    \"php\",\n    \"typescript\"\n  ],\n  \"manual\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "795",
            "date": "2022-01-22",
            "incompleteChallengeCount": 25,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1024",
        "content": "[TOC]\n\n## Video Solution\n\n---\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/493564000?texttrack=en\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n#### Overview\n\n**DFS vs. BFS**\n\nThere are two ways to traverse the tree: DFS _depth first search_ and\nBFS _breadth first search_. Here is a small summary\n\n![diff](../Figures/1602/traversals.png)\n\nBFS traverses level by level, and DFS first goes to the leaves.\n\n![diff](../Figures/1602/dfs_bfs2.png)\n\n> Which approach to choose, BFS or DFS?\n\n- The problem is to return the nearest node on the same level that is to the right of `u`,\nso it's the way more natural to implement BFS here.\n\n- Time complexity is the same $$\\mathcal{O}(N)$$\nboth for DFS and BFS since one has to visit all nodes.\n\n- Space complexity is $$\\mathcal{O}(H)$$ for DFS and\n$$\\mathcal{O}(D)$$ for BFS, where $$H$$ is a tree height,\nand $$D$$ is a tree diameter. They both result in\n$$\\mathcal{O}(N)$$ space in the worst-case scenarios:\nskewed tree for DFS and complete tree for BFS.\n\nLet's use the opportunity\nto check out three different BFS implementations with the queue,\nApproach 1 - Approach 3.\n\nIf you prefer to use DFS on the interviews - check the Approach 4.\n\n**BFS implementation**\n\nAll three implementations use the queue in a standard BFS way:\n\n- Push the root into the queue.\n\n- Pop-out a node from the _left_.\n\n- Push the _left_ child into the queue, and then push the _right_ child.\n\n![diff](../Figures/1602/implem2.png)\n\n**Three BFS approaches**\n\nThe difference is how to identify the end of the level:\n\n- Two queues, one for the previous level and one for the current.\n\n- One queue with sentinel to mark the end of the level.\n\n- One queue + level size measurement.\n\n<br />\n<br />\n\n\n---\n#### Approach 1: BFS: Two Queues\n\nLet's use two queues: one for the current level,\nand one for the next. The idea is to pop the nodes one by one from\nthe current level and push their children into the next level queue.\n\n![diff](../Figures/1602/levels.png)\n\n**Algorithm**\n\n- Initiate two queues: one for the current level,\nand one for the next. Add root into `nextLevel` queue.\n\n- While `nextLevel` queue is not empty:\n\n    - Initiate the current level: `currLevel = nextLevel`,\n    and empty the next level `nextLevel`.\n\n    - While current level queue is not empty:\n\n        - Pop out a node from the current level queue.\n\n        - If this node is `u`, return the next node from the queue.\n        If there is no more nodes in `nextLevel` queue, return `null`.\n\n        - Add first _left_ and then _right_ child node into `nextLevel`\n        queue.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/NvbEC3Az/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"NvbEC3Az\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(N)$$ since one has to visit each node.\n\n* Space complexity: $$\\mathcal{O}(D)$$ to keep the queues,\nwhere $$D$$ is a tree diameter.\nLet's use the last level to estimate the queue size.\nThis level could contain up to $$N/2$$ tree nodes in the case of\n[complete binary tree](https://leetcode.com/problems/count-complete-tree-nodes/).\n<br />\n<br />\n\n\n---\n#### Approach 2: BFS: One Queue + Sentinel\n\nAnother approach is to push all the nodes in one queue and\nto use a [sentinel node](https://en.wikipedia.org/wiki/Sentinel_node)\nto separate the levels. Typically, one could use `null` as\na sentinel.\n\n![diff](../Figures/1602/sentinel.png)\n\nThe first step is to initiate the first level: `root` + `null` as\na sentinel. Once it's done, continue to pop the nodes one by one from the left and push their children to the right.\nStop each time the current node is `null` because it means we hit the end of the current level.\nEach stop is a time to push `null` in the queue to mark the end of the next level.\n\n**Algorithm**\n\n- Initiate the queue by adding a root. Add `null` sentinel\nto mark the end of the first level.\n\n- Initiate the current node as `root`.\n\n- While queue is not empty:\n\n    - Pop the current node from the queue `curr = queue.poll()`.\n\n    - If this node is `u`, return the next node from the queue.\n    If there is no more nodes in the queue, return `null`.\n\n    - If the current node is not `null`:\n\n        - Add first _left_ and then _right_ child node into the\n        queue.\n\n        - Update the current node: `curr = queue.poll()`.\n\n    - Now, the current node is null, _i.e._ we reached the end of the current level.\n    If the queue is not empty, push the null node as a sentinel,\n    to mark the end of the next level.\n\n**Implementation**\n\nNote that `ArrayDeque` in Java doesn't support null\nelements, and hence the data structure to use here\nis `LinkedList`.\n\n<iframe src=\"https://leetcode.com/playground/GuJCc7w2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"GuJCc7w2\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(N)$$ since one has to visit each node.\n\n* Space complexity: $$\\mathcal{O}(D)$$ to keep the queues,\nwhere $$D$$ is a tree diameter.\nLet's use the last level to estimate the queue size.\nThis level could contain up to $$N/2$$ tree nodes in the case of\n[complete binary tree](https://leetcode.com/problems/count-complete-tree-nodes/).\n<br />\n<br />\n\n\n---\n#### Approach 3: BFS: One Queue + Level Size Measurements\n\nInstead of using the sentinel, we could write down the length\nof the current level.\n\n![diff](../Figures/1602/length.png)\n\n**Algorithm**\n\n- Initiate the queue by adding a root.\n\n- While the queue is not empty:\n\n    - Write down the length of the current level:\n    `levelLength = queue.size()`.\n\n    - Iterate over `i` from `0` to `level_length - 1`:\n\n        - Pop the current node from the queue:\n        `node = queue.poll()`.\n\n        - If this node is `u`, return the next node from the queue.\n        Check that the next node is on the same level:\n        `i != levelLength - 1`, otherwise return `null`.\n\n        - Add first _left_ and then _right_ child node\n        into the queue.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/oHRxCQbZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"oHRxCQbZ\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(N)$$ since one has to visit each node.\n\n* Space complexity: $$\\mathcal{O}(D)$$ to keep the queues,\nwhere $$D$$ is a tree diameter.\nLet's use the last level to estimate the queue size.\nThis level could contain up to $$N/2$$ tree nodes in the case of\n[complete binary tree](https://leetcode.com/problems/count-complete-tree-nodes/).\n<br />\n<br />\n\n\n___\n#### Approach 4: Recursive DFS: Preorder Traversal\n\nEveryone likes recursive DFS because of its simplicity, so let's add it here as well.\nThe idea is straightforward: to perform standard preorder traversal of the tree,\nstarting each time from the leftmost child.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/6ZWiYBY7/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"6ZWiYBY7\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(N)$$ since one has to visit each node.\n\n* Space complexity: $$\\mathcal{O}(H)$$ to keep the recursion stack,\nwhere $$H$$ is the tree height.\nThe worst-case situation is a skewed tree when $$H = N$$.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": true,
        "paidOnlyVideo": true,
        "rating": {
            "id": "969",
            "count": 27,
            "average": "4.741",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "find-nearest-right-node-in-binary-tree",
    "playgroundData": {
        "NvbEC3Az": {
            "playground": {
                "testcaseInput": "",
                "name": "find-nearest-right-node-in-binary-tree-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "GuJCc7w2": {
            "playground": {
                "testcaseInput": "",
                "name": "find-nearest-right-node-in-binary-tree-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "oHRxCQbZ": {
            "playground": {
                "testcaseInput": "",
                "name": "find-nearest-right-node-in-binary-tree-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "6ZWiYBY7": {
            "playground": {
                "testcaseInput": "",
                "name": "find-nearest-right-node-in-binary-tree-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}