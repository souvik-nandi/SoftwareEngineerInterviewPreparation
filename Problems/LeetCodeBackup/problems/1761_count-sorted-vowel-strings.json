{
    "id": "1761",
    "question": {
        "questionId": "1761",
        "questionFrontendId": "1641",
        "boundTopicId": null,
        "title": "Count Sorted Vowel Strings",
        "titleSlug": "count-sorted-vowel-strings",
        "content": "<p>Given an integer <code>n</code>, return <em>the number of strings of length </em><code>n</code><em> that consist only of vowels (</em><code>a</code><em>, </em><code>e</code><em>, </em><code>i</code><em>, </em><code>o</code><em>, </em><code>u</code><em>) and are <strong>lexicographically sorted</strong>.</em></p>\n\n<p>A string <code>s</code> is <strong>lexicographically sorted</strong> if for all valid <code>i</code>, <code>s[i]</code> is the same as or comes before <code>s[i+1]</code> in the alphabet.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The 5 sorted strings that consist of vowels only are <code>[&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;].</code>\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> The 15 sorted strings that consist of vowels only are\n[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;].\nNote that &quot;ea&quot; is not a valid string since &#39;e&#39; comes after &#39;a&#39; in the alphabet.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 33\n<strong>Output:</strong> 66045\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code>&nbsp;</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 2938,
        "dislikes": 63,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "1\n2\n33",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Nira Finance\", \"slug\": \"nira-finance\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int countVowelStrings(int n) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int countVowelStrings(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def countVowelStrings(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def countVowelStrings(self, n: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint countVowelStrings(int n){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int CountVowelStrings(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar countVowelStrings = function(n) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef count_vowel_strings(n)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func countVowelStrings(_ n: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func countVowelStrings(n int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def countVowelStrings(n: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun countVowelStrings(n: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn count_vowel_strings(n: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function countVowelStrings($n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function countVowelStrings(n: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (count-vowel-strings n)\n  (-> exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec count_vowel_strings(N :: integer()) -> integer().\ncount_vowel_strings(N) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec count_vowel_strings(n :: integer) :: integer\n  def count_vowel_strings(n) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"136.5K\", \"totalSubmission\": \"176K\", \"totalAcceptedRaw\": 136515, \"totalSubmissionRaw\": 176007, \"acRate\": \"77.6%\"}",
        "hints": [
            "For each character, its possible values will depend on the value of its previous character, because it needs to be not smaller than it.",
            "Think backtracking. Build a recursive function count(n, last_character) that counts the number of valid strings of length n and whose first characters are not less than last_character.",
            "In this recursive function, iterate on the possible characters for the first character, which will be all the vowels not less than last_character, and for each possible value c, increase the answer by count(n-1, c)."
        ],
        "solution": {
            "id": "1041",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "1",
        "metaData": "{\n  \"name\": \"countVowelStrings\",\n  \"params\": [\n    {\n      \"name\": \"n\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "910",
            "date": "2022-05-11",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1041",
        "content": "[TOC]\n\n## Solution\n---\n\n#### Overview ####\n\nThe problem is to build all the string combinations of given length $$n$$ using 5 vowels(`a, e ,i ,o ,u`) in sorted order. If you have solved the common backtracking problems before like [Combination Sum](https://leetcode.com/problems/combination-sum/) or [Combinations](https://leetcode.com/problems/combinations/), it is easier to come up with the Backtracking solution with few changes. However, there are also other interesting ways to solve the problem.\n\nLet's look at the different approaches in detail.\n\n---\n\n#### Approach 1: Brute Force Using Backtracking\n\n**Intuition**\n> [Backtracking](https://en.wikipedia.org/wiki/Backtracking) is a general approach that works by identifying potential candidates and incrementally builds the solution using depth first search. Once the required goal is reached, we backtrack to explore another potential candidate.\n\nThe backtracking solution for the given problem would be, to begin with, the first vowel character, continue using the same vowel until we build a string of length $$n$$. Post that, backtrack and use the next character.\n\n As we are picking up each vowel character in alphabetically sorted order (first `a`, then `e`, then `i`, and so on), we know that the resultant string is always lexicographically sorted.\n\nExample,\nFor `n = 3`, pick the first vowel `a`, continue picking up the same vowel until we reach $$n$$. The resultant string would be `aaa`. Now that we have found our first combination, backtrack and pick up the next character `e`. Our next string would be `aae`. The process continues until all the vowel characters are explored.  \n\n**Algorithm**\n\n- As we start with the first vowel `a` then `e` and so on, we need a way to determine the current vowel in a recursive function. We use an integer variable `vowel` for that purpose, where `1` denotes `a`, `2` denotes `e`, and so on.\n- We begin with $$n$$ positions and first vowel `a`(1) and use method `countVowelStringUtil ` to recursively compute all the combinations.\n- On every recursion, we decrement `n` by 1 as we have used up that position and continue passing the same vowel. On the backtrack, we move on to the next vowel.\n\n_Base Case_\n\nIf $$n = 0$$, we have reached the end of the string and found one combination. Hence, we return 1 and backtrack.\n\n<iframe src=\"https://leetcode.com/playground/HHA7cxYY/shared\" frameBorder=\"0\" width=\"100%\" height=\"361\" name=\"HHA7cxYY\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(n^{5})$$. We have to calculate the size of the recursion tree. Let's analyze the number of nodes generated at each level. The following figure illustrates the number of enumerations at level $$2$$.\n\n![img](../Figures/5555/timeComplexityBruteForce.png)\n\n   Mathematically, the total number of enumerations at each level can be analyzed as follows,\n1) \tIf we choose vowel `a` for $$i^{th}$$ position, we have $$i-1$$ positions left and we could choose from one of the $$5$$ vowels `(a, e, i, o, u)` as next vowel character.\n\n    Thus, from $$5$$ vowels, we could choose $$i-1$$ vowels with repetitions ([K - Combinations With Repetitions](https://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition)), which can be written as,\n\n      $$\\left(\\!\\!{5\\choose i-1}\\!\\!\\right)$$ $$= \\frac{(5 + (i - 1)-1)}{(5-1)! \\cdot (i-1)!} = \\frac{(i)\\cdot (i+1) \\cdot (i+2) \\cdot (i+3)}{24} $$\n\n2) If we choose vowel `e` for $$i^{th}$$ position, we have $$i-1$$ positions left and we could choose from one of the $$4$$ vowels `(e, i, o, u)` as next vowel character.\n\n    $$\\left(\\!\\!{4\\choose i-1}\\!\\!\\right)$$ $$= \\frac{(4 + (i - 1)-1)!}{(4-1)! \\cdot (i-1)!} = \\frac{(i)\\cdot (i+1) \\cdot (i+2)}{6} $$\n\n3) Similarly, if we choose vowel `i` for $$i^{th}$$ position, we are left with  3 vowels `(i, o, u)` for $$i-1$$ positions.\n\n    $$\\left(\\!\\!{3\\choose i-1}\\!\\!\\right)$$ $$= \\frac{(3 + (i - 1)-1)!}{(3-1)! \\cdot (i-1)!} = \\frac{(i)\\cdot (i+1)}{2} $$\n\n4) Similarly, if we choose vowel `o` for $$i^{th}$$ position, we are left with  2 vowels `(o, u)` for $$i-1$$ positions.\n\n    $$\\left(\\!\\!{2\\choose i-1}\\!\\!\\right)$$ $$= \\frac{(2 + (i - 1)-1)!}{(2-1)! \\cdot (i-1)!} = i $$\n\n5) Lastly, if we choose vowel `u` for $$i^{th}$$ position, we are left with only one vowel `(u)` for $$i-1$$ positions.\n\n    $$\\left(\\!\\!{1\\choose i-1}\\!\\!\\right)$$ $$= \\frac{(1 + (i - 1)-1)!}{(1-1)! \\cdot (i-1)!} = 1 $$\n\n\n   Adding above equations we get,\n             $$\\frac{(i)\\cdot (i+1) \\cdot (i+2) \\cdot (i+3)}{24} + \\frac{(i)\\cdot (i+1) \\cdot (i+2)}{6} +\\frac{(i)\\cdot (i+1)}{2} + i + 1 $$.\n\n   Thus, we could say that at each level $$i$$, there would be roughly $$i^{4}$$ possible branches in the recursion tree. Since, the maximum depth of recursion would be $$n$$, the total number of nodes can be calculated as,\n\n   $$\\sum\\limits_{i=1}^n i^4 = \\mathcal{O}(n^{4+1}) = \\mathcal{O}(n^5)$$.\n\n   This gives us total time complexity as $$\\mathcal{O}(n^{5})$$.\n- Space Complexity: $$\\mathcal{O}(n)$$. This space will be used to store the recursion stack. We can\u2019t have more than $$n$$ recursive calls on the call stack at any time.\n\n---\n\n#### Approach 2: Decoding the Pattern, Using Recursion\n\n**Intuition**\n\nIf we observe, the problem follows a specific pattern. For any given $$n$$ and number of $$\\text{vowels}$$ , the number of combinations is always equal to the _sum_ of following,\n - Number of combinations for previous $$n$$ i.e $$n-1$$  and same number of $$vowels$$\n- Number of combinations for $$vowels-1$$ and same $$n$$.\n\nThe following figure illustrates this idea using an example.\n\n![img](../Figures/5555/combinationPattern.png)\n\nThus, the recurrence relation can be written as,\n```\ncountVowelStrings (n, vowels) = isSum(n - 1, vowels) + isSum(n, vowels - 1)\n```\n\n**Algorithm**\n\n- We start with given $$n$$ and vowels as $$5$$. `{a, e, i, o, u}`.\n- Recursively calculate the result for every $$n$$ and $$\\text{vowels}$$ using above recurrence relation.\n- We must backtrack on the following base cases,\n    - If $$n = 1$$, we have only one position left. Here, we must return the current number of vowels.\n\n      _Example_, if $$n = 1$$ and $$\\text{vowels} = 3$$. As there could be 3 combinations `a, e, i`, the result would be 3.\n\n   - If $$\\text{vowels} = 1$$, we must return $$1$$.\n\n     _Example_, if $$n=3$$, and only 1 vowel `u` is left, there could be only one combination `uuu`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/VWvo6CoN/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"VWvo6CoN\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(n^{5})$$, as for a given $$n$$ and $$5$$ vowels (`a`, `e`, `i`, `o`, `u`), there are roughly $$n^{5}$$ possible candidates (Refer time complexity of _Approach 1_).This gives us time complexity as $$\\mathcal{O}(n^{5})$$.\n\n- Space Complexity: $$\\mathcal{O}(n)$$. This space will be used to store the recursion stack. As the maximum depth of recursion would be $$\\max(n,5)$$, the space required for internal call stack would roughly $$\\mathcal{O}(n)$$.\n\n---\n\n#### Approach 3: Using Recursion + Memoization, Top Down Dynamic Programming\n\n**Intuition**\n\nIf you have solved problems on [Dynamic Programming](https://en.wikipedia.org/wiki/Dynamic_programming) before, it is pretty easy to optimize the _Approach 2_  using Memoization. In the above approach, the problem can be broken down into subproblems. On drawing the recursion tree, it is evident that the same subproblems are computed multiple times.\n\n![img](../Figures/5555/vowelRecursionTree.png)\n\nIn the above recursion tree, we could see that subproblems `(2, 4)`, `(2, 3)` and `(1, 2)` are computed multiple times and the result would be always the same. The problem has [Overlapping Subproblem](https://en.wikipedia.org/wiki/Overlapping_subproblems) and can be solved using _Dynamic Programming_.\n\n**Algorithm**\n\n We could have stored the results of our computation for the first time and used it later.\n This technique of computing once and returning the stored value is called [Memoization](https://en.wikipedia.org/wiki/Memoization).\n\nAs we must store results for every $$n$$ and $$\\text{vowels}$$, we use a two dimensional array $$\\text{memo}$$ of size $$n \\cdot 5$$ and follow the following steps for each recursive call :\n- Check in the memo if we have already calculated results for a given $$n$$ and $$\\text{vowels}$$ and return the result stored in the memo.\n- Save the results of any calculations to $$\\text{memo}$$.\n\n> Since arrays are 0-indexed, we initialize the array of size (n + 1, 5 + 1) and use the range 1..n and 1..5 for easier understanding and keeping it consistent with the previous approach.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/E6NRqwbb/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"E6NRqwbb\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(n)$$, as for every $$n$$ and $$\\text{vowels}$$ we calculate result only once, the total number of nodes in the recursion tree would be $$n \\cdot 5$$, which is roughly equal to $$n$$.\n\n- Space Complexity : $$\\mathcal{O}(n)$$, as we use a 2D array $$\\text{memo}$$ of size $$n \\cdot 5$$ and the size of internal call stack would also be $$n$$ (As explained in _Approach 2_), the space complexity would be $$\\mathcal{O}(n+n) = \\mathcal{O}(n+n)$$.\n\n---\n\n#### Approach 4: Bottom Up Dynamic Programming, Tabulation\n\n**Intuition**\n\nThis is another approach to solve the Dynamic Programming problems. We use the iterative approach and store the result of subproblems in bottom-up fashion also known as Tabulation. We store the results of previous computations in tabular format and use those results for the next computations.\n\n**Algorithm**\n\nWe maintain a 2D array , $$\\text{dp}$$ of size $$n \\cdot 5$$ where, $$\\text{dp[n][vowels]}$$ denotes the total number of combinations for given $$n$$ and number of $$\\text{vowels}$$. Using the recurrence relation established in _Approach 2_, we could iteratively calculate the value for $$\\text{dp[n][vowels]}$$ as,  \n\n```\ndp[n][vowels] = dp[n - 1][vowels] + dp[n][vowels - 1]\n```\nAs this is the Bottom Up approach to solve the problem, we must initialize the table for the base cases. The base cases are the same as in _Approach 2_.\n\n-  If $$n = 1$$, the number of combinations are always equal to number of $$\\text{vowels}$$. Hence, we initialize all the values of $$\\text{dp[1][vowels]}$$ with $$\\text{vowels}$$.  \n-  If $$vowels = 1$$, the number of combinations are always equal to 1. Hence, we initialize all the values of $$\\text{dp[n][1]}$$ with $$1$$.  \n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/mBH7mZpz/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"mBH7mZpz\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(n)$$, as we iterate $$5 \\cdot n$$ times to fill the $$\\text{dp}$$ array, the time complexity is approximately $$\\mathcal{O}(5 \\cdot n) =\\mathcal{O}(n)$$.\n\n- Space Complexity : $$\\mathcal{O}(n)$$, as we use a 2D array of size $$n \\cdot 5$$, the space complexity would be $$\\mathcal{O}(n)$$.\n---\n\n#### Approach 5: Math\n\n**Intuition and Algorithm**\n\nThe problem is a variant of finding [Combinations](https://en.wikipedia.org/wiki/Combination). Mathematically, the problem can be described as, given 5 vowels (let $$k = 5$$), we want to find the number of combinations using only $$n$$ vowels. Also, we can repeat each of those vowels multiple times.\n\n> In other words, from $$k$$ vowels ($$k = 5$$), we can choose $$n$$ vowels with repetition. Denoted as $$\\left(\\!\\!{k \\choose n}\\!\\!\\right)$$, the formulae for [Combination with Repetition ](https://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition) is given by,\n>\n> $$\\left(\\!\\!{k \\choose n}\\!\\!\\right)$$ $$= \\frac{(k + n - 1)!}{ (k - 1)! n!}$$\n>\n\nWe know that the $$k$$ value is $$5$$ as there are always $$5$$ vowels to choose from. Substituting $$k$$ as $$5$$ in above formulae,\n\n$$\\left(\\!\\!{5\\choose n}\\!\\!\\right)$$ $$= \\frac{(n+4) \\cdot (n+3) \\cdot (n+2) \\cdot (n+1)}{24}$$\n\nThe derivation can be illustrated as follows.\n\n![img](../Figures/5555/mathematicalDerivation.png)\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/BHAqJjJb/shared\" frameBorder=\"0\" width=\"100%\" height=\"157\" name=\"BHAqJjJb\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity: $$\\mathcal{O}(1)$$, as the approach runs in constant time.\n\n- Space Complexity: $$\\mathcal{O}(1)$$, as the approach uses constant extra space.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "996",
            "count": 57,
            "average": "4.807",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "count-sorted-vowel-strings",
    "playgroundData": {
        "HHA7cxYY": {
            "playground": {
                "testcaseInput": "",
                "name": "count-sorted-vowel-strings-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "VWvo6CoN": {
            "playground": {
                "testcaseInput": "",
                "name": "count-sorted-vowel-strings-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "E6NRqwbb": {
            "playground": {
                "testcaseInput": "",
                "name": "count-sorted-vowel-strings-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "mBH7mZpz": {
            "playground": {
                "testcaseInput": "",
                "name": "count-sorted-vowel-strings-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "BHAqJjJb": {
            "playground": {
                "testcaseInput": "",
                "name": "count-sorted-vowel-strings-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}