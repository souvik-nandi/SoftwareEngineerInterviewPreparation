{
    "id": "1060",
    "question": {
        "questionId": "1060",
        "questionFrontendId": "1062",
        "boundTopicId": null,
        "title": "Longest Repeating Substring",
        "titleSlug": "longest-repeating-substring",
        "content": "<p>Given a string <code>s</code>, return <em>the length of the longest repeating substrings</em>. If no repeating substring exists, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>There is no repeating substring.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abbaba&quot;\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>The longest repeating substrings are &quot;ab&quot; and &quot;ba&quot;, each of which occurs twice.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aabcaabdaab&quot;\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>The longest repeating substring is &quot;aab&quot;, which occurs <code>3</code> times.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 535,
        "dislikes": 37,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "\"abcd\"\n\"abbaba\"\n\"aabcaabdaab\"",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Rolling Hash",
                "slug": "rolling-hash",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Suffix Array",
                "slug": "suffix-array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Function",
                "slug": "hash-function",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 3}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int longestRepeatingSubstring(string s) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int longestRepeatingSubstring(String s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def longestRepeatingSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def longestRepeatingSubstring(self, s: str) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint longestRepeatingSubstring(char * s){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int LongestRepeatingSubstring(string s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestRepeatingSubstring = function(s) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef longest_repeating_substring(s)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func longestRepeatingSubstring(_ s: String) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func longestRepeatingSubstring(s string) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def longestRepeatingSubstring(s: String): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun longestRepeatingSubstring(s: String): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn longest_repeating_substring(s: String) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function longestRepeatingSubstring($s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function longestRepeatingSubstring(s: string): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (longest-repeating-substring s)\n  (-> string? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec longest_repeating_substring(S :: unicode:unicode_binary()) -> integer().\nlongest_repeating_substring(S) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec longest_repeating_substring(s :: String.t) :: integer\n  def longest_repeating_substring(s) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"28.4K\", \"totalSubmission\": \"48.1K\", \"totalAcceptedRaw\": 28388, \"totalSubmissionRaw\": 48064, \"acRate\": \"59.1%\"}",
        "hints": [
            "Generate all substrings in O(N^2) time with hashing.",
            "Choose those hashing of strings with the largest length."
        ],
        "solution": {
            "id": "753",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "\"abcd\"",
        "metaData": "{\n  \"name\": \"longestRepeatingSubstring\",\n  \"params\": [\n    {\n      \"name\": \"s\",\n      \"type\": \"string\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "753",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Split into two subtasks\n\nLet's focus here on the solutions which are performing better\nthan naive $$\\mathcal{O}(N^2)$$ at least in the best/average cases.  \n\nHere we have \"two in one\" problem :\n\n1. Perform a search by a substring length in the interval from 1 to N.\n\n2. Check if there is a duplicate substring of a given length L.\n\n**Subtask one : Binary search by a substring length**\n\nA naive solution would be to check all possible string length \none by one starting from N - 1: \nif there is a duplicate substring of length N - 1, then of length N - 2, etc. \nNote that if there is a duplicate substring of length k, that means\nthat there is a duplicate substring of length k - 1. \nHence one could use a binary search by string length here,\nand have the first problem solved in $$\\mathcal{O}(\\log N)$$ time. \n\n![pic](../Figures/1062/binary.png)\n\nThe binary search code is quite standard and we will use it here\nfor all approaches to focus on much more interesting subtask number two.\n\n<iframe src=\"https://leetcode.com/playground/YW3x9Tbo/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"YW3x9Tbo\"></iframe>\n\n**Subtask two : Check if there is a duplicate substring of length L**\n\nWe will discuss here three different ideas how to proceed.\nThey are all based on sliding window + hashset, \nthough their performance and space consumption are quite different. \n\n1. Linear-time slice + hashset of already seen strings.\n$$\\mathcal{O}((N - L) L)$$ time complexity and \nhuge space consumption in the case of large strings. \n\n2. Linear-time slice + hashset of _hashes_ of already seen strings. \n$$\\mathcal{O}((N - L) L)$$ time complexity and \nmoderate space consumption even in the case of large strings. \n\n3. Rabin-Karp = constant-time slice + \nhashset of _hashes_ of already seen strings.\nHashes are computed with the rolling hash algorithm.\n$$\\mathcal{O}(N - L)$$ time complexity and \nmoderate space consumption even in the case of large strings.\n\n![pic](../Figures/1062/algorithms.png)\n\n<br /> \n<br />\n\n\n---\n#### Approach 1: Binary Search + Hashset of Already Seen Strings\n\nThe idea is straightforward : \n\n- Move a sliding window of length L along the string of length N.\n \n- Check if the string in the sliding window\nis in the hashset of already seen strings. \n\n    - If yes, the duplicate substring is right here.\n    \n    - If not, save the string in the sliding window in the hashset.  \n\n!?!../Documents/1062_LIS.json:1000,411!?!\n\nObvious drawback of this approach is a huge memory consumption\nin the case of large strings. \n\n<iframe src=\"https://leetcode.com/playground/qz5FBzFQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"qz5FBzFQ\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N \\log N)$$ in the average case\nand $$\\mathcal{O}(N^2)$$ in the worst case. \nOne needs $$\\mathcal{O}((N - L)L)$$ for one duplicate check,\nand one does up to $$\\mathcal{O}(\\log N)$$ checks. \nTogether that results in $$\\mathcal{O}(\\sum\\limits_{L}{(N - L)L})$$, \ni.e. in $$\\mathcal{O}(N \\log N)$$ in the average \ncase and in $$\\mathcal{O}(N^2)$$ in the worst case of L close to $$N/2$$. \n\n* Space complexity : $$\\mathcal{O}(N^2)$$ to keep the hashset.\n<br /> \n<br />\n\n\n---\n#### Approach 2: Binary Search + Hashset of _Hashes_ of Already Seen Strings\n\nTo reduce the memory consumption by the hashset structure,\none could store not the full strings, but their hashes.\n\nThe drawback of this approach is a time performance, \nwhich is still not always linear.  \n\n![pic](../Figures/1062/dupe.png)\n\n<iframe src=\"https://leetcode.com/playground/mG8KVRUW/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mG8KVRUW\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N \\log N)$$ in the average case\nand $$\\mathcal{O}(N^2)$$ in the worst case. \nOne needs $$\\mathcal{O}((N - L)L)$$ for one duplicate check,\nand one does up to $$\\mathcal{O}(\\log N)$$ checks. \nTogether that results in $$\\mathcal{O}(\\sum\\limits_{L}{(N - L)L})$$, \ni.e. in $$\\mathcal{O}(N \\log N)$$ in the average \ncase and in $$\\mathcal{O}(N^2)$$ in the worst case of L close to $$N/2$$. \n\n* Space complexity : $$\\mathcal{O}(N)$$ to keep the hashset.\n\n<br /> \n<br />\n\n\n---\n#### Approach 3: Binary Search + Rabin-Karp\n\nRabin-Karp algorithm is used to perform a multiple pattern search \nin a linear time and with a moderate memory consumption suitable \nfor the large strings. \n\nThe linear time implementation of this idea is a bit\ntricky because of two technical problems:\n\n1. [How to implement a string slice in a constant time?](https://stackoverflow.com/questions/35180377/time-complexity-of-string-slice) \n\n2. Hashset memory consumption could be huge for very long strings. \nOne could keep the string hash instead of string itself\nbut hash generation costs $$\\mathcal{O}(L)$$ for the string of length L,\nand the complexity of algorithm would be $$\\mathcal{O}((N - L)L)$$,\nN - L for the slice and L for the hash generation. \nOne has to think how to generate hash in a constant time here.\n\nLet's now address these problems.\n\n**String slice in a constant time**\n\nThat's a very language-dependent problem. For the moment for \nJava and Python there is no straightforward solution, \nand to move sliding window in a constant time\none has to convert string to another data structure. \n\nThe simplest solution both for Java and Python is to convert string to integer array of ascii-values.\n\n**Rolling hash : hash generation in a constant time**\n\nTo generate hash of array of length L, one needs $$\\mathcal{O}(L)$$ time.\n\n> How to have constant time of hash generation? Use the advantage of \nslice: only one integer in, and only one - out. \n\nThat's the idea of [rolling hash](https://en.wikipedia.org/wiki/Rolling_hash).\nHere we'll implement the simplest one, polynomial rolling hash.\nBeware that's polynomial rolling hash is NOT the [Rabin fingerprint](https://en.wikipedia.org/wiki/Rolling_hash#Rabin_fingerprint).\n\nSince one deals here with lowercase English letters, all values \nin the integer array are between 0 and 25 :\n`arr[i] = (int)S.charAt(i) - (int)'a'`.  \nSo one could consider string `abcd` -> `[0, 1, 2, 3]` as a number \nin a [numeral system](https://en.wikipedia.org/wiki/Numeral_system) with the base 26. \nHence `abcd` -> `[0, 1, 2, 3]` could be hashed as \n\n$$\nh_0 = 0 \\times 26^3 + 1 \\times 26^2 + 2 \\times 26^1 + 3 \\times 26^0\n$$\n\nLet's write the same formula in a generalised way, where $$c_i$$\nis an integer array element and $$a = 26$$ is a system base.\n\n$$\nh_0 = c_0 a^{L - 1} + c_1 a^{L - 2} + ... + c_i a^{L - 1 - i} + ... + c_{L - 1} a^1 + c_L a^0\n$$\n\n$$\nh_0 = \\sum_{i = 0}^{L - 1}{c_i a^{L - 1 - i}}\n$$\n\nNow let's consider the slice `abcd` -> `bcde`. For int arrays that means\n`[0, 1, 2, 3]` -> `[1, 2, 3, 4]`, to remove number 0 and to add number 4.\n\n$$\nh_1 = (h_0 - 0 \\times 26^3) \\times 26 + 4 \\times 26^0\n$$\n\nIn a generalised way\n\n$$\nh_1 = (h_0 a - c_0 a^L) + c_{L + 1}\n$$\n\nNow hash regeneration is perfect and fits in a constant time. \nThere is one more issue to address: possible overflow problem. \n\n**How to avoid overflow**\n\n$$a^L$$ could be a large number and hence\nthe idea is to set limits to avoid the overflow. \nTo set limits means to limit a hash by a given number called modulus\nand use everywhere not hash itself but `h % modulus`.\n\nIt's quite obvious that modulus should be large enough, but how \nlarge? [Here one could read more about the topic](https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use),\nfor the problem here $$2^{24}$$ is enough.\n\nIn a real life, when not all testcases are known in advance, \none has to check if the strings with equal hashes are truly equal.\nSuch false-positive strings could happen \nbecause of a modulus which is too small and strings which are too long.\nThat leads to Rabin-Karp time complexity $$\\mathcal{O}(NL)$$ \nin the worst case then almost all strings are false-positive. \nHere it's not the case because all testcases are known and \none could adjust the modulus. \n\nAnother one overflow issue here is purely Java related.\nWhile in Python the hash regeneration goes perfectly fine, \nin Java the same thing is better to rewrite to avoid\nlong overflow. \n\n<iframe src=\"https://leetcode.com/playground/FzHGskkW/shared\" frameBorder=\"0\" width=\"100%\" height=\"89\" name=\"FzHGskkW\"></iframe>\n\n**Rabin-Karp algorithm**\n\nsearch(L) :\n    \n- Compute the hash of substring `S.substring(0, L)`\n    and initiate the hashset of already seen substring with this value.\n        \n- Iterate over the start position of substring : from 1 to $$N - L$$.\n        \n    - Compute rolling hash based on the previous hash value.\n            \n    - Return start position if the hash is in the hashset,\n        because that means one met the duplicate. \n            \n    - Otherwise, add hash in the hashset.\n         \n- Return -1, that means there is no duplicate string of length L.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/4uZaangG/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4uZaangG\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N \\log N)$$. $$\\mathcal{O}(\\log N)$$\nfor the binary search and $$\\mathcal{O}(N)$$ for Rabin-Karp algorithm.\n* Space complexity : $$\\mathcal{O}(N)$$ to keep the hashset.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "738",
            "count": 90,
            "average": "3.500",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "longest-repeating-substring",
    "playgroundData": {
        "YW3x9Tbo": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-repeating-substring-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "qz5FBzFQ": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-repeating-substring-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "mG8KVRUW": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-repeating-substring-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "FzHGskkW": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-repeating-substring-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "4uZaangG": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-repeating-substring-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}