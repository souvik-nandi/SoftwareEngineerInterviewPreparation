{
    "id": "277",
    "question": {
        "questionId": "277",
        "questionFrontendId": "277",
        "boundTopicId": null,
        "title": "Find the Celebrity",
        "titleSlug": "find-the-celebrity",
        "content": "<p>Suppose you are at a party with <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code> people know the celebrity, but the celebrity does not know any of them.</p>\n\n<p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is ask questions like: &quot;Hi, A. Do you know B?&quot; to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p>\n\n<p>You are given a helper function <code>bool knows(a, b)</code> that tells you whether A knows B. Implement a function <code>int findCelebrity(n)</code>. There will be exactly one celebrity if they are at the party.</p>\n\n<p>Return <em>the celebrity&#39;s label if there is a celebrity at the party</em>. If there is no celebrity, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/19/g1.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,1,0],[0,1,0],[1,1,1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/19/g2.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,0,1],[1,1,0],[0,1,1]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is no celebrity.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == graph.length == graph[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li><code>graph[i][i] == 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If the maximum number of allowed calls to the API <code>knows</code> is <code>3 * n</code>, could you find a solution without exceeding the maximum number of calls?</p>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 2422,
        "dislikes": 223,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Find the Town Judge\", \"titleSlug\": \"find-the-town-judge\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[1,1,0],[0,1,0],[1,1,1]]\n[[1,0,1],[1,1,0],[0,1,1]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Two Pointers",
                "slug": "two-pointers",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Greedy",
                "slug": "greedy",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Graph",
                "slug": "graph",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Interactive",
                "slug": "interactive",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Pinterest\", \"slug\": \"pinterest\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 4}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 6}, {\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "/* The knows API is defined for you.\n      bool knows(int a, int b); */\n\nclass Solution {\npublic:\n    int findCelebrity(int n) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "/* The knows API is defined in the parent class Relation.\n      boolean knows(int a, int b); */\n\npublic class Solution extends Relation {\n    public int findCelebrity(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "# The knows API is already defined for you.\n# @param a, person a\n# @param b, person b\n# @return a boolean, whether a knows b\n# def knows(a, b):\n\nclass Solution(object):\n    def findCelebrity(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "# The knows API is already defined for you.\n# return a bool, whether a knows b\n# def knows(a: int, b: int) -> bool:\n\nclass Solution:\n    def findCelebrity(self, n: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "/* The knows API is defined for you.\n      bool knows(int a, int b); */\n\nint findCelebrity(int n) {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "/* The Knows API is defined in the parent class Relation.\n      bool Knows(int a, int b); */\n\npublic class Solution : Relation {\n    public int FindCelebrity(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * Definition for knows()\n * \n * @param {integer} person a\n * @param {integer} person b\n * @return {boolean} whether a knows b\n * knows = function(a, b) {\n *     ...\n * };\n */\n\n/**\n * @param {function} knows()\n * @return {function}\n */\nvar solution = function(knows) {\n    /**\n     * @param {integer} n Total people\n     * @return {integer} The celebrity\n     */\n    return function(n) {\n        \n    };\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# The knows API is already defined for you.\n# @param {Integer} person a\n# @param {Integer} person b\n# @return {Boolean} whether a knows b\n# def knows(a, b)\n\n# @param {Integer} n\n# @return {Integer}\ndef find_celebrity(n)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "/**\n * The knows API is defined in the parent class Relation.\n *     func knows(_ a: Int, _ b: Int) -> Bool;\n */\n\nclass Solution : Relation {\n    func findCelebrity(_ n: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "/**\n * The knows API is already defined for you.\n *     knows := func(a int, b int) bool\n */\nfunc solution(knows func(a int, b int) bool) func(n int) int {\n    return func(n int) int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "/* The knows API is defined in the parent class Relation.\n      def knows(a: Int, b: Int): Boolean = {} */\n\nclass Solution extends Relation {\n    def findCelebrity(n: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "/* The knows API is defined in the parent class Relation.\n      fun knows(a: Int, b: Int) : Boolean {} */\n\nclass Solution: Relation() {\n    override fun findCelebrity(n: Int) : Int {\n        \n\t}\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "/* The knows API is defined for you.\n       knows(a: i32, b: i32)->bool;\n    to call it use self.knows(a,b)\n*/\n\nimpl Solution {\n    pub fn find_celebrity(&self, n: i32) -> i32 {\n \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "/* The knows API is defined in the parent class Relation.\n      public function knows($a, $b){} */\n\nclass Solution extends Relation {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function findCelebrity($n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "/**\n * The knows API is defined in the parent class Relation.\n * knows(a: number, b: number): boolean {\n *     ...\n * };\n */\n\nvar solution = function(knows: any) {\n\n    return function(n: number): number {\n        \n    };\n};",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"231.1K\", \"totalSubmission\": \"492.8K\", \"totalAcceptedRaw\": 231142, \"totalSubmissionRaw\": 492755, \"acRate\": \"46.9%\"}",
        "hints": [
            "The best hint for this problem can be provided by the following figure:\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_find_celebrity.png\" width=\"700\"/>",
            "Well, if you understood the gist of the above idea, you can extend it to find a candidate that can possibly be a celebrity. Why do we say a \"candidate\"? That is for you to think. This is clearly a greedy approach to find the answer. However, there is some information that would still remain to be verified without which we can't obtain an answer with certainty. To get that stake in the ground, we would need some more calls to the knows API."
        ],
        "solution": {
            "id": "881",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": true,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,1,0],[0,1,0],[1,1,1]]",
        "metaData": "{\n  \"name\": \"findCelebrity\",\n  \"params\": [\n    {\n      \"name\": \"graph\",\n      \"type\": \"integer[][]\",\n      \"internal\": true\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  },\n  \"manual\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "934",
            "date": "2022-05-22",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "881",
        "content": "[TOC]\n\n## Video Solution\n\n---\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/514427854\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n#### Approach 1: Brute Force\n\n**Intuition**\n\nAs per the problem statement, for a given person `i`, we can check whether or not `i` is a celebrity by using the `knows(...)` API to see if everybody knows `i`, and that `i` know nobody.\n\nTherefore, the simplest way of solving this problem is to go through each of the people in turn, and check whether or not they are a celebrity.\n\n**Algorithm**\n\nIt's best to define a separate `isCelebrity(...)` function that takes the id number of a specific person and returns `true` if they are a celebrity and `false` if not. This avoids the need for complex loop-break conditions, thus keeping the code cleaner.\n\nOne edge case we need to be cautious of is not asking person `i` if they know themselves. This can be handled by a check for `i == j` at the start of the main loop of `isCelebrity(...)` and then simply `continue`-ing when it is `true`.\n\n<iframe src=\"https://leetcode.com/playground/B4PHPMAX/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"B4PHPMAX\"></iframe>\n\n**Complexity Analysis**\n\nWe don't know what time and space the `knows(...)` API uses. Because it's not our concern, we'll assume it's $$O(1)$$ for the purpose of analysing our algorithm.\n\n- Time Complexity : $$O(n^2)$$.\n    \n    For each of the $$n$$ people, we need to check whether or not they are a celebrity.\n\n    Checking whether or not somebody is a celebrity requires making $$2$$ API calls for each of the $$n - 1$$ other people, for a total of $$2 \\cdot (n - 1) = 2 \\cdot n - 2$$ calls. In big-oh notation, we drop the constants, leaving $$O(n)$$.\n\n    So each of the $$n$$ celebrity checks will cost $$O(n)$$, giving a total of $$O(n^2)$$.\n\n- Space Complexity : $$O(1)$$.\n\n    Our code only uses constant extra space. The results of the API calls are not saved.\n\n<br />\n\n---\n\n#### Approach 2: Logical Deduction\n\n**Intuition**\n\nWe can do far better than the above approach. Let's start by looking at another way of representing the problem, which is a great way for approaching it in an interview. What we actually have in this problem is a **graph**, where a *directed edge* going from person `A` to person `B` means that we have confirmed that `A knows B`. \n\nFor example, here is a possible graph. Assume that we have made all possible calls to the `knows(...)` API to find these edges. Is there a celebrity here? If so, who is it?\n\n![Introductory example 1](../Figures/277/with_celebrity.png)\n\nWhat about in this graph?\n\n![Introductory example 2](../Figures/277/without_celebrity_1.png)\n\nAnd this one?\n\n![Introductory example 3](../Figures/277/without_celebrity_2.png)\n\nOn the graph representation, a celebrity is a person who has *exactly* `n - 1` directed edges going in (everybody knows them) and `0` edges going out (they know nobody). \n\nOn the first example we looked at above, person `4` is a celebrity because they have `5` directed edges going in, which is `n - 1`. They have no directed edges going out. Note that `3` *is not a celebrity* because they have `5` *outgoing* edges, not `5` ingoing.\n\nOn the second example, there is no celebrity. Person `4` is not a celebrity, because person `2` doesn't know them. There are only `n - 2` directed edges going into `4`.\n\nOn the third example, there is also no celebrity. Person `0` is not a celebrity, because they know person `5`, as represented by the directed edge going from `0` to `5`.\n\nAt the start, we only know the *nodes* of the graph. The *edges* are all hidden. We can \"uncover\" *edges* by making calls to the `knows(...)` API. In the first approach, we uncovered *all* the edges this way. So, the question we need to ask now is... was it actually necessary to uncover *all* of them? A good way to answer this question in an interview is to work through an example on the whiteboard, where you decide which edges you want to ask for, and then draw them as you go.\n\nWhen you do your own example, you'll of course need to know what the full graph behind your example is, or at least the important aspects of it, but you also need to focus on what information you've \"uncovered\" by using the `knows(...)` API. \n\nHere is an animation of an example. To distinguish between `not (A knows B)` and we-haven't-yet-asked if `A knows B`, we use a green solid arrow to show `A knows B`, a red dotted arrow to show `not (A knows B)` and no arrow if we haven't yet asked.\n\n!?!../Documents/277_find_celebrity_experiment.json:960,350!?!\n\nDuring the example in the animation, we asked if `4` knows `6`. Why was this question not necessary to identify the celebrity?\n\n![Asking whether or not 4 knows 6.](../Figures/277/redundant_question.png)\n\nWell, because we already know that both `4` and `6` know at least one other person, this means that neither of them could be the celebrity! Therefore, we've already ruled them out, there was no need to investigate them further.\n\nSo, what can we conclude from the result of an `A knows B` check? If the result was `true`, could `A` be the celebrity? What about `B`?\n\n![A green arrow from A to B.](../Figures/277/a_knows_b.png)\n\nAnd what about if `A knows B` returned `false`? Who couldn't be a celebrity now?\n\n![A red arrow from A to B](../Figures/277/a_doesnt_know_b.png)\n\nIn the first example, we know that `A` can't be a celebrity, because `A` knows somebody, namely `B`. In the second example, we know that `B` can't be a celebrity, because `A`, doesn't know him/her.\n\n> Therefore, with each call to `knows(...)`, we can conclusively determine that exactly **1** of the people is not a celebrity!\n\nThe following algorithm can, therefore, be used to rule out `n - 1` of the people in $$O(n)$$ time. We start by guessing that `0` might be a `celebrityCandidate`, and then we check if `0 knows 1` (within the loop). If `true`, then we know `0` isn't a celebrity (they know somebody), but `1` might be. We update the `celebrityCandidate` variable to `1` to reflect this. Otherwise, we know `1` is not a celebrity (somebody doesn't know them), but we haven't ruled out `0`, yet, so keep them as the `celebrityCandidate`. Whoever we kept is then asked if they know `2`, and so forth.\n\n```python\ncelebrity_candidate = 0\nfor i in range(1, n):\n    if knows(celebrity_candidate, i):\n        celebrity_candidate = i\n```\n\nAt the end, the only person we haven't ruled out is in the `celebrityCandidate` variable.\n\nHere is an animation of the algorithm.\n\n!?!../Documents/277_find_celebrity_candidate.json:960,350!?!\n\nAt the end of the example in the animation, this is how our graph looked. The person who we haven't ruled out is `4`. \n\n![Final slide of the animation, where we identified 4 as the celebrity candidate.](../Figures/277/final_celebrity_candidate.png)\n\nBut do we actually know for *sure* that this person is a celebrity? (Remember, it's possible there's no celebrity, in which case we'd return `-1`).\n\nNope! It's still possible that `0` doesn't know `4`, or perhaps `4` knows `3`. We can't rule these possibilities out from the information we have uncovered so far.\n\nSo, what can we do? We can use our `isCelebrity(...)` function on `4` to check whether or not they are a celebrity. If they are, our function will return `4`. If not, then it should return `-1`.\n\n**Algorithm**\n\nOur algorithm firstly narrows the people down to a single `celebrityCandidate` using the algorithm just above, and then it checks whether or not that candidate is a celebrity using the `isCelebrity(...)`.\n\n<iframe src=\"https://leetcode.com/playground/mUhnT8fb/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mUhnT8fb\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$O(n)$$.\n    \n    Our code is split into 2 parts.\n    \n    The first part finds a celebrity candidate. This requires doing $$n - 1$$ calls to `knows(...)` API, and so is $$O(n)$$.\n\n    The second part is the same as before\u2014checking whether or not a given person is a celebrity. We determined that this is $$O(n)$$.\n\n    Therefore, we have a total time complexity of $$O(n + n) = O(n)$$.\n\n- Space Complexity : $$O(1)$$.\n\n    Same as above. We are only using constant extra space.\n\n<br />\n\n---\n\n#### Approach 3: Logical Deduction with Caching\n\n**Intuition**\n\n*You probably won't need to implement this approach in an interview, however, I wouldn't be surprised if discussing these ideas was a follow up question. For that reason, we'll take a quick look at it!*\n\nHave a look at our example from above again. These are the calls to the `knows(...)` API that were made to identify that `4` is a celebrity candidate.\n\n![Final slide of the animation, where we identified 4 as the celebrity candidate.](../Figures/277/final_celebrity_candidate.png)\n\nNow, these are the calls that our Approach 2 would have made in the second phase to check whether or not our celebrity candidate, `4`, actually is a celebrity.\n\n![The 14 calls made to confirm the candidate.](../Figures/277/celebrity_candidate_confirm.png)\n\nAs shown in the above images, we made some of the same calls twice! The lower the number of the celebrity candidate, the more of these duplicated calls there will be, because the celebrity candidate spent longer in the `celebrityCandidate` variable, and so was involved in a lot more of the initial \"questioning\". Is this actually wasteful though?\n\nWe know that the best possible time complexity we could ever achieve in the average/ worst case is $$O(n)$$. The easiest way of proving this to point out that confirming that somebody *is* a celebrity requires $$O(n)$$ checks. There's simply no way around it, if you miss just one of those checks, it could have been the one that showed they were *not*. \n\nSo, because we can never do better than $$O(n)$$ anyway, surely it really doesn't matter?\n\nYes and no! It's possible that calls to the `knows(...)` API could be *really expensive* (i.e. slow). For example, in the scenario presented in the question, you need to ask the question to people and then listen for their answer. This is time consuming! As a computer-based example, what if the `knows(...)` API was retrieving its answers from a really slow web service on the other side of the world? What if somebody was having to sit in front of their computer, waiting patiently for this algorithm to finish running? They would definitely appreciate it taking 5 seconds instead of 10 seconds, even if that difference is constant.\n\nThe cost of this, however, is space. We will now need to store the results of `n - 1` calls the the `knows(...)` API.\n\nThis is similar to how web browsers cache data. Often, the cost of retrieving a page again is considered to more expensive than the cost of caching a page.\n\n**Algorithm**\n\nFor Java and JavaScript, we'll store our cache in a `HashMap`. For Python, we'll use `lru_cache` in the `functools` library. Other than that, the code is the same as\n\n<iframe src=\"https://leetcode.com/playground/iWYC7hdp/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"iWYC7hdp\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$O(n)$$.\n\n    The time complexity is still $$O(n)$$. The only difference is that sometimes we're retrieving data from a cache inside our code instead of from the API.\n\n- Space Complexity : $$O(n)$$.\n    \n    We're storing the results of the $$n - 1$$ calls to the `know(...)` API we made while finding a candidate.\n\n    We could optimize the space complexity slightly, by dumping the cached contents each time the `celebrityCandidate` variable changes, which would be $$O(1)$$ in the best case (which happens to be the worst case for reducing number of API calls) but it's still $$O(n)$$ space in the worst case and probably not worth the extra code complexity as the algorithm still ultimately requires the memory/ disk space needed for the worst case.\n\n</br>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": true,
        "paidOnlyVideo": true,
        "rating": {
            "id": "839",
            "count": 280,
            "average": "4.904",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "find-the-celebrity",
    "playgroundData": {
        "B4PHPMAX": {
            "playground": {
                "testcaseInput": "",
                "name": "find-the-celebrity-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "mUhnT8fb": {
            "playground": {
                "testcaseInput": "",
                "name": "find-the-celebrity-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "iWYC7hdp": {
            "playground": {
                "testcaseInput": "",
                "name": "find-the-celebrity-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}