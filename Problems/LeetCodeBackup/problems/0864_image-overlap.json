{
    "id": "864",
    "question": {
        "questionId": "864",
        "questionFrontendId": "835",
        "boundTopicId": null,
        "title": "Image Overlap",
        "titleSlug": "image-overlap",
        "content": "<p>You are given two images, <code>img1</code> and <code>img2</code>, represented as binary, square matrices of size <code>n x n</code>. A binary matrix has only <code>0</code>s and <code>1</code>s as values.</p>\n\n<p>We <strong>translate</strong> one image however we choose by sliding all the <code>1</code> bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the <strong>overlap</strong> by counting the number of positions that have a <code>1</code> in <strong>both</strong> images.</p>\n\n<p>Note also that a translation does <strong>not</strong> include any kind of rotation. Any <code>1</code> bits that are translated outside of the matrix borders are erased.</p>\n\n<p>Return <em>the largest possible overlap</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg\" style=\"width: 450px; height: 231px;\" />\n<pre>\n<strong>Input:</strong> img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We translate img1 to right by 1 unit and down by 1 unit.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg\" style=\"width: 450px; height: 105px;\" />\nThe number of positions that have a 1 in both images is 3 (shown in red).\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg\" style=\"width: 450px; height: 231px;\" />\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> img1 = [[1]], img2 = [[1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> img1 = [[0]], img2 = [[0]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == img1.length == img1[i].length</code></li>\n\t<li><code>n == img2.length == img2[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>img1[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li><code>img2[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 131,
        "dislikes": 36,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[[1,1,0],[0,1,0],[0,1,0]]\n[[0,0,0],[0,1,1],[0,0,1]]\n[[1]]\n[[1]]\n[[0]]\n[[0]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"1\": [], \"3\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int largestOverlap(vector<vector<int>>& img1, vector<vector<int>>& img2) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int largestOverlap(int[][] img1, int[][] img2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def largestOverlap(self, img1, img2):\n        \"\"\"\n        :type img1: List[List[int]]\n        :type img2: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint largestOverlap(int** img1, int img1Size, int* img1ColSize, int** img2, int img2Size, int* img2ColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int LargestOverlap(int[][] img1, int[][] img2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} img1\n * @param {number[][]} img2\n * @return {number}\n */\nvar largestOverlap = function(img1, img2) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} img1\n# @param {Integer[][]} img2\n# @return {Integer}\ndef largest_overlap(img1, img2)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func largestOverlap(_ img1: [[Int]], _ img2: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func largestOverlap(img1 [][]int, img2 [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def largestOverlap(img1: Array[Array[Int]], img2: Array[Array[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun largestOverlap(img1: Array<IntArray>, img2: Array<IntArray>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn largest_overlap(img1: Vec<Vec<i32>>, img2: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $img1\n     * @param Integer[][] $img2\n     * @return Integer\n     */\n    function largestOverlap($img1, $img2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function largestOverlap(img1: number[][], img2: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (largest-overlap img1 img2)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec largest_overlap(Img1 :: [[integer()]], Img2 :: [[integer()]]) -> integer().\nlargest_overlap(Img1, Img2) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec largest_overlap(img1 :: [[integer]], img2 :: [[integer]]) :: integer\n  def largest_overlap(img1, img2) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"48K\", \"totalSubmission\": \"78.5K\", \"totalAcceptedRaw\": 47980, \"totalSubmissionRaw\": 78526, \"acRate\": \"61.1%\"}",
        "hints": [],
        "solution": {
            "id": "990",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,1,0],[0,1,0],[0,1,0]]\n[[0,0,0],[0,1,1],[0,0,1]]",
        "metaData": "{\n  \"name\": \"largestOverlap\",\n  \"params\": [\n    {\n      \"name\": \"img1\",\n      \"type\": \"integer[][]\"\n    },\n    {\n      \"name\": \"img2\",\n      \"type\": \"integer[][]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "990",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Overview\n\nFirst of all, this is a really fun problem to solve, as one would discover later.\nIn addition, it could be a practical problem in real world.\nFor instance, if one can find the maximal overlapping zone between two images, one could _clip_ the images to make them smaller and more focused.\n\nIn this article, we will cover three approaches as follows:\n\n- We could solve the problem intuitively by enumerating all the possible overlapping zones.\n\n- Or more efficiently, we can apply some knowledge of _**linear algebra**_ (or geometry), as we will present another solution in the second approach.\n\n- Finally, we could even solve it with the conception of **_convolution_**, as in Convolution Neural Network (_a.k.a._ CNN), which is the backbone operation for the image recognition models nowadays.\n\n\n---\n#### Approach 1: Shift and Count\n\n**Intuition**\n\nAs stated in the problem description, in order to calculate the number of ones in the overlapping zone, we should first **_shift_** one of the images.\nOnce the image is shifted, it is intuitive to __*count*__ the numbers.\n\n>Therefore, a simple idea is that one could come up all possible overlapping zones, by _shifting_ the image matrix, and then simply count within each overlapping zone.\n\nThe image matrix could be shifted in four directions, _i.e._ left, right, up and down.\n\nWe could represent the shifting with a 2-axis coordinate as follows, where the X-axis indicates the shifting on the directions of _left_ and _right_ and the Y-axis indicates the shifting of _up_ and _down_.\n\n![Image Shift](../Figures/835/835_image_shift.png)\n\nFor instance, the coordinate of `(1, 1)` represents that we shift the matrix to the right by one and to the up side by one as well.\n\n>One important insight is that shifting one matrix to a direction is **equivalent** to shifting the other matrix to the _opposite_ direction, in the sense that we would have the same overlapping zone at the end.\n\n![Image Shift](../Figures/835/835_equivalent_shifts.png)\n\nFor example, by shifting the matrix A to one step on the right, is same as shifting the matrix B to the left by one step.\n\n**Algorithm**\n\nBased on the above intuition, we could implement the solution step by step.\nFirst we define the function `shift_and_count(x_shift, y_shift, M, R)` where we shift the matrix `M` with reference to the matrix `R` with the shifting coordinate `(x_shift, y_shift)` and then we count the overlapping ones in the overlapping zone.\n\n- The algorithm is organized as a loop over all possible combinations of shifting coordinates `(x_shift, y_shift)`.\n\n- More specifically, the ranges of `x_shift` and `y_shift` are both `[0, N-1]` where $$N$$ is the width of the matrix. \n\n- At each iteration, we invoke the function `shift_and_count()` twice to shift and count the overlapping zone, first with the matrix B as the reference and vice versa.\n\n\n<iframe src=\"https://leetcode.com/playground/bWPTLUSi/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bWPTLUSi\"></iframe>\n\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the width of the matrix.\n\nFirst of all, let us calculate the number of all possible shiftings, (_i.e._ the number of overlapping zones).\n\nFor a matrix of length $$N$$, we have $$2(N-1)$$ possible offsets along each axis to shift the matrix.\nTherefore, there are in total $$2(N-1) \\cdot 2(N-1)  = 4(N-1)^2$$ possible overlapping zones to calculate.\n\n- Time Complexity: $$\\mathcal{O}(N^4)$$\n\n    - As discussed before, we have in total $$4(N-1)^2$$ possible overlapping zones.\n\n    - The size of the overlapping zone is bounded by $$\\mathcal{O}(N^2)$$.\n\n    - Since we iterate through each overlapping zone to find out the overlapping ones, the overall time complexity of the algorithm would be $$4(N-1)^2 \\cdot \\mathcal{O}(N^2) = \\mathcal{O}(N^4)$$.\n\n- Space Complexity: $$\\mathcal{O}(1)$$\n\n    - As one can see, a constant space is used in the above algorithm.\n\n\n---\n#### Approach 2: Linear Transformation\n\n**Intuition**\n\nOne drawback of the above algorithm is that we would scan through those zones that are filled with zeros over and over, even though these zones are not of our interests.\n\nBecause for those cells filled with zero, no matter how we _shift_, they would not _add up_ to the final solutions.\nAs a follow-up question, we could ask ourselves that, _can we **focus** on those cells with ones?_\n\n>The answer is yes. The idea is that we filter out those cells with ones in both matrices, and then we apply the **_linear transformation_** to _align_ the cells.\n\nFirst of all, we define a 2-dimension coordinate, via which we could assign a unique coordinate to each cell in the matrix, _e.g._ a cell can be indexed as $$I = (X_i, Y_i)$$.\n\nThen to shift a cell, we can obtain the new position of the cell by applying a _linear transformation_.\nFor example, to shift the cell to the right by one and to the up side by one is to apply the linear transformation vector of $$V = (1, 1)$$.\nThe new index of the cell can be obtained by $$I + V = (X_i + 1, Y_i + 1)$$.\n\n![linear transformation](../Figures/835/835_linear_transformation.png)\n\nFurthermore, given two matrices, we have two non-zero cells respectively in the matrices as $$P_a =(X_a, Y_a)$$ and $$P_b = (X_b, Y_b)$$.\nTo **align** these cells together, we would need a transformation vector as $$V_{ab} = (X_b - X_a, Y_b - Y_a)$$, so that $$P_a + V_{ab} = P_b$$.\n\n>Now, the key insight is that all the cells in the **same** overlapping zone would share the **same** linear transformation vector.\n\nBased on the above insight, we can then use the transformation vector $$V_{ab}$$ as a key to **group** all the non-zero cells alignments between two matrices.\nEach group represents an overlapping zone.\nNaturally, the size of the overlapping zone would be the size of the group as well.\n\n**Algorithm**\n\nThe algorithm can be implemented in two overall steps.\n\n- First, we filter out those non-zero cells in each matrix respectively.\n\n- Second, we do a cartesian product on the non-zero cells. For each pair of the products, we calculate the corresponding linear transformation vector as $$V_{ab} = (X_b - X_a, Y_b - Y_a)$$.\nThen, we count the number of the pairs that have the same transformation vector, which is also the number of ones in the overlapping zone. \n\nHere are some sample implementation which are inspired from the user [TejPatel18](https://leetcode.com/problems/image-overlap/discuss/150504/Python-Easy-Logic) in the discussion forum.\n\n<iframe src=\"https://leetcode.com/playground/QjMcaTRN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"QjMcaTRN\"></iframe>\n\n\n\n**Complexity Analysis**\n\nLet $$M_a, M_b$$ be the number of non-zero cells in the matrix A and B respectively. Let $$N$$ be the width of the matrix.\n\n- Time Complexity: $$\\mathcal{O}(N^4)$$.\n\n    - In the first step, we filter out the non-zero cells in each matrix, which would take $$\\mathcal{O}(N^2)$$ time.\n\n    - In the second step, we enumerate the cartesian product of non-zero cells between the two matrices, which would take $$\\mathcal{O}(M_a \\cdot M_b)$$ time. In the worst case, both $$M_a$$ and $$M_b$$ would be up to $$N^2$$, _i.e._ matrix filled with ones.\n\n    - To sum up, the overall time complexity of the algorithm would be $$\\mathcal{O}(N^2) + \\mathcal{O}(N^2 \\cdot N^2) = \\mathcal{O}(N^4)$$.\n\n    - Although this approach has the same time complexity as the previous approach, it should run faster in practice, since we ignore those zero cells.\n\n- Space Complexity: $$\\mathcal{O}(N^2)$$\n\n    - We kept the indices of non-zero cells in both matrices. In the worst case, we would need the $$\\mathcal{O}(N^2)$$ space for the matrices filled with ones.\n\n\n---\n#### Approach 3: Imagine Convolution\n\n**Intuition**\n\nAs it turns out, the number of overlapped ones in an overlapping zone is equal to the result of performing a [convolution operation](https://en.wikipedia.org/wiki/Kernel_(image_processing)) between two matrices.\n\n![image convolution](../Figures/835/835_convolution.png)\n\nTo put it simple, the convolution between two matrices is to perform a **dot product** between them, _i.e._ $$\\sum_{x}^{N}\\sum_{y}^{N}\\big(V_{xy}(A) \\cdot V_{xy}(B)\\big)$$ where $$V_{xy}(A)$$ and is the value of the cell in the matrix A at the position of $$(x, y)$$.\n\nFrom the above formulas, one can clearly see why the result of convolution is the number of overlapping ones.\n\nUsually, the image convolution is performed between an image and a specific **_kernel_** matrix, in order to obtain certain effects such as blurring or sharpening.\nIn our case, we would perform the convolution between the matrix A and the **_shifted_** matrix B which serves as a kernel.\n\nMore importantly, we should shift the matrix with truncation and **_zero padding_**, in order to obtain a proper kernel for convolution.\n\n![shift with padding](../Figures/835/835_shift_with_padding.png)\n\n>As a result, rather than manually counting the number of overlapping ones, we could perform the convolution operation instead.\n\n**Algorithm**\n\nOverall, we enumerate all possible kernels (by shifting the matrix B), and then perform the convolution operation to count the overlapping ones.\nThe algorithm can be broke down into the following steps:\n\n- First of all, we extend both the width and height of the matrix B to $$N + 2(N-1) = 3N-2$$, and pad the extended cells with zeros, as follows:\n\n![kernels](../Figures/835/835_kernels.png)\n\n- From the extended and padded matrix B, we then can extract the kernel one by one.\n\n- For each kernel, we perform the convolution operation with the matrix A to count the number of overlapping ones.\n\n- At the end, we return the maximal value of overlapping ones.\n\nHere are some sample implementations that are inspired from the solution of user [HeroKillerEver](https://leetcode.com/problems/image-overlap/discuss/131344/An-interesting-SOLUTION%3A-Let-us-think-about-it-as-%22Convolution%22) in the discussion forum.\n\n<iframe src=\"https://leetcode.com/playground/miV4zwBW/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"miV4zwBW\"></iframe>\n\nNote that, in the Python solution, we utilise the `numpy` package, which is a well-known library in the tasks of data processing and machine learning.\n\nThe `numpy` library is highly _optimized_ for the matrix operations, which is why it runs faster than the Approach #1, although they have the same time complexity.\n\n**Complexity Analysis**\n\nLet $$N$$ be the width of the matrix.\n\n- Time Complexity: $$\\mathcal{O}(N^4)$$\n\n    - We iterate through $$(2N-1) \\cdot (2N-1)$$ number of kernels.\n\n    - For each kernel, we perform a convolution operation, which takes $$\\mathcal{O}(N^2)$$ time.\n\n    - To sum up, the overall time complexity of the algorithm would be $$(2N-1) \\cdot (2N-1) \\cdot \\mathcal{O}(N^2) = \\mathcal{O}(N^4)$$.\n\n- Space Complexity: $$\\mathcal{O}(N^2)$$\n\n    - We extend the matrix B to the size of $$(3N-2) \\cdot (3N-2)$$, which would require the space of $$\\mathcal{O}(N^2)$$.\n\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "935",
            "count": 50,
            "average": "4.560",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "image-overlap",
    "playgroundData": {
        "bWPTLUSi": {
            "playground": {
                "testcaseInput": "",
                "name": "image-overlap-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "QjMcaTRN": {
            "playground": {
                "testcaseInput": "",
                "name": "image-overlap-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "miV4zwBW": {
            "playground": {
                "testcaseInput": "",
                "name": "image-overlap-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}