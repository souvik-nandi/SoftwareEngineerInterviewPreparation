{
    "id": "594",
    "question": {
        "questionId": "594",
        "questionFrontendId": "594",
        "boundTopicId": null,
        "title": "Longest Harmonious Subsequence",
        "titleSlug": "longest-harmonious-subsequence",
        "content": "<p>We define a harmonious array as an array where the difference between its maximum value and its minimum value is <b>exactly</b> <code>1</code>.</p>\r\n\r\n<p>Given an integer array <code>nums</code>, return <em>the length of its longest harmonious subsequence among all its possible subsequences</em>.</p>\r\n\r\n<p>A <strong>subsequence</strong> of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,3,2,2,5,2,3,7]\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> The longest harmonious subsequence is [3,2,2,2,3].\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4]\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,1,1]\r\n<strong>Output:</strong> 0\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\r\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\r\n</ul>",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Easy",
        "likes": 1613,
        "dislikes": 153,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[1,3,2,2,5,2,3,7]\n[1,2,3,4]\n[1,1,1,1]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Sorting",
                "slug": "sorting",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"LiveRamp\", \"slug\": \"liveramp\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\r\npublic:\r\n    int findLHS(vector<int>& nums) {\r\n        \r\n    }\r\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\r\n    public int findLHS(int[] nums) {\r\n        \r\n    }\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\r\n    def findLHS(self, nums):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :rtype: int\r\n        \"\"\"",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\r\n    def findLHS(self, nums: List[int]) -> int:",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "int findLHS(int* nums, int numsSize){\r\n\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\r\n    public int FindLHS(int[] nums) {\r\n        \r\n    }\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar findLHS = function(nums) {\r\n    \r\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} nums\r\n# @return {Integer}\r\ndef find_lhs(nums)\r\n    \r\nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\r\n    func findLHS(_ nums: [Int]) -> Int {\r\n        \r\n    }\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func findLHS(nums []int) int {\r\n    \r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\r\n    def findLHS(nums: Array[Int]): Int = {\r\n        \r\n    }\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\r\n    fun findLHS(nums: IntArray): Int {\r\n        \r\n    }\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\r\n    pub fn find_lhs(nums: Vec<i32>) -> i32 {\r\n        \r\n    }\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\r\n\r\n    /**\r\n     * @param Integer[] $nums\r\n     * @return Integer\r\n     */\r\n    function findLHS($nums) {\r\n        \r\n    }\r\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function findLHS(nums: number[]): number {\r\n\r\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (find-lhs nums)\r\n  (-> (listof exact-integer?) exact-integer?)\r\n\r\n  )",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"119.6K\", \"totalSubmission\": \"226.1K\", \"totalAcceptedRaw\": 119559, \"totalSubmissionRaw\": 226052, \"acRate\": \"52.9%\"}",
        "hints": [],
        "solution": {
            "id": "141",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,3,2,2,5,2,3,7]",
        "metaData": "{\r\n  \"name\": \"findLHS\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "141",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Approach 1: Brute Force\n\nIn the brute force solution, we consider every possible subsequence that can be formed using the elements of the given array. For every subsequence, we find the maximum and minimum values in the subsequence. If the difference between the maximum and the minimum values obtained is 1, it means the current subsequence forms a harmonious subsequence. Thus, we can consider the number of elements in this subsequence to be compared with the length of the last longest harmonious subsequence. \n\nIn order to obtain all the subseqeuences possible, we make use of binary number representation of decimal numbers. For a binary number of size $$n$$, a total of $$2^n$$ different binary numbers can be generated. We generate all these binary numbers from $$0$$ to $$2^n$$. For every binary number generated, we consider the subsequence to be comprised of only those elements of $$nums$$ which have a 1 at the corresponding position in the current binary number. The following figure shows an example of the way the elements of $$nums$$ are considered in the current subsequence.\n\n![Harmonic_Subsequence](../Figures/594_Harmonic_Subsequence_Binary.PNG)\n\n<iframe src=\"https://leetcode.com/playground/H2Qr2BKn/shared\" frameBorder=\"0\" width=\"100%\" height=\"361\" name=\"H2Qr2BKn\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(2^n)$$. Number of subsequences generated will be $$2^n$$.\n\n* Space complexity : $$O(1)$$. Constant space required.\n<br>\n<br>\n\n---\n#### Approach 2: Better Brute Force\n\n**Algorithm**\n\nIn the last approach, we created every possible subsequence, and for every such subsequence, we found out if it satisfies the harmonicity condition. Instead of doing this, we can do as follows. We can consider every element of the given $$nums$$ array one by one. For $$nums[i]$$ chosen to be the current element, we determine the $$count$$ of all the elements in the $$nums$$ array, which satisfy the harmonicity condition with $$nums[i]$$, i.e. the $$count$$ of all such $$nums[j]$$ satisfying $$nums[i] == nums[j]$$ or $$nums[i] == nums[j] + 1$$. When we reach the end of the array for $$nums[i]$$ being the current element, we compare this $$count$$ obtained with the result obtained from the previous traversals and update the result appropriately. When all the elements of the array have been chosen as the element to be chosen as the base for harmonicity check, we get the required length of the longest harmonic subsequence.\n\nThe following animation illustrates the process:\n\n!?!../Documents/594_Harmonic_Subsequence_1.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/esihum3Z/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"esihum3Z\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n^2)$$. Two nested loops are there.\n\n* Space complexity : $$O(1)$$. Constant space required.\n<br>\n<br>\n\n---\n#### Approach 3: Using Sorting\n\n**Algorithm**\n\nSince we are concerned only with the count of elements which are at a difference of 1, we can use sorting to our advantage. If we sort the given $$nums$$ array, the related elements will get arranged close to each other. Thus, we can traverse over the sorted array, and find the count of similar elements and elements one larger than the current ones, which occur consecutively(all the similar elements will be lying consecutively now). Initially, this value is stored in $$prev\\_count$$ variable. Then, if we encounter an element which is just 1 larger than the last elements, we count the occurences of such elements as well. This value is stored in $$count$$ variable. \n\nThus, now for the harmonic subsequence comprised of only these two elements is a subsequence of length $$count + prev\\_count$$. This result is stored in $$res$$ for each subsequence found. When we move forward to considering the next set of similar consecutive elements, we need to update the $$prev\\_count$$ with the $$count$$'s value, since now $$count$$ will act as the count of the elements 1 lesser than the next elements encountered. The value of $$res$$ is always updated to be the larger of previous $$res$$ and the current $$count + prev\\_count$$ value.\n\nWhen we are done traversing over the whole array, the value of $$res$$ gives us the required result.\n\n<iframe src=\"https://leetcode.com/playground/qjbYZPWC/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"qjbYZPWC\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n\\log n)$$. Sorting takes $$O(n\\log n)$$ time.\n\n* Space complexity : $$O(\\log n)$$. $$\\log n$$ space is required by sorting in average case.\n<br>\n<br>\n\n---\n#### Approach 4: Using HashMap\n\n**Algorithm**\n\nIn this approach, we make use of a hashmap $$map$$ which stores the number of times an element occurs in the array along with the element's value in the form $$(num: count\\_num)$$, where $$num$$ refers to an element in the array and $$count\\_num$$ refers to the number of times this $$num$$ occurs in the $$nums$$ array. We traverse over the $$nums$$ array and fill this $$map$$ once.\n\nAfter this, we traverse over the keys of the $$map$$ created. For every key of the $$map$$ considered, say $$key$$, we find out if the map contains the $$key + 1$$. Such an element is found, since only such elements can be counted for the harmonic subsequence if $$key$$ is considered as one of the element of the harmonic subsequence. We need not care about $$key - 1$$, because if $$key$$ is present in the harmonic subsequence, at one time either $$key + 1$$ or $$key - 1$$ only could be included in the harmonic subsequence. The case of $$key - 1$$ being in the harmonic subsequence will automatically be considered, when $$key - 1$$ is encountered as the current key. \n\nNow, whenver we find that $$key + 1$$ exists in the keys of $$map$$, we determine the count of the current harmonic subsequence as $$count_{key} + count_{key+1}$$, where $$count_i$$ refers to the value corresponding to the key $$i$$ in $$map$$, which reprents the number of times $$i$$ occurs in the array $$nums$$.\n\nLook at the animation below for a pictorial view of the process:\n\n!?!../Documents/594_Harmonic_Subsequence_2.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/eq45aYH5/shared\" frameBorder=\"0\" width=\"100%\" height=\"293\" name=\"eq45aYH5\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. One loop is required to fill $$map$$ and one for traversing the $$map$$.\n\n* Space complexity : $$O(n)$$. In worst case map size grows upto size $$n$$.\n<br>\n<br>\n\n---\n#### Approach 5: In Single Loop\n\n**Algorithm**\n\nInstead of filling the $$map$$ first and then traversing over the $$map$$ to determine the lengths of the harmonic subsequences encountered, we can traverse over the $$nums$$ array, and while doing the traversals, we can determine the lengths of the harmonic subsequences possible till the current index of the $$nums$$ array. \n\nThe method of finding the length of harmonic subsequence remains the same as the last approach. But, this time, we need to consider the existence of both $$key + 1$$ and $$key - 1$$ exclusively and determine the counts corresponding to both the cases. This is needed now because it could be possible that $$key$$ has already been added to the $$map$$ and later on $$key - 1$$ is encountered. In this case, if we consider the presence of $$key + 1$$ only, we'll go in the wrong direction.\n\nThus, we consider the $$count$$s corresponding to both the cases separately for every $$key$$ and determine the maximum out of them. \nThus, now the same task can be done only in a single traveral of the $$nums$$ array.\n\nSee the animation below for understanding the process:\n\n!?!../Documents/594_Harmonic_Subsequence_3.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/mEou6uoB/shared\" frameBorder=\"0\" width=\"100%\" height=\"293\" name=\"mEou6uoB\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. Only one loop is there.\n\n* Space complexity : $$O(n)$$. $$map$$ size grows upto size $$n$$.\n<br>\n<br>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "134",
            "count": 72,
            "average": "4.764",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "longest-harmonious-subsequence",
    "playgroundData": {
        "H2Qr2BKn": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-harmonious-subsequence-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "esihum3Z": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-harmonious-subsequence-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "qjbYZPWC": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-harmonious-subsequence-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "eq45aYH5": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-harmonious-subsequence-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "mEou6uoB": {
            "playground": {
                "testcaseInput": "",
                "name": "longest-harmonious-subsequence-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}