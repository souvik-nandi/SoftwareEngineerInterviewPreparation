{
    "id": "1909",
    "question": {
        "questionId": "1909",
        "questionFrontendId": "1762",
        "boundTopicId": null,
        "title": "Buildings With an Ocean View",
        "titleSlug": "buildings-with-an-ocean-view",
        "content": "<p>There are <code>n</code> buildings in a line. You are given an integer array <code>heights</code> of size <code>n</code> that represents the heights of the buildings in the line.</p>\n\n<p>The ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a <strong>smaller</strong> height.</p>\n\n<p>Return a list of indices <strong>(0-indexed)</strong> of buildings that have an ocean view, sorted in increasing order.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [4,2,3,1]\n<strong>Output:</strong> [0,2,3]\n<strong>Explanation:</strong> Building 1 (0-indexed) does not have an ocean view because building 2 is taller.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [4,3,2,1]\n<strong>Output:</strong> [0,1,2,3]\n<strong>Explanation:</strong> All the buildings have an ocean view.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [1,3,2,4]\n<strong>Output:</strong> [3]\n<strong>Explanation:</strong> Only building 3 has an ocean view.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 863,
        "dislikes": 114,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Number of Visible People in a Queue\", \"titleSlug\": \"number-of-visible-people-in-a-queue\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[4,2,3,1]\n[4,3,2,1]\n[1,3,2,4]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Stack",
                "slug": "stack",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Monotonic Stack",
                "slug": "monotonic-stack",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 128}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}], \"3\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findBuildings(vector<int>& heights) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int[] findBuildings(int[] heights) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def findBuildings(self, heights: List[int]) -> List[int]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findBuildings(int* heights, int heightsSize, int* returnSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int[] FindBuildings(int[] heights) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} heights\n * @return {number[]}\n */\nvar findBuildings = function(heights) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} heights\n# @return {Integer[]}\ndef find_buildings(heights)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func findBuildings(_ heights: [Int]) -> [Int] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func findBuildings(heights []int) []int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def findBuildings(heights: Array[Int]): Array[Int] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun findBuildings(heights: IntArray): IntArray {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn find_buildings(heights: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $heights\n     * @return Integer[]\n     */\n    function findBuildings($heights) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function findBuildings(heights: number[]): number[] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (find-buildings heights)\n  (-> (listof exact-integer?) (listof exact-integer?))\n\n  )",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"119.7K\", \"totalSubmission\": \"150.4K\", \"totalAcceptedRaw\": 119663, \"totalSubmissionRaw\": 150417, \"acRate\": \"79.6%\"}",
        "hints": [
            "You can traverse the buildings from the nearest to the ocean to the furthest.",
            "Keep with you the maximum to the right while traversing to determine if you can see the ocean or not."
        ],
        "solution": {
            "id": "1201",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[4,2,3,1]",
        "metaData": "{\n  \"name\": \"findBuildings\",\n  \"params\": [\n    {\n      \"name\": \"heights\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer[]\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1201",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nIn this problem, we need to find all of the buildings that have an ocean view and return their indices. A building is said to have an ocean view if and only if all the buildings to its right are strictly shorter.\n\n![image](../Figures/1762/Slide1.JPG)\n\n<br />\n\nWhen first coming up with the solution to any problem, it often helps to start with the most naive approach.  For this problem, the most naive approach is as follows: for each building, we will iterate over all of the buildings to its right and check if there is any building with equal or greater height than the current building.\n\n\n```c++\n// Let N equal the length of the array heights.\nfor current = 0 to N     \n    canSee = true\n    \n    for next = current + 1 to N \n        if current height <= next height\n            canSee = false\n    \n    if canSee\n        add current index to answer array\n```\n\nHowever, this approach requires $$O(N^2)$$ time because, for all $$N$$ buildings, we check every building to its right to see if any are of equal height or taller, which requires $$O(N)$$ time per building.  Intuitively, we will need to visit every building at least once to determine if it has an ocean view, but let's see if we can find a way to do so without repeatedly visiting all of the buildings to the right.  \n<br />\n\n---\n\n#### Approach 1: Linear Iteration\n\n**Intuition**\n\nOur goal is to create an array (`answer`) that contains indices for the buildings that have an ocean view and ideally to do so without looking at every building to the right every time we need to find out if a building has an ocean view.  So what can we change to improve on the naive solution?\n\nWhen looking for a way to optimize the naive solution, sometimes it helps to consider the problem from a new perspective. How about instead of looking right and asking, \"does any building block this building's view\" we look left and ask \"which buildings' view is blocked by this building?\"  \n\nFor each building, initially, let's assume that it has an ocean view. Currently, we're not worrying about any of the buildings to the right.  \n\nInstead, we will look left and see if any of the buildings that had an ocean view are blocked by the current building. Any buildings whose view is blocked must be removed from the answer array before we can add the current building into the answer array.\n\nNow, if the current building is strictly shorter than the last building in the answer array, then it will not block the ocean view of any of the buildings that are already present in the answer array.  This is because the last building present in the array was not blocking the ocean view of any other buildings, and the current building must be even shorter.\nThus, the current building will be shorter than all of the other buildings in the answer array.    \n\nBy repeating this process of removing any building with a blocked view from the array and then appending the current building to the array, every building will be added to the answer array once, and every blocked building will be removed from the answer array once. Thus we have our answer. \n\n</br>\n\n!?!../Documents/1762/slideshow1.json:960,540!?!\n\n</br>\n\n**Algorithm**\n\n1. Create an `answer` array to store all of the buildings that have an ocean view.\n2. Iterate over the given array of buildings from left to right.\n3. For each current building:\n    - Pop all the building indices from the end of the `answer` array if their height is less than or equal to the height of the current building.\n    - Push the current building index into the `answer` array.\n4. In the end, the `answer` array will only contain buildings that have an ocean view. Return the `answer` array.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/APfNhXsL/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"APfNhXsL\"></iframe>\n\n**Complexity Analysis**\n\nHere $$N$$ is the size of the given array.\n\n* Time complexity: $$O(N)$$.    \n    - We iterate over the given array once.     \n    - Each building's index can be pushed to `answer` and popped from `answer` at most once, and both of the operations take $$O(1)$$ time.\n    - In Java, copying the elements from an array list to an integer array will take an additional $$O(N)$$ time.\n\n* Space complexity: $$O(N)$$.    \n    - There is no auxiliary space used other than the output. The output does not count towards the space complexity. However, in the worst-case scenario, `answer` may contain as many as $$N - 1$$ indices, and then the very last building is the tallest, so the output will reduce to one index. In this scenario, the algorithm must store $$N - 1$$ elements at some point, but only $$1$$ element is included in the output.\n    - In Java, in order to maintain a dynamic size array, we created an extra Array List that supports fast $$O(1)$$ push/pop operation. Array List can contain at most $$N$$ elements. Hence in Java, an additional $$O(N)$$ space is used.\n\n<br/>\n\n---\n\n#### Approach 2: Monotonic Stack \n\n**Intuition**\n\nIn the previous approach, we performed better than the naive solution by changing our perspective.  Instead of looking ahead to see if any building to the right is blocking the current building's view, we looked back and removed every building whose view is blocked by the current building.  By removing all shorter buildings from the array before adding the current building to the array, we inadvertently maintained a monotonic stack where the building heights are in decreasing order.  So the key to the first approach's success was using a **monotonic stack** and traversing the array from left to right but looking **left** (to see which buildings are blocked) instead of looking **right** (to see if any building is blocking the current building's view).  \n\nLet's take these two ideas from the first approach and use them as the foundation for a new approach.  First, let's take the idea of looking in the opposite direction of the array traversal, except this time we will traverse from right to left.  So, unlike the first approach, where we traversed the array from left to right checking if the current building blocks other buildings' ocean view to its left, here, we will traverse from right to left and check if the current building's ocean view is blocked by any building to its right.\n\nSo we can convert this problem into finding the next element to the right that is greater than or equal to the current element. If there is no element to the right that is greater than or equal to the current element, it means the view is not blocked. For clarity, let's consider an example where we traverse from right to left and look right to check if the current building's ocean view is blocked by any building to its right.\n\n> Assume we have $$6$$ buildings with heights, $$[5, 2, 1, 3, 4, 2]$$.    \n> Now, we can see the buildings at indices $$5$$ and $$4$$ do not have any next greater or equal height building to their right. Hence their views are not blocked.      \n> The building at index $$3$$ has the next greater or equal height building at index $$4$$. Hence its view is blocked by the building at index $$4$$.    \n> Similarly, the buildings at indices $$2$$ and $$1$$ have their next greater or equal height building at index $$3$$ to their right. Hence their views are blocked.      \n> The building at index $$0$$ does not have any next greater or equal building. Hence its view is not blocked.    \n\n\nBut how can we efficiently check if any building to the right is taller than the current building? In the previous approach, for each building, we would pop all buildings whose view would be blocked by the current building from the answer array (which was effectively a stack). Here, we can adopt a very similar approach and use a stack to store the buildings to the right in decreasing order. Just like before, for each building, we can pop all buildings from the stack that are strictly shorter than the current building and then add the current building to the stack.  \n\nThis process of popping all shorter buildings from the stack before adding the current building to the stack means that the stack will always contain buildings in decreasing order, hence it is called **monotonically decreasing stack**.    \n\n> A stack when it consists of elements only in decreasing order is known as a monotonically decreasing stack.    \nThe basic idea is to only push the new element onto the stack if it is strictly smaller than the top element, otherwise pop all elements that are less than or equal to the new element from the top of the stack, and then push the new element onto the stack. This way, the stack's elements will be in strictly decreasing order.     \n\n<br />\n\n\n![image](../Figures/1762/Slide2.JPG)\n\n<br />\n\nTo learn more, here is an article about [Monotonic Stacks](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step) written by a fellow LeetCode user.\n\nAs shown above, just before the current element is added to a monotonically decreasing stack, all elements in the stack will be greater than or equal to the current element. Here, since we are traversing the buildings from right to left, this means that the stack will only contain buildings of equal or greater height that are to the right of the current building.  Thus, the current building will only have an ocean view when the stack is empty.  Otherwise, there must exist a building of equal or greater height to the right of the current building. Therefore, by maintaining a monotonically decreasing stack as we traverse the buildings from right to left, we can tell if a building has an ocean view by whether or not the stack is empty just before the building is added to the stack.\n</br>\n\nThus, we can start by traversing the given array of building heights from right to left.     \nFor each building, some values may already be in the stack.  These values are the indices of buildings to the right of the current building. Then we can pop the shorter buildings from the top of the stack to find the first building to the right that has a greater or equal height than the current building.\nIf there is no next building with greater or equal height, then the stack will be empty.  This means that no buildings are blocking the current buildings' view of the ocean.     \nThen push the current building into the stack and repeat the process for finding the next building of greater or equal height for the next building in our array traversal.\n\n<br />\n\n!?!../Documents/1762/slideshow2.json:960,540!?!\n\n</br>\n\n**Algorithm**\n\n1. Iterate over the array of building heights from right to left.\n2. For each current building,\n    - While the stack is not empty, and the height of the building on top of the stack is less than the height of the current building, repeatedly pop from the stack.  This will result in one of two cases:\n        - Stack becomes empty, which means there is no greater or equal height building present to the right of the current building. Thus the view is not blocked, and we can append the current building index to the `answer` array.\n        - Stack is not empty, which means there is at least one greater or equal height building. Thus the view is blocked.\n    - Push the current building index into the stack.\n3. Since we traversed the input array from right to left, the building indices were added to `answer` in reverse order. Thus, before returning `answer`, we must reverse the `answer` array so that it is in ascending order.\n4. Return the array `answer`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/mLicgy43/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mLicgy43\"></iframe>\n\n**Complexity Analysis**\n\nHere $$N$$ is the size of the given array.\n\n* Time complexity: $$O(N)$$.    \n    - We iterate over the given array once.\n    - Each building's index can be pushed into and popped from the stack at most once, and both the operations take $$O(1)$$ time.\n    - The array is reversed at the end which takes $$O(N)$$ time.\n    - In Java, the copying of elements from the array list to an integer array in reverse order also takes $$O(N)$$ time.\n\n* Space complexity: $$O(N)$$.    \n    - An extra stack is created, which can take at most $$O(N)$$ space.\n    - In Java, in order to maintain a dynamic size array (since we don't know the size of the output array at the beginning), we created an extra Array List that supports fast $$O(1)$$ push operation. The Array List may contain at most $$N$$ elements.\n\n<br/>\n\n---\n\n#### Approach 3: Monotonic Stack Space Optimization\n\n**Intuition**\n\nIn the previous approach, we converted this problem into finding the next greater or equal element for each element in the array. If an element does not have a next greater or equal element, it means its view is not blocked.\n\nDo we really need to store all the greater or equal height buildings to the right of the current building in the stack?\nAs we iterated over the array from right to left, we pushed each building into the stack. Each building would remain in the stack until we reached a taller building. At which point, the shorter building would be popped from the stack. This means that the tallest building seen so far would always be in the stack unless the current building is the tallest building seen so far, in which case, the stack will be empty. Simply put, while traversing from right to left, the current building will only have an ocean view if it is the tallest building seen so far.\n\nTherefore, we can simplify the previous approach by traversing from right to left and just keep one variable to denote the tallest building seen so far. \nThen, if the current building's view is not blocked by the tallest building seen so far, the current building must have an ocean view. \nThus, we just need to track the maximum height building encountered so far while traversing from right to left.\n\n!?!../Documents/1762/slideshow3.json:960,540!?!\n\n**Algorithm**\n\n1. Initialize `maxHeight` to `-1`. It will store the maximum height of the buildings to the right of the current building.\n2. Iterate over the buildings array from right to left.\n    - If the current building is taller than `maxHeight`, then append its index to the `answer` array and update `maxHeight` with the current building's height.\n3. At the end, the `answer` array has the indices of the buildings that can see the ocean in descending order.\n4. Reverse the `answer` array (to make it in ascending order) and return it.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/RJMW437k/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"RJMW437k\"></iframe>\n\n\n**Complexity Analysis**\n\nHere $$N$$ is the size of the given array.\n\n* Time complexity: $$O(N)$$.    \n    - We iterate over the given array once, and for each building height, we perform a constant number of operations.\n    - The answer array is reversed at the end, which also takes $$O(N)$$ time.\n    - In Java, copying the elements from the array list to an integer array in reverse order also takes $$O(N)$$.\n\n* Space complexity: $$O(1)$$.    \n    - No auxiliary space was used other than for the output array.\n    - Although, in Java, in order to maintain a dynamic size array (since we don't know the size of the output array at the beginning), we created an extra Array List that supports fast $$O(1)$$ push operation. Array List can contain at most $$N$$ elements, hence for the Java solution, the space complexity is $$O(N)$$.\n\n<br/>\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1206",
            "count": 31,
            "average": "3.774",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "buildings-with-an-ocean-view",
    "playgroundData": {
        "APfNhXsL": {
            "playground": {
                "testcaseInput": "",
                "name": "buildings-with-an-ocean-view-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "mLicgy43": {
            "playground": {
                "testcaseInput": "",
                "name": "buildings-with-an-ocean-view-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "RJMW437k": {
            "playground": {
                "testcaseInput": "",
                "name": "buildings-with-an-ocean-view-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}