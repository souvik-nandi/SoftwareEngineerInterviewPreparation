{
    "id": "1360",
    "question": {
        "questionId": "1360",
        "questionFrontendId": "1239",
        "boundTopicId": null,
        "title": "Maximum Length of a Concatenated String with Unique Characters",
        "titleSlug": "maximum-length-of-a-concatenated-string-with-unique-characters",
        "content": "<p>You are given an array of strings <code>arr</code>. A string <code>s</code> is formed by the <strong>concatenation</strong> of a <strong>subsequence</strong> of <code>arr</code> that has <strong>unique characters</strong>.</p>\n\n<p>Return <em>the <strong>maximum</strong> possible length</em> of <code>s</code>.</p>\n\n<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> All the valid concatenations are:\n- &quot;&quot;\n- &quot;un&quot;\n- &quot;iq&quot;\n- &quot;ue&quot;\n- &quot;uniq&quot; (&quot;un&quot; + &quot;iq&quot;)\n- &quot;ique&quot; (&quot;iq&quot; + &quot;ue&quot;)\nMaximum length is 4.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Possible longest valid concatenations are &quot;chaers&quot; (&quot;cha&quot; + &quot;ers&quot;) and &quot;acters&quot; (&quot;act&quot; + &quot;ers&quot;).\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]\n<strong>Output:</strong> 26\n<strong>Explanation:</strong> The only string in arr has all 26 characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>\n\t<li><code>arr[i]</code> contains only lowercase English letters.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 1867,
        "dislikes": 159,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[\"un\",\"iq\",\"ue\"]\n[\"cha\",\"r\",\"act\",\"ers\"]\n[\"abcdefghijklmnopqrstuvwxyz\"]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"DiDi\", \"slug\": \"didi\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Honey\", \"slug\": \"honey\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Tesla\", \"slug\": \"tesla\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"American Express\", \"slug\": \"american-express\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int maxLength(vector<string>& arr) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int maxLength(List<String> arr) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def maxLength(self, arr):\n        \"\"\"\n        :type arr: List[str]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint maxLength(char ** arr, int arrSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MaxLength(IList<string> arr) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string[]} arr\n * @return {number}\n */\nvar maxLength = function(arr) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String[]} arr\n# @return {Integer}\ndef max_length(arr)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func maxLength(_ arr: [String]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func maxLength(arr []string) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def maxLength(arr: List[String]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun maxLength(arr: List<String>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn max_length(arr: Vec<String>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String[] $arr\n     * @return Integer\n     */\n    function maxLength($arr) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function maxLength(arr: string[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (max-length arr)\n  (-> (listof string?) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec max_length(Arr :: [unicode:unicode_binary()]) -> integer().\nmax_length(Arr) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec max_length(arr :: [String.t]) :: integer\n  def max_length(arr) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"110.7K\", \"totalSubmission\": \"219.2K\", \"totalAcceptedRaw\": 110740, \"totalSubmissionRaw\": 219205, \"acRate\": \"50.5%\"}",
        "hints": [
            "You can try all combinations and keep mask of characters you have.",
            "You can use DP."
        ],
        "solution": {
            "id": "1169",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"un\",\"iq\",\"ue\"]",
        "metaData": "{\n  \"name\": \"maxLength\",\n  \"params\": [\n    {\n      \"name\": \"arr\",\n      \"type\": \"list<string>\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1169",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n--- \r\n\r\n#### Approach 1: Iterative\r\n\r\n**Intuition**\r\n\r\nA brute force solution to this problem would entail creating all $$2^N$$ possible combinations of `arr` entries and checking each one for duplicate characters. The iterative solution improves upon the brute force solution by building the results up by adding one entry at a time, thus allowing us to immediately prune any potential new result and its subsequent branch of combinations if a duplicate character is found.\r\n\r\nTo do this, we initialize our `results` list with an empty string, which will be the base from which to build the subsequent branching results. From there, we can search for new valid results by iterating over each element in `arr` and attempting to append it to each of the prior results.\r\n\r\nAt this point, we need to be careful to only check the results that existed prior to the beginning of the current element of `arr`, as we will be adding new entries to `results` as we go. Otherwise, we would continue to attempt to append the current element to each of the results that were just made by using this element.\r\n\r\nFor each new potential result, we can check for duplicate characters by utilizing a set data structure and comparing the length of the potential result with the size of the set formed from its characters. If those values don't match, then there is a duplicate character in the potential result and the result should be discarded. Otherwise, we can add this validated result to our `results` list.\r\n\r\nIf necessary, we can then update the integer variable `best` which represents the longest valid result seen so far. Once we've fully iterated through all elements in `arr`, we can return `best` as our answer.\r\n\r\n**Algorithm**\r\n\r\n1. Initialize a `results` list with an empty string.\r\n2. Iterate through each entry in `arr`, and for each entry:\r\n   - Iterate through each entry in `results`, and for each entry:\r\n     - Form a new result combination.\r\n     - Check for duplicate characters with the use of a set.\r\n     - If the new result is valid, then add it to `results`.\r\n     - Keep track of the longest valid result so far in `best`.\r\n3. Return `best`.\r\n\r\n<iframe src=\"https://leetcode.com/playground/JNFCu9bG/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"JNFCu9bG\"></iframe>\r\n\r\n**Optimization**\r\n\r\nWhile relatively simple, the performance of the basic iterative solution leaves much to be desired. In particular, each attempted new result (which can occur up to $$2^N$$ times) requires first the concatenation of the new result string, then the creation of a new set from this string. This process requires multiple iterations through the result string's characters, which is greatly inefficient. This inefficiency can, however, be mostly overcome with the use **bit manipulation**.\r\n With bit manipulation, we can interact in multiple ways with an integer at the bit level. Since an integer contains 32-bits' worth of data, we can use bit manipulation to provide for more functionality than simply the storage of a single number in an integer.\r\n\r\nIn the case of this solution, we can use bit manipulation to store an entire **character bitset** in one integer. Essentially, we will use 26 of the 32 bits of the integer as boolean flags where each bit will be a 0 or a 1, depending on whether or not the corresponding letter of the alphabet is present. Each bit then corresponds to a letter of the alphabet (0 -> 'a' ... 25 -> 'z'). The remaining bits (26 through 31) will be unused.\r\n\r\n<div>\r\n    <div class=\"video-container\">\r\n        <iframe src=\"https://player.vimeo.com/video/591163103\" width=\"640\" height=\"272\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen></iframe>\r\n    </div>\r\n</div>\r\n\r\nTo accomplish this, we can use some common bit operations:\r\n - **Bitwise AND operator (`&`)** - Returns an integer in which each bit is a 1 *if and only if* the corresponding bits of both operands are 1s. For example (in binary), `10011001 & 10101010 = 10001000`.\r\n\r\n<div>\r\n    <div class=\"video-container\">\r\n        <iframe src=\"https://player.vimeo.com/video/591163046\" width=\"640\" height=\"311\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen></iframe>\r\n    </div>\r\n</div>\r\n\r\n - **Bitwise shift left (`<<`) and right (`>>`)** - Returns the integer formed by shifting each bit value of the operand the designated direction by the given number of positions. Any bits values that are shifted to the right of 0 are lost, and any bits that are vacated when shifting to the left are automatically 0s. For example (in binary), `10011001 << 3 = 10011001000` and `10011001 >> 3 = 10011`.\r\n\r\n<div>\r\n    <div class=\"video-container\">\r\n        <iframe src=\"https://player.vimeo.com/video/591163069\" width=\"640\" height=\"219\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen></iframe>\r\n    </div>\r\n</div>\r\n\r\nIn addition to these basic bitwise operations, we will also need to use a **bitmask**. A bitmask is simply an integer used to target or isolate a specific section of another integer, typically for reading or writing. Let's say that a partial portion of our character bitset is `110011`, which represents 'a', 'b', 'e', and 'f'. If we wanted to store a 'd', the first step would be to create a bitmask of the specific character using a bitwise shift operation. Since 'd' is the 3rd (0-indexed) bit, we can use `1 << 3 = 1000` as our bitmask. Then, as we're only changing 0s to 1s at this point, we can simply add the bitmask to our bitset (`110011 + 1000 = 111011`) to effectively add the letter 'd'.\r\n\r\nTo check if a single character is in a bitset, we could use the same bitmask method, but then use the bitwise AND operator to isolate and read the corresponding masked bit of the bitset to see if it is already a 1. For example, using the partial bitset `110011`, checking for a 'd' (`110011 & 1000`) evaluates to 0, while checking for an 'e' (`110011 & 10000`) evaluates to 10000. In this case, the result will be a 0 if the letter is not found and some non-zero number if the letter is found.\r\n\r\nIn order to avoid having to repeatedly evaluate each bitset to count the length of the result which it represents, we can instead choose to store the length of each bitset in our bitset integer. Since the maximum length of a valid result will be 26, this length data will consequently fit in 5 bits' worth of space (`$$2^5 = 32$$`), which is conveniently less than the 6 bits' worth of unused space in our bitset integer. To do this, we can shift the length number left, past the end of the character bitset data, before adding it to the bitset integer (`combined = (length << 26) + bitset`).\r\n\r\n<div>\r\n    <div class=\"video-container\">\r\n        <iframe src=\"https://player.vimeo.com/video/591163076\" width=\"640\" height=\"272\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen></iframe>\r\n    </div>\r\n</div>\r\n\r\nThis means that we'll have to then use more bit manipulation to isolate and read these two separate pieces of information in our bitset integer. To read the length data, we can simply shift the combined integer to the right by 26 places to drop off the entire bitset portion (`length = combined >> 26`).\r\n\r\nTo read just the bitset data instead, we'll first need to create a bitmask of the first 26 bits. This is easily accomplished by taking a 1, pushing it past the end of the intended section, then subtracting 1 (`(1 << 26) - 1`) which will result in a 1 in each of the first 26 bit positions. Then we can use this bitmask along with a bitwise AND operation to isolate and read the first 26 bits' worth of data from the combined integer (`bitset = combined & ((1 << 26) - 1)`).\r\n\r\nThe bitwise AND operator can also be used to quickly compare two entire character bitsets. Any duplicate letter found in both bitsets will result in a 1 somewhere in the resulting integer, which means that any non-zero number result indicates the presence of at least one duplicate letter. Also, as long as there are no overlapping (duplicate) character bits, we can simply add two complete bitsets together to get their union.\r\n\r\nThe other optimization that is made worthwhile with the use of bit manipulation is to initialize `results` as a **set** data structure instead of a basic list. When dealing with strings, for example, `\"abcde\"`, `\"edcba\"`, `\"aebdc\"`, and `\"cdbea\"` would all be considered different results, regardless of the fact that they're all functionally the same for the purposes of this solution because they all use the same set of distinct characters. When converted to their character bitset equivalents, each of those results (as well as many more) would resolve into the same value (`11111`). This enhances the effectiveness of using a set for our results collection to avoid duplicates entries, especially since this approach requires us to repeatedly iterate through the entirety of `results`.\r\n\r\nAdditionally, we can check to see if the character bitset already exists in `results` prior to attemping to combine it with each prior result. If it already exists in `results`, then any subsequent match would already have been made, so we can skip directly to the next element of `arr`.\r\n\r\n<iframe src=\"https://leetcode.com/playground/GJDB7J79/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"GJDB7J79\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(2^N)$$ where $$N$$ is the length of `arr`. With $$N$$ number of strings, there are $$2^N$$ possible combinations of strings. In reality, the optimizations should allow for a great deal of pruning, but the worst case scenario will still be $$O(2^N)$$. This qualification applies to the space complexity, as well.\r\n\r\n* Space complexity: $$O(2^{min(N,K)})$$ where $$K$$ is the number of distinct characters that appear in `arr`. The order of characters does not matter once we convert each word to its character bitset, and the `results` set prevents duplicate results, so there cannot be more than $$2^K$$ possible combinations of results, even if $$N$$ > $$K$$.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 2: Backtracking\r\n\r\n**Intuition**\r\n\r\nThe downside to using an iterative solution such as the one described in Approach 1 is that it requires the storage of an excessive amount of data in the results list. One common way to achieve the same kind of branching result-building that we need to accomplish for this solution is to use a backtracking approach.\r\n\r\nIn a backtracking approach, we perform a depth-first search (DFS) to build out one branch as far as it can go before backtracking to a previous state and attempting the next possible branch. This is done using a recursive function.\r\n\r\nIn the recursive backtracking function, we'll need to iterate through each remaining element of `arr`, update the current result state, recurse to the next position in `arr`, then backtrack the current result state.\r\n\r\nOur recursive function should also have a return value of the best length seen in the lower levels of the branch back up the recursive stack so that we can ultimately return the value generated by calling the initial instance of the function.\r\n\r\nIn order to make the process of updating and backtracking the current result state more efficient, we can use a map data structure (`resMap`) to store character counts. Any character count of more than 1 means that there are duplicates of that character, and the result is invalid.\r\n\r\nThe first thing we should do in our recursive function, then, is to check for duplicate characters by iterating through `resMap` and looking for values larger than 1. If the current result state is invalid we can return 0, otherwise we should initialize the starting value for our `best` result as the current size of `resMap`.\r\n\r\nNext, we should then iterate through each remaining position in `arr` and attempt to start a new branch from that position. This represents potentially skipping the elements in between the two positions (`pos` and `i`). At each iteration, we should add the new element's characters to `resMap` before calling our backtracking function at the following position. The result of this function call should be checked against the current `best` result seen so far and updated if necessary. Then we should backtrack `resMap` to its previous state by subtracting the current element's character counts from the counts stored in `resMap`.\r\n\r\nOnce we've finished iterating through the elements of `arr`, we can return the updated `best` result length back up the recursion stack.\r\n\r\n**Algorithm**\r\n\r\n1. Define a recursive depth first search function that will:\r\n   - Use a map data structure for the current result condition.\r\n   - Return 0 if duplicates characters exist in `resMap`.\r\n   - Initialize `best` with the current size of `resMap`.\r\n   - Iterate through each remaining entry in `arr`, and for each entry:\r\n     - Add the entry to `resMap` by updating the character counts.\r\n     - Recurse to the next position in `arr`.\r\n     - Update `best` with the returned value if necessary.\r\n     - Backtrack `resMap` to its previous state.\r\n   - Return `best`.\r\n2. Return the result of the DFS function starting at the beginning of `arr` with an empty `resMap`.\r\n\r\n<iframe src=\"https://leetcode.com/playground/haFXkvdj/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"haFXkvdj\"></iframe>\r\n\r\n**Optimization**\r\n\r\nThe backtracking solution can also benefit from the bit manipulation optimization method described in Approach 1. Since we're going to be using character bitsets, we can pre-process `arr` by passing its string elements through a helper function that will convert each element into its integer bitset before we call the recursive helper function.\r\n\r\nWhile we convert the words to bitsets, we can omit any elements that contain duplicate characters, and also use a set data structure to remove any element that transforms into a duplicate bitset of a previous element of `arr`. As the recursion process will take $$O(2^N)$$ time, any reduction in `N` will have a significant impact on the efficiency.\r\n\r\n<iframe src=\"https://leetcode.com/playground/4pt4mc7r/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4pt4mc7r\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(2^N)$$ where $$N$$ is the length of `arr`. With $$N$$ number of strings, there are $$2^N$$ possible combinations of strings. As with Approach 1, this represents the worst-case scenario, although there will typically be a significant amount of branch pruning with the optimizations in place.\r\n\r\n* Space complexity: $$O(N)$$ for `optSet`, `optArr`, and the max depth of the recursion stack.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 3: Recursion\r\n\r\n**Intuition**\r\n\r\nA slightly more basic approach compared to the backtracking solution seen in Approach 2 is a simple recursive solution. This approach remains more or less the same as the previous one, just without the need for backtracking. This does mean that it creates a new result for each recursive instance, which will increase the overall space used a bit, but this increase is fairly negligible, especially when paired with the further optimizations discussed later.\r\n\r\nWithout the need to backtrack, we can use a string as the current result, and then use a set data structure to check for duplicate characters, similar to Approach 1. As in Approach 2, each recursive function will iterate through the remaining positions and start new recursive branches at each. Instead of updating a common object, however, we'll simply create a new result string and pass it on to the next recursive level.\r\n\r\nThe real strength of this approach will be seen after we apply the optimizations in the next section.\r\n\r\n**Algorithm**\r\n\r\n1. Define a recursive depth first search function that will:\r\n   - Return 0 if duplicates characters exist in the current result condition (`res`).\r\n   - Initialize `best` with the current length of `res`.\r\n   - Iterate through each remaining entry in `arr`, and for each entry:\r\n     - Recurse to the next position in `arr` while adding the entry to `res`.\r\n     - Update `best` with the returned value if necessary.\r\n   - Return `best`.\r\n2. Return the result of the DFS function starting at the beginning of `arr` with an empty string for `res`.\r\n\r\n<iframe src=\"https://leetcode.com/playground/3349x8b6/shared\" frameBorder=\"0\" width=\"100%\" height=\"446\" name=\"3349x8b6\"></iframe>\r\n\r\n**Optimization**\r\n\r\nHere again we can use the bit manipulation optimization method described in Approach 1 to good effect. As the basic recursion solution is very similar to the backtracking one from Approach 2, we can also apply the same method of pre-processing `arr` by passing its string elements through a helper function to convert each element to its integer bitset before we call the recursive helper function.\r\n\r\nWhile we convert the words to bitsets, we can omit any elements that contain duplicate characters, and also use a set data structure to remove any element that transforms into a duplicate bitset of a previous element of `arr`. As the recursion process will take $$O(2^N)$$ time, any reduction in `N` will have a significant impact on the efficiency.\r\n\r\nThe use of bit manipulation to convert each element of `arr` into a character bitset stored in a single integer renders the main benefit of the Approach 2's backtracking solution unnecessary, since the entire state of the current result can be stored in a single integer as opposed to a 2-dimensional data structure. This in turn makes the simplified recursive solution described in this optimized approach the most efficient solution.\r\n\r\n<iframe src=\"https://leetcode.com/playground/LR32MjpN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"LR32MjpN\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(2^N)$$ where $$N$$ is the length of `arr`. With $$N$$ number of strings, there are $$2^N$$ possible combinations of strings. As with Approach 1, this represents the worst-case scenario, although there will typically be a significant amount of branch pruning with the optimizations in place.\r\n\r\n* Space complexity: $$O(N)$$ for `optSet`, `optArr`, and the max depth of the recursion stack.\r\n\r\n<br/>\r\n\r\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1174",
            "count": 25,
            "average": "4.480",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "maximum-length-of-a-concatenated-string-with-unique-characters",
    "playgroundData": {
        "JNFCu9bG": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-length-of-a-concatenated-string-with-unique-characters-5",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "GJDB7J79": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-length-of-a-concatenated-string-with-unique-characters-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "haFXkvdj": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-length-of-a-concatenated-string-with-unique-characters-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "4pt4mc7r": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-length-of-a-concatenated-string-with-unique-characters-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "3349x8b6": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-length-of-a-concatenated-string-with-unique-characters-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "LR32MjpN": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-length-of-a-concatenated-string-with-unique-characters-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}