{
    "id": "588",
    "question": {
        "questionId": "588",
        "questionFrontendId": "588",
        "boundTopicId": null,
        "title": "Design In-Memory File System",
        "titleSlug": "design-in-memory-file-system",
        "content": "<p>Design a data structure that simulates an in-memory file system.</p>\n\n<p>Implement the FileSystem class:</p>\n\n<ul>\n\t<li><code>FileSystem()</code> Initializes the object of the system.</li>\n\t<li><code>List&lt;String&gt; ls(String path)</code>\n\t<ul>\n\t\t<li>If <code>path</code> is a file path, returns a list that only contains this file&#39;s name.</li>\n\t\t<li>If <code>path</code> is a directory path, returns the list of file and directory names <strong>in this directory</strong>.</li>\n\t</ul>\n\tThe answer should in <strong>lexicographic order</strong>.</li>\n\t<li><code>void mkdir(String path)</code> Makes a new directory according to the given <code>path</code>. The given directory path does not exist. If the middle directories in the path do not exist, you should create them as well.</li>\n\t<li><code>void addContentToFile(String filePath, String content)</code>\n\t<ul>\n\t\t<li>If <code>filePath</code> does not exist, creates that file containing given <code>content</code>.</li>\n\t\t<li>If <code>filePath</code> already exists, appends the given <code>content</code> to original content.</li>\n\t</ul>\n\t</li>\n\t<li><code>String readContentFromFile(String filePath)</code> Returns the content in the file at <code>filePath</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/filesystem.png\" style=\"width: 650px; height: 315px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FileSystem&quot;, &quot;ls&quot;, &quot;mkdir&quot;, &quot;addContentToFile&quot;, &quot;ls&quot;, &quot;readContentFromFile&quot;]\n[[], [&quot;/&quot;], [&quot;/a/b/c&quot;], [&quot;/a/b/c/d&quot;, &quot;hello&quot;], [&quot;/&quot;], [&quot;/a/b/c/d&quot;]]\n<strong>Output</strong>\n[null, [], null, null, [&quot;a&quot;], &quot;hello&quot;]\n\n<strong>Explanation</strong>\nFileSystem fileSystem = new FileSystem();\nfileSystem.ls(&quot;/&quot;);                         // return []\nfileSystem.mkdir(&quot;/a/b/c&quot;);\nfileSystem.addContentToFile(&quot;/a/b/c/d&quot;, &quot;hello&quot;);\nfileSystem.ls(&quot;/&quot;);                         // return [&quot;a&quot;]\nfileSystem.readContentFromFile(&quot;/a/b/c/d&quot;); // return &quot;hello&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length,&nbsp;filePath.length &lt;= 100</code></li>\n\t<li><code>path</code> and <code>filePath</code>&nbsp;are absolute paths which begin with <code>&#39;/&#39;</code>&nbsp;and do not end with <code>&#39;/&#39;</code>&nbsp;except that the path is just&nbsp;<code>&quot;/&quot;</code>.</li>\n\t<li>You can assume that all directory names and file names only contain lowercase letters, and the same names will not exist in the same directory.</li>\n\t<li>You can assume that all operations will be passed valid parameters, and users will not attempt to retrieve file content or list a directory or file that does not exist.</li>\n\t<li><code>1 &lt;= content.length &lt;= 50</code></li>\n\t<li>At most <code>300</code> calls will be made to <code>ls</code>, <code>mkdir</code>,&nbsp;<code>addContentToFile</code>, and&nbsp;<code>readContentFromFile</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Hard",
        "likes": 1160,
        "dislikes": 131,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"LRU Cache\", \"titleSlug\": \"lru-cache\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"LFU Cache\", \"titleSlug\": \"lfu-cache\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Design Log Storage System\", \"titleSlug\": \"design-log-storage-system\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[\"FileSystem\",\"ls\",\"mkdir\",\"addContentToFile\",\"ls\",\"readContentFromFile\"]\n[[],[\"/\"],[\"/a/b/c\"],[\"/a/b/c/d\",\"hello\"],[\"/\"],[\"/a/b/c/d\"]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Design",
                "slug": "design",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Trie",
                "slug": "trie",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Citadel\", \"slug\": \"citadel\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Baidu\", \"slug\": \"baidu\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Coinbase\", \"slug\": \"coinbase\", \"timesEncountered\": 30}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 18}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 9}, {\"taggedByAdmin\": false, \"name\": \"DoorDash\", \"slug\": \"doordash\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Tesla\", \"slug\": \"tesla\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class FileSystem {\npublic:\n    FileSystem() {\n        \n    }\n    \n    vector<string> ls(string path) {\n        \n    }\n    \n    void mkdir(string path) {\n        \n    }\n    \n    void addContentToFile(string filePath, string content) {\n        \n    }\n    \n    string readContentFromFile(string filePath) {\n        \n    }\n};\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem* obj = new FileSystem();\n * vector<string> param_1 = obj->ls(path);\n * obj->mkdir(path);\n * obj->addContentToFile(filePath,content);\n * string param_4 = obj->readContentFromFile(filePath);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public List<String> ls(String path) {\n        \n    }\n    \n    public void mkdir(String path) {\n        \n    }\n    \n    public void addContentToFile(String filePath, String content) {\n        \n    }\n    \n    public String readContentFromFile(String filePath) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * List<String> param_1 = obj.ls(path);\n * obj.mkdir(path);\n * obj.addContentToFile(filePath,content);\n * String param_4 = obj.readContentFromFile(filePath);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class FileSystem(object):\n\n    def __init__(self):\n        \n\n    def ls(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: List[str]\n        \"\"\"\n        \n\n    def mkdir(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: None\n        \"\"\"\n        \n\n    def addContentToFile(self, filePath, content):\n        \"\"\"\n        :type filePath: str\n        :type content: str\n        :rtype: None\n        \"\"\"\n        \n\n    def readContentFromFile(self, filePath):\n        \"\"\"\n        :type filePath: str\n        :rtype: str\n        \"\"\"\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.ls(path)\n# obj.mkdir(path)\n# obj.addContentToFile(filePath,content)\n# param_4 = obj.readContentFromFile(filePath)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class FileSystem:\n\n    def __init__(self):\n        \n\n    def ls(self, path: str) -> List[str]:\n        \n\n    def mkdir(self, path: str) -> None:\n        \n\n    def addContentToFile(self, filePath: str, content: str) -> None:\n        \n\n    def readContentFromFile(self, filePath: str) -> str:\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.ls(path)\n# obj.mkdir(path)\n# obj.addContentToFile(filePath,content)\n# param_4 = obj.readContentFromFile(filePath)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n\ntypedef struct {\n    \n} FileSystem;\n\n\nFileSystem* fileSystemCreate() {\n    \n}\n\nchar ** fileSystemLs(FileSystem* obj, char * path, int* retSize) {\n  \n}\n\nvoid fileSystemMkdir(FileSystem* obj, char * path) {\n  \n}\n\nvoid fileSystemAddContentToFile(FileSystem* obj, char * filePath, char * content) {\n  \n}\n\nchar * fileSystemReadContentFromFile(FileSystem* obj, char * filePath) {\n  \n}\n\nvoid fileSystemFree(FileSystem* obj) {\n    \n}\n\n/**\n * Your FileSystem struct will be instantiated and called as such:\n * FileSystem* obj = fileSystemCreate();\n * char ** param_1 = fileSystemLs(obj, path, retSize);\n \n * fileSystemMkdir(obj, path);\n \n * fileSystemAddContentToFile(obj, filePath, content);\n \n * char * param_4 = fileSystemReadContentFromFile(obj, filePath);\n \n * fileSystemFree(obj);\n*/",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public IList<string> Ls(string path) {\n        \n    }\n    \n    public void Mkdir(string path) {\n        \n    }\n    \n    public void AddContentToFile(string filePath, string content) {\n        \n    }\n    \n    public string ReadContentFromFile(string filePath) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * IList<string> param_1 = obj.Ls(path);\n * obj.Mkdir(path);\n * obj.AddContentToFile(filePath,content);\n * string param_4 = obj.ReadContentFromFile(filePath);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "\nvar FileSystem = function() {\n    \n};\n\n/** \n * @param {string} path\n * @return {string[]}\n */\nFileSystem.prototype.ls = function(path) {\n    \n};\n\n/** \n * @param {string} path\n * @return {void}\n */\nFileSystem.prototype.mkdir = function(path) {\n    \n};\n\n/** \n * @param {string} filePath \n * @param {string} content\n * @return {void}\n */\nFileSystem.prototype.addContentToFile = function(filePath, content) {\n    \n};\n\n/** \n * @param {string} filePath\n * @return {string}\n */\nFileSystem.prototype.readContentFromFile = function(filePath) {\n    \n};\n\n/** \n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "class FileSystem\n    def initialize()\n        \n    end\n\n\n=begin\n    :type path: String\n    :rtype: String[]\n=end\n    def ls(path)\n        \n    end\n\n\n=begin\n    :type path: String\n    :rtype: Void\n=end\n    def mkdir(path)\n        \n    end\n\n\n=begin\n    :type file_path: String\n    :type content: String\n    :rtype: Void\n=end\n    def add_content_to_file(file_path, content)\n        \n    end\n\n\n=begin\n    :type file_path: String\n    :rtype: String\n=end\n    def read_content_from_file(file_path)\n        \n    end\n\n\nend\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem.new()\n# param_1 = obj.ls(path)\n# obj.mkdir(path)\n# obj.add_content_to_file(file_path, content)\n# param_4 = obj.read_content_from_file(file_path)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "\nclass FileSystem {\n\n    init() {\n        \n    }\n    \n    func ls(_ path: String) -> [String] {\n        \n    }\n    \n    func mkdir(_ path: String) {\n        \n    }\n    \n    func addContentToFile(_ filePath: String, _ content: String) {\n        \n    }\n    \n    func readContentFromFile(_ filePath: String) -> String {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem()\n * let ret_1: [String] = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath, content)\n * let ret_4: String = obj.readContentFromFile(filePath)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "type FileSystem struct {\n    \n}\n\n\nfunc Constructor() FileSystem {\n    \n}\n\n\nfunc (this *FileSystem) Ls(path string) []string {\n    \n}\n\n\nfunc (this *FileSystem) Mkdir(path string)  {\n    \n}\n\n\nfunc (this *FileSystem) AddContentToFile(filePath string, content string)  {\n    \n}\n\n\nfunc (this *FileSystem) ReadContentFromFile(filePath string) string {\n    \n}\n\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Ls(path);\n * obj.Mkdir(path);\n * obj.AddContentToFile(filePath,content);\n * param_4 := obj.ReadContentFromFile(filePath);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "class FileSystem() {\n\n    def ls(path: String): List[String] = {\n        \n    }\n\n    def mkdir(path: String) {\n        \n    }\n\n    def addContentToFile(filePath: String, content: String) {\n        \n    }\n\n    def readContentFromFile(filePath: String): String = {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class FileSystem() {\n\n    fun ls(path: String): List<String> {\n        \n    }\n\n    fun mkdir(path: String) {\n        \n    }\n\n    fun addContentToFile(filePath: String, content: String) {\n        \n    }\n\n    fun readContentFromFile(filePath: String): String {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "struct FileSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl FileSystem {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn ls(&self, path: String) -> Vec<String> {\n        \n    }\n    \n    fn mkdir(&self, path: String) {\n        \n    }\n    \n    fn add_content_to_file(&self, file_path: String, content: String) {\n        \n    }\n    \n    fn read_content_from_file(&self, file_path: String) -> String {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem::new();\n * let ret_1: Vec<String> = obj.ls(path);\n * obj.mkdir(path);\n * obj.add_content_to_file(filePath, content);\n * let ret_4: String = obj.read_content_from_file(filePath);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class FileSystem {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @return String[]\n     */\n    function ls($path) {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @return NULL\n     */\n    function mkdir($path) {\n        \n    }\n  \n    /**\n     * @param String $filePath\n     * @param String $content\n     * @return NULL\n     */\n    function addContentToFile($filePath, $content) {\n        \n    }\n  \n    /**\n     * @param String $filePath\n     * @return String\n     */\n    function readContentFromFile($filePath) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * $obj = FileSystem();\n * $ret_1 = $obj->ls($path);\n * $obj->mkdir($path);\n * $obj->addContentToFile($filePath, $content);\n * $ret_4 = $obj->readContentFromFile($filePath);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "class FileSystem {\n    constructor() {\n\n    }\n\n    ls(path: string): string[] {\n\n    }\n\n    mkdir(path: string): void {\n\n    }\n\n    addContentToFile(filePath: string, content: string): void {\n\n    }\n\n    readContentFromFile(filePath: string): string {\n\n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define file-system%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; ls : string? -> (listof string?)\n    (define/public (ls path)\n\n      )\n    ; mkdir : string? -> void?\n    (define/public (mkdir path)\n\n      )\n    ; add-content-to-file : string? string? -> void?\n    (define/public (add-content-to-file file-path content)\n\n      )\n    ; read-content-from-file : string? -> string?\n    (define/public (read-content-from-file file-path)\n\n      )))\n\n;; Your file-system% object will be instantiated and called as such:\n;; (define obj (new file-system%))\n;; (define param_1 (send obj ls path))\n;; (send obj mkdir path)\n;; (send obj add-content-to-file file-path content)\n;; (define param_4 (send obj read-content-from-file file-path))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec file_system_init_() -> any().\nfile_system_init_() ->\n  .\n\n-spec file_system_ls(Path :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nfile_system_ls(Path) ->\n  .\n\n-spec file_system_mkdir(Path :: unicode:unicode_binary()) -> any().\nfile_system_mkdir(Path) ->\n  .\n\n-spec file_system_add_content_to_file(FilePath :: unicode:unicode_binary(), Content :: unicode:unicode_binary()) -> any().\nfile_system_add_content_to_file(FilePath, Content) ->\n  .\n\n-spec file_system_read_content_from_file(FilePath :: unicode:unicode_binary()) -> unicode:unicode_binary().\nfile_system_read_content_from_file(FilePath) ->\n  .\n\n\n%% Your functions will be called as such:\n%% file_system_init_(),\n%% Param_1 = file_system_ls(Path),\n%% file_system_mkdir(Path),\n%% file_system_add_content_to_file(FilePath, Content),\n%% Param_4 = file_system_read_content_from_file(FilePath),\n\n%% file_system_init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule FileSystem do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec ls(path :: String.t) :: [String.t]\n  def ls(path) do\n\n  end\n\n  @spec mkdir(path :: String.t) :: any\n  def mkdir(path) do\n\n  end\n\n  @spec add_content_to_file(file_path :: String.t, content :: String.t) :: any\n  def add_content_to_file(file_path, content) do\n\n  end\n\n  @spec read_content_from_file(file_path :: String.t) :: String.t\n  def read_content_from_file(file_path) do\n\n  end\nend\n\n# Your functions will be called as such:\n# FileSystem.init_()\n# param_1 = FileSystem.ls(path)\n# FileSystem.mkdir(path)\n# FileSystem.add_content_to_file(file_path, content)\n# param_4 = FileSystem.read_content_from_file(file_path)\n\n# FileSystem.init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"72K\", \"totalSubmission\": \"148.4K\", \"totalAcceptedRaw\": 72023, \"totalSubmissionRaw\": 148442, \"acRate\": \"48.5%\"}",
        "hints": [],
        "solution": {
            "id": "142",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"FileSystem\",\"ls\",\"mkdir\",\"addContentToFile\",\"ls\",\"readContentFromFile\"]\n[[],[\"/\"],[\"/a/b/c\"],[\"/a/b/c/d\",\"hello\"],[\"/\"],[\"/a/b/c/d\"]]",
        "metaData": "{\r\n    \"classname\": \"FileSystem\",\r\n    \"maxbytesperline\": 200000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n        ]\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"ls\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"string\",\r\n                    \"name\": \"path\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"list<string>\"\r\n            }\r\n        },\r\n        {\r\n            \"name\" : \"mkdir\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"string\",\r\n                    \"name\": \"path\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            }\r\n        },\r\n        {\r\n            \"name\" : \"addContentToFile\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"string\",\r\n                    \"name\": \"filePath\"\r\n                },\r\n                {\r\n                    \"type\": \"string\",\r\n                    \"name\": \"content\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            }\r\n        },\r\n        {\r\n            \"name\" : \"readContentFromFile\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"string\",\r\n                    \"name\": \"filePath\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"string\"\r\n            }\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "793",
            "date": "2022-01-08",
            "incompleteChallengeCount": 25,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "142",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Approach #1 Using separate Directory and File List[Accepted]\n\nWe start our discussion by looking at the directory structure used. The root directory acts as the base of the directory structure. Each directory contains two hashmaps namely $$dirs$$ and $$files$$. The $$dirs$$ contains data in the form $$[(subdirectory_1\\_name: subdirectory_{1\\_structure}), (subdirectory_2\\_name: subdirectory_{2\\_structure})...]$$. The $$files$$ contains data in the form $$[(file_1: file_{1\\_contents}), (file_2: file_{2\\_contents})...]$$. This directory structure is shown below with a sample showing just the first two levels.\n\n![Design_Memory](../Figures/588_Design_In_Memory.PNG)\n\nNow, we'll discuss how we implement the various commands required.\n\n1. `ls`: In this case, we start off by initializing $$t$$, a temporary directory pointer, to the root directory. We split the input directory path based on `/` and obtain the individual levels of directory names in a $$d$$ array. Then, we traverse over the tree directory structure based on the individual directories found and we keep on updating the $$t$$ directory pointer to point to the new level of directory(child) as we go on entering deeper into the directory structure. At the end, we will stop at either the end level directory or at the file name depending upon the input given. If the last level in the input happens to be a file name, we simply need to return the file name. So, we directly return the last entry in the $$d$$ array. If the last level entry happens to be a directory, we can obtain its subdirectory list from the list of keys in its $$dirs$$ hashmap. Similarly, we can obtain the list of files in the last directory from the keys in the corresponding $$files$$ hashmap. We append the two lists obtained, sort them and return the sorted appended list.\n\n2. `mkdir`: In response to this command, as in case of `ls`, we start entering the directory structure level by level. Whenever we reach a state where a directory mentioned in the path of `mkdir` doesn't exist, we create a new entry in the last valid directory's $$dirs$$ structure and initialize its subdirectory list as an empty list. We keep on doing so till we reach the end level directory.\n\n3. `addContentToFile`: In response to this command as well, as in case of `ls`, we start entering the directory structure level by  level. When we reach the level of the file name, we check if the file name already exists in the $$files$$ keys. If it exists, we concatenate the current contents to the contents of the file(in the value section of the corresponding file). If it doesn't exist, we create a new entry in the current directory's $$files$$ and initialize its contents with the current contents.\n\n4. `readContentFromFile`: As the previous cases, we reach the last directory level by traversing through the directory structure level by level. Then, in the last directory, we search for the file name entry in the corresponding $$files$$' keys  and return its corresponding value as the contents of the file.\n\n<iframe src=\"https://leetcode.com/playground/EUzUEgvo/shared\" frameBorder=\"0\" name=\"EUzUEgvo\" width=\"100%\" height=\"515\"></iframe>\n\n**Performance Analysis**\n\n* The time complexity of executing an `ls` command is $$O\\big(m+n+klog(k)\\big)$$. Here, $$m$$ refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. $$n$$ refers to the depth of the last directory level in the given input for `ls`. This factor is taken because we need to enter $$n$$ levels of the tree structure to reach the last level. $$k$$ refers to the number of entries(files+subdirectories) in the last level directory(in the current input). We need to sort these names giving a factor of $$klog(k)$$.\n\n* The time complexity of executing an `mkdir` command is $$O(m+n)$$. Here, $$m$$ refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. $$n$$ refers to the depth of the last directory level in the `mkdir` input. This factor is taken because we need to enter $$n$$ levels of the tree structure to reach the last level.\n\n* The time complexity of both `addContentToFile` and `readContentFromFile` is $$O(m+n)$$. Here, $$m$$ refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. $$n$$ refers to the depth of the file name in the current input. This factor is taken because we need to enter $$n$$ levels of the tree structure to reach the level where the files's contents need to be added/read from.\n\n* The advantage of this scheme of maintaining the directory structure is that it is expandable to include even more commands easily. For example, `rmdir` to remove a directory given an input directory path. We need to simply reach to the destined directory level and remove the corresponding directory entry from the corresponding $$dirs$$ keys.\n\n* Renaming files/directories is also very simple, since all we need to do is to create a temporary copy of the directory structure/file with a new name and delete the last entry.\n\n* Relocating a hierarchichal subdirectory structure from one directory to the other is also very easy, since, all we need to do is obtain the address for the corresponding subdirectory class, and assign the same at the new positon in the new directory structure.\n\n* Extracting only directories or files list on any path is easy in this case, since we maintain separate entires for $$dirs$$ and $$files$$.\n\n---\n\n#### Approach #2 Using unified Directory and File List[Accepted]\n\nThis design differs from the first design in that the current data structure for a Directory contains a unified $$files$$ hashmap, which contains the list of all the files and subdirectories in the current directory. Apart from this, we contain an entry $$isfile$$, which when True indicates that the current $$files$$ entry is actually corresponding to a file, otherwise it represents a directory. Further, since we are considering the directory and files' entries in the same manner, we need an entry for $$content$$, which contains the contents of the current file(if $$isfile$$ entry is True in the current case). For entries corresponding to directories, the $$content$$ field is kept empty.\n\nThe following figure shows the directory structure for the same example as in the case above, for the first two levels of the hierarchical structure. \n\n![Design_In_Memory](../Figures/588_Design_In_Memory_3.PNG)\n\n\nThe implementation of all the commands remains the same as in the last design, except that we need to make entries in the same $$files$$ hashmap for both files and directories, corresponding to `addContentToFile` and `mkdir` respectively. Further, for `ls`, we need not extract entries separately for the files and directories, since they are unified in the current case, and can be obtained in a single go.\n\nThis approach is inspired by [@shawngao](http://leetcode.com/shwangao)\n\n<iframe src=\"https://leetcode.com/playground/a7jiya7b/shared\" frameBorder=\"0\" name=\"a7jiya7b\" width=\"100%\" height=\"515\"></iframe>\n\n\n**Performance Analysis**\n\n* The time complexity of executing an `ls` command is $$O\\big(m+n+klog(k)\\big)$$. Here, $$m$$ refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. $$n$$ refers to the depth of the last directory level in the given input for `ls`. This factor is taken because we need to enter $$n$$ levels of the tree structure to reach the last level. $$k$$ refers to the number of entries(files+subdirectories) in the last level directory(in the current input). We need to sort these names giving a factor of $$klog(k)$$.\n\n* The time complexity of executing an `mkdir` command is $$O(m+n)$$. Here, $$m$$ refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. $$n$$ refers to the depth of the last directory level in the `mkdir` input. This factor is taken because we need to enter $$n$$ levels of the tree structure to reach the last level.\n\n* The time complexity of both `addContentToFile` and `readContentFromFile` is $$O(m+n)$$. Here, $$m$$ refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. $$n$$ refers to the depth of the file name in the current input. This factor is taken because we need to enter $$n$$ levels of the tree structure to reach the level where the files's contents need to be added/read from.\n\n* The advantage of this scheme of maintaining the directory structure is that it is expandable to include even more commands easily. For example, `rmdir` to remove a directory given an input directory path. We need to simply reach to the destined directory level and remove the corresponding directory entry from the corresponding $$dirs$$ keys.\n\n* Renaming files/directories is also very simple, since all we need to do is to create a temporary copy of the directory structure/file with a new name and delete the last entry.\n\n* Relocating a hierarchichal subdirectory structure from one directory to the other is also very easy, since, all we need to do is obtain the address for the corresponding subdirectory class, and assign the same at the new positon in the new directory structure.\n\n* If the number of directories is very large, we waste redundant space for $$isfile$$ and $$content$$, which wasn't needed in the first design.\n\n* A problem with the current design could occur if we want to list only the directories(and not the files), on any given path. In this case, we need to traverse over the whole contents of the current directory, check for each entry, whether it is a file or a directory, and then extract the required data.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "137",
            "count": 79,
            "average": "4.899",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "design-in-memory-file-system",
    "playgroundData": {
        "EUzUEgvo": {
            "playground": {
                "testcaseInput": "",
                "name": "588_design_in_memory_filemd2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "a7jiya7b": {
            "playground": {
                "testcaseInput": "",
                "name": "588_design_in_memory_filemd1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}