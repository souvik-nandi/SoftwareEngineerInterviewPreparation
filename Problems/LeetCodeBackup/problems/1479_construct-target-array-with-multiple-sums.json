{
    "id": "1479",
    "question": {
        "questionId": "1479",
        "questionFrontendId": "1354",
        "boundTopicId": null,
        "title": "Construct Target Array With Multiple Sums",
        "titleSlug": "construct-target-array-with-multiple-sums",
        "content": "<p>You are given an array <code>target</code> of n integers. From a starting array <code>arr</code> consisting of <code>n</code> 1&#39;s, you may perform the following procedure :</p>\n\n<ul>\n\t<li>let <code>x</code> be the sum of all elements currently in your array.</li>\n\t<li>choose index <code>i</code>, such that <code>0 &lt;= i &lt; n</code> and set the value of <code>arr</code> at index <code>i</code> to <code>x</code>.</li>\n\t<li>You may repeat this procedure as many times as needed.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if it is possible to construct the</em> <code>target</code> <em>array from</em> <code>arr</code><em>, otherwise, return</em> <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [9,3,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Start with arr = [1, 1, 1] \n[1, 1, 1], sum = 3 choose index 1\n[1, 3, 1], sum = 5 choose index 2\n[1, 3, 5], sum = 9 choose index 0\n[9, 3, 5] Done\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [1,1,1,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Impossible to create target array from [1,1,1,1].\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [8,5]\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 1864,
        "dislikes": 149,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Minimum Amount of Time to Fill Cups\", \"titleSlug\": \"minimum-amount-of-time-to-fill-cups\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "exampleTestcases": "[9,3,5]\n[1,1,1,2]\n[8,5]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Quora\", \"slug\": \"quora\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"2\": [], \"3\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    bool isPossible(vector<int>& target) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public boolean isPossible(int[] target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def isPossible(self, target):\n        \"\"\"\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nbool isPossible(int* target, int targetSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public bool IsPossible(int[] target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} target\n * @return {boolean}\n */\nvar isPossible = function(target) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} target\n# @return {Boolean}\ndef is_possible(target)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func isPossible(_ target: [Int]) -> Bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func isPossible(target []int) bool {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def isPossible(target: Array[Int]): Boolean = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun isPossible(target: IntArray): Boolean {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn is_possible(target: Vec<i32>) -> bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $target\n     * @return Boolean\n     */\n    function isPossible($target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function isPossible(target: number[]): boolean {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (is-possible target)\n  (-> (listof exact-integer?) boolean?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec is_possible(Target :: [integer()]) -> boolean().\nis_possible(Target) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec is_possible(target :: [integer]) :: boolean\n  def is_possible(target) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"60.3K\", \"totalSubmission\": \"166K\", \"totalAcceptedRaw\": 60285, \"totalSubmissionRaw\": 165964, \"acRate\": \"36.3%\"}",
        "hints": [
            "Given that the sum is strictly increasing, the largest element in the target must be formed in the last step by adding the total sum in the previous step. Thus, we can simulate the process in a reversed way.",
            "Subtract the largest with the rest of the array, and put the new element into the array. Repeat until all elements become one"
        ],
        "solution": {
            "id": "878",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[9,3,5]",
        "metaData": "{\n  \"name\": \"isPossible\",\n  \"params\": [\n    {\n      \"name\": \"target\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"boolean\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "959",
            "date": "2022-06-24",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "878",
        "content": "[TOC]\n\n## Solution\n\n#### Approach 1: Working Backward\n\n**Intuition**\n\nLet $$n$$ be the *length of the target array*.\n\nFirstly, we know that if $$n = 1$$, then the sum of the array is always `1`, and therefore it is impossible for it to ever change from `[1]`. This means that the only target array with $$n = 1$$ that is possible to solve is `[1]` itself. Any others, for example, `[2]`, `[12]`, and `[18329832]` must be impossible. Depending on how you code your algorithm, you might or might not have to deal with this *edge case* explicitly.  \n\nNow, how about when $$n \u2265 2$$?\n\nA natural place to start might be to begin with an array of length $$n$$, containing all `1`s, and to attempt to get to the target array.\n\nLet's have a go at doing that. Say our target array is `[13, 7, 1, 43]`.\n\nWe would start with an array of `[1, 1, 1, 1]`. At each step, we compute the sum of all elements in the array, and choose one of the numbers to replace with the sum, as per the problem statement.\n\nFor example, for the first step, the options we have are `[4, 1, 1, 1]`, `[1, 4, 1, 1]`, `[1, 1, 4, 1]`, and `[1, 1, 1, 4]`.\n\nFor each of these, we then have two options: replacing the `4` with a `7 ` (`1 + 1 + 1 + 4 = 7`) or replacing a `1` with a `7`. \n\nFor example, the next possible steps for `[4, 1, 1, 1]` are `[7, 1, 1, 1]`, `[7, 4, 1, 1]`, `[7, 1, 4, 1]` and `[7, 1, 1, 4]`. \n\nAs you can probably see, this branches out really, really fast.\n\n![The exponential explosion of working forwards.](../Figures/1354/exponential_explosion.png)\n\nIt's not obvious which path might lead us to the target array.\n\nHow about the strategy of trying to get each number one-by-one, starting with the smallest? For example, when we had `[1, 7, 1, 1]`, perhaps we could say that two slots are correct, and we just need to get the other two without changing the two that are correct?\n\nThe only option now is to replace one of the others with `10` (`1 + 7 + 1 + 1 = 10`). That gives us `[10, 7, 1, 1]`.\n\nBut what happens next? `10 + 7 + 1 + 1 = 19`. This is higher than `13`.\n\nIt is now impossible to get a `13`. The sums are *strictly increasing* (as long as $$n  \u2265 2$$), i.e. each step's sum will always be larger than the last. Therefore, we definitely won't get the target array following this approach. The reason we know it's *strictly increasing* is because at each step, we're always making one number *larger*.\n\nYou may now be tempted to conclude that the target `[13, 7, 1, 43]` is *impossible* to reach. However, this is not the case. Here's the way that you can construct it!\n\n```\n[1,  1, 1, 1]\n[4,  1, 1, 1]\n[4,  7, 1, 1]\n[13, 7, 1, 1]\n[13, 7, 1, 22]\n[13, 7, 1, 43]\n```\n\nAs a side note (not needed for interviews, but aimed at the math lovers here), I'm not aware of a *greedy* approach that could go from the array of `1`s **up to** the target. It seems any such approach would be intractable. However, I haven't been able to *prove* this, so it's very possible there is indeed a way. If you know of one, please do let us know in the comments because I really am curious!\n\n*We will, therefore, need a better strategy!*\n\nIf trying to calculate the result working forward doesn't work, sometimes working backward does. Let's have a go at working backward, i.e. going from `[13, 7, 1, 43]` to `[1, 1, 1, 1]`. \n\nLet's think carefully about what number had to be put into the target array *last*. Could it have, for example, possibly been `13`? If it was indeed the `13`, then our previous array went from `[x, 7, 1, 43]` to `[13, 7, 1, 43]`. We would then just need to figure out what `x` is, which should be simple, as we know `13 = x + 7 + 1 + 43`. Rearranging, we get `x = 13 - 7 - 1 - 43`. Therefore, `x = -38`. \n\nThis can't be right though! We know that the array *always* contains positive numbers only (refer back to where we determined that the sums for each step are strictly increasing). Therefore, it could not have been `13`.\n\nIn fact, the only valid possibility is that the last was the largest number: `43`. Otherwise, `43` would have to be part of the sum, forcing the resulting sum to be greater than`43` (assuming $$n \u2265 2$$).\n\nSo now that we know it has to have been the `43`, we know that `43 = 13 + 7 + 1 + x`. Therefore, `x = 22`.\n\nSo we have `[13, 7, 1, 22] \u2192 [13, 7, 1, 43]` (look at the list a bit above, this is indeed the last transition!)\n\nSeeing as we know we can go from `[13, 7, 1, 22]` directly to the target, and because there is only one valid way of going up to the target (recall that we *had* to change the largest), we now only need to consider how we can get from `[1, 1, 1, 1]` up to `[13, 7, 1, 22]`. In other words, we can now treat `[13, 7, 1, 22]` as the *target*.\n\nAnd therefore, we can repeat the same process again! Here is an animation of that.\n\n!?!../Documents/1354_valid_case_animation.json:960,180!?!\n\nSomething quite interesting we can infer here is that the steps to get from an array of `1`s to a target *has to be unique*. In other words, there is only *one* way to get to the target (as there's only one way of changing the largest each step).\n\nTherefore, we can conclude that *the target array is reachable (from an array of `1`s) **if and only if** this unique chain can be derived by working backward.*\n\nIf a target array is not reachable, then the above approach has to *not* reduce it to an array of `1`s. So, what would it do?\n\nAs long as $$n \u2265 2$$, it can't get stuck in an infinite loop. We know this because the sums *strictly increase*. That only leaves the possibility of it going to numbers *below* `1`.\n\nSo our algorithm should check at each step that the array is *valid*, i.e. contains only numbers that are greater than or equal to `1`.\n\nFor reference, here is an animation of a target that is *not* possible to construct.\n\n!?!../Documents/1354_invalid_case_animation.json:960,180!?!\n\n**Algorithm**\n\nA key thing to recognise is that order doesn't matter. In other words, if we know that `[13, 7, 1, 43]` has a solution, then we also know that `[43, 13, 7, 1]` has a solution.\n\nTherefore, the problem reduces to converting all of the input numbers to `1`. Because at each step we always needed to replace the maximum, we should use a data structure that allows us to efficiently find the maximum after each change. Hopefully you've realised that the perfect data structure for the job is a `max-heap`!\n\nWe need to keep track of the current sum. This can be done by calculating the sum at the start, and then updating it as we change values (push and pop from heap).\n\nThen, while the top of the `max-heap` is greater than 1, we \"solve for x\" (see intuition above), and then replace the maximum with `x`, as long as that `x` is not negative. If it is less than 1, then we return `false`. Once the max is equal to 1, this means everything else has to be 1 too, and so we can return `true`.\n\n<iframe src=\"https://leetcode.com/playground/znrdm4V5/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"znrdm4V5\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of the target array. Let $$k$$ be the *maximum* of the target array.\n\n- Time Complexity : $$O(n + k \\, \\log \\, n)$$.\n\n    Making the initial heap is $$O(n)$$. \n\n    Then, each heap operation (add and remove) is $$O(\\log \\, n)$$. \n\n    The $$k$$ comes from the cost of reducing the largest item. In the worst case, it is massive. For example, consider a target of `[1, 1_000_000_000]`. One step of the algorithm will reduce it to `[1, 999_999_999]`. And the next is `[1, 999_999_998]`. You probably see where this is going. \n\n    Because we don't know whether $$n$$ or $$k \\, \\log \\, n$$ is larger, we add them.\n\n    While for this problem, we're told the maximum possible value in the array is `1,000,000,000`, we don't consider these limits for big-oh notation. Because the time taken varies with the maximum number, we consider this time complexity to be [**pseudo-polynomial**](https://en.wikipedia.org/wiki/Pseudo-polynomial_time). For the `[1, 1_000_000_000]` case, it is unworkably slow on any typical computer. \n\n- Space Complexity : $$O(n)$$.\n\n    The heap requires $$O(n)$$ extra space. There are always $$n$$ or $$n-1$$ items on the heap at any one time.\n\n    $$O(1)$$ space would be possible, by converting the target array directly into a heap. The Python code does this, although the line we used to make the target array negative is \"technically\" $$O(n)$$ (some Python interpreters might delete and replace this with an $$O(1)$$ operation behind the scenes). If space was a big issue (it isn't generally), then it's useful to know that these optimizations are at least *possible*.\n    \nThe fact that this algorithm is **pseudo-polynomial**, and has to cope with large $$n$$ values, and extremely large $$k$$ values is a big limitation. Luckily there are a few tweaks we can make to the algorithm that will make it **polynomial**.\n\n</br>\n\n---\n\n#### Approach 2: Working Backward with Optimizations\n\n**Intuition**\n\nIf you got Approach 1 working, but failed on large test cases, you're still doing really well to have gotten that far. A lot of people find these final optimizations really difficult, so always remember during interviews that your performance is *compared to other candidates*. This is one of the harder \"hard\" questions, especially for those with a limited background in mathematics.\n\nRecall that the worst case is where the largest number is substantially larger than the sum of the rest. For example, `[1, 5, 998]`. In these cases, we are repeatedly subtracting from the largest number and putting it back in. A good way to see what we need to do is to just compute the next few transitions for this target.\n\n```\n[1, 4, 998]\n\u2192 [1, 4, 993]\n\u2192 [1, 4, 988]\n\u2192 [1, 4, 983]\n```\n\nSee the pattern? Each time, the largest number is being reduced by `5`. Where does the `5` come from? It is the sum of the other numbers.\n\nRemembering that this number will be the top of the heap until it is smaller than the next largest (i.e. the `4`), we can see that this is going to continue until it is *less than `5`*. From the pattern we can see that eventually it gets to `[1, 4, 8]`, and finally `[1, 4, 3]`. \n\nSubtracting `5` from `998` repeatedly, until it is below `5`, is modular arithmetic. Effectively, all we've done is `998 % 5 = 3`, following a *really* inefficient process!\n\nGeneralising a bit, the `998` was the current heap maximum, and `5` was the sum of the rest (obtained in code with `total_sum - largest`).\n\nSo, instead of doing the following line:\n\n```python\nx = largest - (total_sum - largest)\n```\n\nWe should do:\n\n```python\nx = largest % (total_sum - largest)\n```\n\nThis solves the problem, although it might not be at all obvious why. The key ideas are:\n\n1. That `largest` is always at least half of total_sum. \n2. That `largest` is always replaced with a value at most half of itself.\n\nEffectively, we are always removing at least $$\\frac{1}{4}$$ of the total sum in the array. \n\nTo simplify the explanation, we'll define `rest = total_sum - largest`. i.e. it is simply the sum of the array, excluding the largest.\n\nTo prove the first point, we know that `largest` is always bigger than `rest`, because if it wasn't, `x` would go negative (and therefore we would immediately return `false` and exist.). This can be seen from the formula above. \n\n```\nx = largest - (total_sum - largest)\n\u2192 \nx = largest - rest\n```\n\nTo prove the second point, we need to think carefully what the following is doing:\n\n```\nx = largest % (total_sum - largest)\n\u2192 \nx = largest % rest\n```\n\nBecause `largest > rest`, we know that `x` is at most `largest - rest`. i.e. the modulus will cause `rest` to be subtracted at least once.\n\nIf `rest` is at least half the size of `largest`, then this will clearly chop `largest` in half.\n\nIf instead `rest` is less than half the size of `largest`, then `largest % rest` must be less than half of `largest`.\n\nRemoving $$\\frac{1}{4}$$ each time is logarithmic.\n\nOne edge case we need to be cautious of is where `rest` is `1`. When we take numbers modulo `1`, they always become `0`. The only case this can occur is where $$n = 2$$. In fact though, we know that this case is always doable, because `largest` is simply decremented by `1` repeatedly until it reaches `1` itself.\n\n\n**Algorithm**\n\n<iframe src=\"https://leetcode.com/playground/7Jqjehej/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"7Jqjehej\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$O(n + \\log \\, k \\cdot \\log \\, n)$$.\n\n    Creating a heap is $$O(n)$$. \n    \n    At each step, we were removing at least $$\\frac{1}{4}$$ of the total sum. The original total sum is $$2 \\cdot k$$, because $$k$$ is the largest element, and we know that if the algorithm continues, then the rest can't add up to more than $$k$$. So, we need to take $$O(\\log \\, k)$$ steps to reduce the array down. Each of these steps is the cost of a heap add and remove, i.e. $$O(\\log \\, n)$$. In total, this is $$O(\\log \\, k \\cdot \\log \\, n)$$.\n\n- Space Complexity : $$O(n)$$.\n\n    Same as above.\n\n</br>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "836",
            "count": 42,
            "average": "4.714",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "construct-target-array-with-multiple-sums",
    "playgroundData": {
        "znrdm4V5": {
            "playground": {
                "testcaseInput": "",
                "name": "construct-target-array-with-multiple-sums-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "7Jqjehej": {
            "playground": {
                "testcaseInput": "",
                "name": "construct-target-array-with-multiple-sums-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}