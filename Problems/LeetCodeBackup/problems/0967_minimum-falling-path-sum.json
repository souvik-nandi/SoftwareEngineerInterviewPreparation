{
    "id": "967",
    "question": {
        "questionId": "967",
        "questionFrontendId": "931",
        "boundTopicId": null,
        "title": "Minimum Falling Path Sum",
        "titleSlug": "minimum-falling-path-sum",
        "content": "<p>Given an <code>n x n</code> array of integers <code>matrix</code>, return <em>the <strong>minimum sum</strong> of any <strong>falling path</strong> through</em> <code>matrix</code>.</p>\n\n<p>A <strong>falling path</strong> starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position <code>(row, col)</code> will be <code>(row + 1, col - 1)</code>, <code>(row + 1, col)</code>, or <code>(row + 1, col + 1)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg\" style=\"width: 499px; height: 500px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[2,1,3],[6,5,4],[7,8,9]]\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> There are two falling paths with a minimum sum as shown.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg\" style=\"width: 164px; height: 365px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[-19,57],[-40,-5]]\n<strong>Output:</strong> -59\n<strong>Explanation:</strong> The falling path with a minimum sum is shown.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 2658,
        "dislikes": 96,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Minimum Falling Path Sum II\", \"titleSlug\": \"minimum-falling-path-sum-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[2,1,3],[6,5,4],[7,8,9]]\n[[-19,57],[-40,-5]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Roblox\", \"slug\": \"roblox\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 0}], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minFallingPathSum(int[][] matrix) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minFallingPathSum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinFallingPathSum(int[][] matrix) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @return {number}\n */\nvar minFallingPathSum = function(matrix) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @return {Integer}\ndef min_falling_path_sum(matrix)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minFallingPathSum(matrix [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minFallingPathSum(matrix: Array[Array[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minFallingPathSum(matrix: Array<IntArray>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn min_falling_path_sum(matrix: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return Integer\n     */\n    function minFallingPathSum($matrix) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minFallingPathSum(matrix: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (min-falling-path-sum matrix)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec min_falling_path_sum(Matrix :: [[integer()]]) -> integer().\nmin_falling_path_sum(Matrix) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec min_falling_path_sum(matrix :: [[integer]]) :: integer\n  def min_falling_path_sum(matrix) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"139.8K\", \"totalSubmission\": \"205.9K\", \"totalAcceptedRaw\": 139842, \"totalSubmissionRaw\": 205894, \"acRate\": \"67.9%\"}",
        "hints": [],
        "solution": {
            "id": "1448",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[2,1,3],[6,5,4],[7,8,9]]",
        "metaData": "{\n  \"name\": \"minFallingPathSum\",\n  \"params\": [\n    {\n      \"name\": \"matrix\",\n      \"type\": \"integer[][]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1448",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Overview\nGiven a 2D `matrix(row, col)`, we have to find the sum of the minimum falling path in a matrix.\nTo begin with, let's try to understand, what is a falling path?\nTo put it in simple words, it is a path that satisfies the following criteria,\n 1. A falling path is a path that begins at **any** cell in the first row of the matrix and ends at **any** cell in the last row of the matrix.\n2. From a certain cell `(row, col)` in the falling path, we can only move to 3 possible cells, `(row + 1, col)` , `(row + 1, col + 1)`, `(row + 1, col - 1)`.\n\n\n<center>\n<img src=\"../Figures/931/931_overview.png\">\n</center>\n\nAs the name suggests, the falling path sum is the sum of values of all the cells in the chosen path. Our goal is to find the minimum sum from all possible paths. Let's consider different approaches that can be used to solve this problem. We will begin with the brute force approach and optimize it using dynamic programming.\n\n\n<br>\n---\n#### Approach 1: Brute Force Using Depth First Search\n\n**Intuition**\n\nBrute Force is generally the straightforward approach to solving the problem. You can think of the brute force approach as\n\n \"Given pen and paper in your hand, how will you try to solve the problem\"?\n\nThough the brute force approach is considered to be the most exhaustive and unoptimized approach, implementing this approach first gives a deeper understanding of the basis of the problem, which can further help to shape a better-optimized solution.\n\nLet's understand the brute force approach with the following example,\n\n![Example Problem](../Figures/931/931_example_problem.png)\n\n> Before reading the following section, try to find the minimum falling path for the above matrix on your own.\n\nIn this example, if we start at cell `(0, 1)`, the next cell in the path could be `(1, 0)`, `(1, 1)`, or `(1, 2)`. From the current position, we cannot determine which path will give us the minimum path sum, so let's try all the possible paths.\n\n![Example Problem](../Figures/931/931_example_3possibilities.png)\n\nThe minimum path sum from cell `(0, 1)` is \"5\" - going from `(0, 1)` to `(1, 2)`. Does that mean that we can greedily choose this path and move ahead, discarding the other paths?\nLet's find the minimum falling path if we choose the path with the sum \"5\" i.e `(0, 1)` to `(1, 2)`.\n\n![Example Problem, Explore One Path](../Figures/931/931_Explore_greedy_path.png)\n\nThus, the minimum falling path sum is \"14\". Now, let's explore other paths starting from cell `(0, 1)`.\n\n![Example Problem, Explore All Path](../Figures/931/931_Explore_All_Paths.png)\n\nThe minimum falling path sum is now \"13\" i.e `(0, 1)` -> `(1, 1)` -> `(2, 0)`.\n\nThis proves that the greedy approach will not work for this problem. A sub-path with the lowest subset-sum cannot guarantee the lowest sum for the entire path. We must explore all possible paths to find the one with the smallest sum.\n\nSince we have to try all paths from any cell, the solution must generate all the possible falling paths and track the one with a minimum sum. To try all possible combinations, we can perform a depth-first search on the matrix.\n\n>The Depth First Search is an exhaustive search process wherein we will traverse all the cells in a path. On reaching the end of the path, we must undo our last step in the current path and try a different possible next step to extend the path.\n\nNote: This approach is a brute force solution, and it is not expected to pass all test cases. This approach is included because, often, an intuitive way to approach problems like this one is to start by building a brute force solution and then modify it to achieve an optimized solution.\n\n\n**Algorithm**\n\n1. Implement a Depth First Search algorithm, by defining a recursive function, `findMinFallingPathSum(row, col)`, that recursively explores all the paths from the current cell (defined by parameters `row` and `col`).\n   - Define Base Case:\n  In any recursive function, we must define the terminating condition i.e the base case. When the terminating condition is satisfied, we will exit the recursive search process. The base cases are as follows,\n      - The `row` or `col` values are not within the matrix boundaries.\n      - We have reached the last row. In this case, we will return the value of the current cell and not make any other recursive calls.\n   - _Recursively explore all paths:_ If the base case is not satisfied, it means that we have not reached the end of our current path, and we must try all options to extend our path and find the one with the minimum sum:\n\n```\nminimumPath = Minimum(findMinFallingPathSum(row + 1, col + 1),\n                      findMinFallingPathSum(row + 1, col),\n                      findMinFallingPathSum(row + 1, col - 1))\n```\n\n2. Now that we have defined the recursive function, we must find the minimum falling path for all possible starting cells. A starting cell is any cell in the top row.\n\n   For this, we have to iterate using a _for_ loop and find the minimum falling path for cell in $$0^{th}$$ row and columns ranging from $$0$$ to $$\\text{matrix.length} - 1$$. Define a variable `minFallingSum` to track the minimum of all the falling paths found so far and return the result.\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/Q6grBxnZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Q6grBxnZ\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `matrix`.\n\n* Time Complexity: $$O({N} \\cdot 3^{N})$$ The solution takes the form of a 3-ary recursion tree where there are 3 possibilities for every node in the tree. The time complexity can be derived as follows,\n - The maximum depth of the recursion tree is equal to the number of rows in the matrix i.e $$N$$.\n - Each level (`level`) of the recursion tree will contain approximately $$3^\\text{level}$$ nodes. For example, at level $$0$$ there are $$3^0$$ nodes, for level 1, $$3^{1}$$ nodes, and so on. Thus, the maximum number of nodes at level $$N$$ would be approximately $$3^{N}$$.\n - Thus the time complexity is roughly, $$O({N} \\cdot 3^{N})$$.\n\n The time complexity is exponential, hence this approach is exhaustive and results in _Time Limit Exceeded (TLE)_.\n\n* Space Complexity: $$O(N)$$ This space will be used to store the recursion stack. As the maximum depth of the tree is $$N$$, we will not have more than $$N$$ recursive calls on the call stack at any time.\n\n\n<br>\n---\n#### Approach 2: Top Down Dynamic Programming\n\n**Intuition**\n\nThe brute force approach is exhaustive. To come up with the optimized solution for the problem, let's take a deeper look at the  following recursion tree,\n\n![Example Problem, Recursion Tree](../Figures/931/931_recursion_tree.png)\n\nIn the above recursion tree, we can identify the repetitive sub-paths (circled in the same color). For example, `findMinPathSum(1, 0)` is calculated twice, `findMinPathSum(1, 1)` is calculated three times, and so on.\n\nRepeated calculation of the same subproblems is the root cause of the exponential time complexity in the previous approach.  Although, what if our algorithm could remember the result for a subproblem when it is computed the first time and reuses the stored result every other time?\n\n> Pretend you are on a treasure hunt. On reaching point A, you travel to the destination and don't find anything there. You go back to some other path which again takes you to point A. You wouldn't explore the same path from point A again. You would say, \"I have been here before; I know where this path goes.\"\n>\n>  How can we make our algorithm think the same way? We can do so by marking every path we have visited so that if we reach the same path again, we know the result!!\n\n\nIn [Dynamic Programming](https://leetcode.com/explore/featured/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4034/), when a recursive problem solves the same subproblem multiple times, it has the Overlapping Subproblem property. Such problems can be optimized using a dynamic programming technique called Memoization.\n\nAs in the previous approach, each call to `findMinFallingPathSum` will return the minimum falling path sum between the current cell and the bottom of the `matrix`. However, in this approach, we will store the result of each call in the new parameter `memo`, and when we revisit this cell in a subsequent call, we will be able to reuse the stored result.\n\n\n**Algorithm**\n\n1. In order to record the results of computation for every cell,  maintain a 2-dimensional matrix named `memo` where the value of `memo[row][col]` would give the minimum falling path starting from the cell `(row, col)`.\n\n2. Implement a Depth First Search algorithm, by defining a recursive function, `findMinFallingPathSum(row, col)`, that recursively explores all the paths from the current cell (defined by parameters `row` and `col`).\n   - Define Base Case:\n  In any recursive function, we must define the terminating condition i.e the base case. When the terminating condition is satisfied, we will exit the recursive search process. The base cases are as follows,\n      - The `row` or `col` values are not within the matrix boundaries.\n      - We have reached the last row. In this case, we will return the value of the current cell and not make any other recursive calls.\n   - _Recursively explore all paths:_ If the base case is not satisfied, it means that we have not reached the end of our current path, and we must try all options to extend our path and find the one with the minimum sum:\n\n```\nminimumPath = Minimum(findMinFallingPathSum(row + 1, col + 1),\n                      findMinFallingPathSum(row + 1, col),\n                      findMinFallingPathSum(row + 1, col - 1))\n```\n\n3. To avoid repetitive computation of the results as in the brute force approach, we make use of stored results as follows,\n\n   - Before recursively computing the result for the current cell, check if the `memo` has the result for the current cell. If so, return the result, otherwise, proceed with the recursive call to compute the result.\n\n   - After computing the result, store the result in the `memo[row][col]`.\n\n4. Iteratively find the minimum falling path for all possible starting cells i.e cells in $$0^{th}$$ row and columns ranging from $$0$$ to $$\\text{matrix.length} - 1$$. Track the minimum value in the variable `minFallingSum` and return the result.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/HL4Cuj6E/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"HL4Cuj6E\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `matrix`.\n\n* Time Complexity: $$O(N^2)$$\n\n  For every cell in the matrix, we will compute the result only once and update the `memo`. For the subsequent calls, we are using the stored results that take $$O(1)$$ time. There are $$N^2$$ cells in the matrix, and thus $$N^2$$ dp states. So, the time complexity is $$O(N^2)$$.\n\n* Space Complexity: $$O(N^2)$$\n\n  The recursive call stack uses $$O(N)$$  space. As the maximum depth of the tree is $$N$$, we can\u2019t have more than $$N$$ recursive calls on the call stack at any time. The 2D matrix `memo` uses $$O(N^2)$$ space. Thus, the space complexity is $$O(N) + O(N^2) = O(N^2)$$.\n\n\n<br>\n---\n#### Approach 3: Bottom-Up Dynamic Programming (Tabulation)\n\n**Intuition**\n\nThe memoization technique follows the top-down approach. We start by finding the result for the original matrix and recursively move towards computing the result of smaller subproblems.\n\nThere is yet another technique to implement Dynamic Programming problems called bottom-up dynamic programming also known as, Tabulation. In the bottom-up approach, we start by finding the result of the smallest subproblem and iteratively move towards larger sub-problems. Being non-recursive in nature, this approach does not require maintaining a separate internal call stack for storing the intermediate state of recursion.\n\nThe results of subproblems are stored in a 2-dimensional table, `dp`. Here, the smallest sub-problem would be a matrix with only one row. Thus, we will first calculate the result for each cell in the last row (base case), call this the $$n^{th}$$ row, and store the results in `dp`. Next, when we move to the $$(n-1)^{th}$$ row, the results for the next row (i.e. the $$n^{th}$$ row) are already present. In this way, in every iteration, we are calculating and storing the result for the subsequent problem.\n\nWhile this approach does not improve the time or space complexity compared to the top-down approach, it does act as a stepping stone towards the next approach where we will improve the space complexity.\n\n\n**Algorithm**\n\nBottom-up Dynamic Programming follows an iterative approach to solving the problem. We have to start by finding the minimum falling path for the smallest possible matrix i.e the matrix having a single cell and one by one move towards the rest of the cells in the matrix.\n\n1. To compute the minimum falling path for a certain cell `(row, col)`, we must have pre-computed values for the minimum falling path for cells `(row + 1, col - 1)`, `(row + 1, col)` and `(row + 1, col + 1)`.  For this, we will iterate from $$(n-1)^{th}$$ row to $$0^{th}$$ row and from $$0^{th}$$ column to $$(n-1)^{th}$$ column.\n\n    > Note: The order of iterating the columns does not matter in this case. Even if we iterate from $$(n-1)^{th}$$ to $$0^{th}$$ column, the results would be the same.\n\n2.  Build a 2D matrix `dp` and compute the minimum falling path of current `row` and `col` as,\n     ```\n        dp[row][col] = min(dp[row + 1][col - 1],\n                           dp[row + 1][col],\n                           dp[row + 1][col + 1]) + value of current (row, col) in matrix\n      ```\n    Note: We must handle the edge cases, for example, if the col value is `0` or `n - 1`.\n\n3. Once we have the value of the minimum falling path from every cell, we must get the result from the start cell. The start cell can be any cell on the first row. Thus, we will iterate over all the cells in the first row, and return the minimum value.\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/6AXTLYiP/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"6AXTLYiP\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `matrix`.\n* Time Complexity: $$O(N^{2})$$\n  - The nested for loop takes ($$N^{2}$$) times to fill the `dp` array.\n  - Then, takes $$N$$ time to find the minimum falling path.\n   - So, Time Complexity $$T(n) = O(N^{2}) + O(N) = O(N^{2})$$\n\n* Space Complexity: $$O(N^{2})$$. The additional space is used for `dp` array of size $$N^{2}$$.\n\n<br>\n\n---\n\n#### Approach 4: Space Optimized, Bottom-Up Dynamic Programming\n\n**Intuition**\n\nThe tabulation approach used $$O(N^{2})$$ space to track the minimum falling path starting from every cell. But, in the end, to calculate the final result, we only need the minimum falling path of all the cells in the first row.\n\nFurthermore, to calculate the values for cells in the row `n`, we only need the values of the `n + 1` row. So, after finding the results for row `n`, we no longer need to store the values for the `n + 1` row. As such, we can optimize the space complexity of the tabulation approach as follows,\n\n-  Calculate the values for all the cells in the current row `n` based on results for the cells in the `n + 1` row. Let's define a 1-dimensional array, `dp`, to store the results of the `n + 1` row.\n-  As we move to the `n - 1` row, the current row becomes the `n + 1` row. So, we can discard the current values of `dp`, and begin to store the results for the current row in the `dp` array.\n\nIn this way, instead of maintaining a 2-dimensional array the size of a `matrix`, we can just define two 1-dimensional arrays, one that stores the value of the current row and the other that has the results of the previous row.\n\n**Algorithm**\n\n1.  Define a 1-dimensional array, `dp`, initialized with all values set to `0`,\n\n2.   For every row, define a 1-dimensional array, `currentRow`, to store the results of all the columns in the current row.\n\n3.  Calculate the values for all the columns in the current row, `currentRow` based on the values of the previous row stored in  array`dp`,\n\n    ```\n    currentRow[col] = min(dp[col - 1],\n                          dp[col],\n                          dp[col + 1]) + value of current (row, col) in matrix\n    ```\n      Note: We must handle the edge cases, for example, if the col value is `0` or `n - 1`.\n\n4. Once all the values of the current row are calculated, assign the values of `currentRow` to the `dp` array. So that the values in `dp` servers as the values of the previous row for the next iteration.\n\n   In some programming languages, this can be done by just changing the pointer reference instead of copying the values one by one.\n\n5. The process is repeated for all the rows, and at the end, we will have the results for the cells in the first row, in the `dp` array, and we can find the minimum falling path.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/emds4kgq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"emds4kgq\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `matrix`.\n\n* Time Complexity: $$O(N^{2})$$\n  - The nested for loop takes ($$N^{2}$$) time.\n  - Then, it takes $$N$$time to find the minimum falling path.\n  - So, Time Complexity $$T(n) = O(N^{2}) + O(N) = O(N^{2})$$\n\n* Space Complexity: $$O(N)$$.\n  - We are using two 1-dimensional arrays `dp` and `currentRow` of size $$N$$.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1453",
            "count": 9,
            "average": "5.000",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "minimum-falling-path-sum",
    "playgroundData": {
        "Q6grBxnZ": {
            "playground": {
                "testcaseInput": "",
                "name": "minimum-falling-path-sum-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "HL4Cuj6E": {
            "playground": {
                "testcaseInput": "",
                "name": "minimum-falling-path-sum-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "6AXTLYiP": {
            "playground": {
                "testcaseInput": "",
                "name": "minimum-falling-path-sum-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "emds4kgq": {
            "playground": {
                "testcaseInput": "",
                "name": "minimum-falling-path-sum-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}