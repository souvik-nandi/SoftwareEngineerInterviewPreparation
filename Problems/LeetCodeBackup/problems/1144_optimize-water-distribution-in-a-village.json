{
    "id": "1144",
    "question": {
        "questionId": "1144",
        "questionFrontendId": "1168",
        "boundTopicId": null,
        "title": "Optimize Water Distribution in a Village",
        "titleSlug": "optimize-water-distribution-in-a-village",
        "content": "<p>There are <code>n</code> houses in a village. We want to supply water for all the houses by building wells and laying pipes.</p>\n\n<p>For each house <code>i</code>, we can either build a well inside it directly with cost <code>wells[i - 1]</code> (note the <code>-1</code> due to <strong>0-indexing</strong>), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array <code>pipes</code> where each <code>pipes[j] = [house1<sub>j</sub>, house2<sub>j</sub>, cost<sub>j</sub>]</code> represents the cost to connect <code>house1<sub>j</sub></code> and <code>house2<sub>j</sub></code> together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs.</p>\n\n<p>Return <em>the minimum total cost to supply water to all houses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/22/1359_ex1.png\" style=\"width: 189px; height: 196px;\" />\n<pre>\n<strong>Input:</strong> n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The image shows the costs of connecting houses using pipes.\nThe best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, wells = [1,1], pipes = [[1,2,1],[1,2,2]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can supply water with cost two using one of the three options:\nOption 1:\n  - Build a well inside house 1 with cost 1.\n  - Build a well inside house 2 with cost 1.\nThe total cost will be 2.\nOption 2:\n  - Build a well inside house 1 with cost 1.\n  - Connect house 2 with house 1 with cost 1.\nThe total cost will be 2.\nOption 3:\n  - Build a well inside house 2 with cost 1.\n  - Connect house 1 with house 2 with cost 1.\nThe total cost will be 2.\nNote that we can connect houses 1 and 2 with cost 1 or with cost 2 but we will always choose <strong>the cheapest option</strong>. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>wells.length == n</code></li>\n\t<li><code>0 &lt;= wells[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= pipes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>pipes[j].length == 3</code></li>\n\t<li><code>1 &lt;= house1<sub>j</sub>, house2<sub>j</sub> &lt;= n</code></li>\n\t<li><code>0 &lt;= cost<sub>j</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>house1<sub>j</sub> != house2<sub>j</sub></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Hard",
        "likes": 878,
        "dislikes": 33,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "3\n[1,2,2]\n[[1,2,1],[2,3,1]]\n2\n[1,1]\n[[1,2,1],[1,2,2]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Union Find",
                "slug": "union-find",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Graph",
                "slug": "graph",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Minimum Spanning Tree",
                "slug": "minimum-spanning-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"1\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minCostToSupplyWater(int n, vector<int>& wells, vector<vector<int>>& pipes) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minCostToSupplyWater(self, n, wells, pipes):\n        \"\"\"\n        :type n: int\n        :type wells: List[int]\n        :type pipes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minCostToSupplyWater(self, n: int, wells: List[int], pipes: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minCostToSupplyWater(int n, int* wells, int wellsSize, int** pipes, int pipesSize, int* pipesColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinCostToSupplyWater(int n, int[] wells, int[][] pipes) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number[]} wells\n * @param {number[][]} pipes\n * @return {number}\n */\nvar minCostToSupplyWater = function(n, wells, pipes) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @param {Integer[]} wells\n# @param {Integer[][]} pipes\n# @return {Integer}\ndef min_cost_to_supply_water(n, wells, pipes)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minCostToSupplyWater(_ n: Int, _ wells: [Int], _ pipes: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minCostToSupplyWater(n int, wells []int, pipes [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minCostToSupplyWater(n: Int, wells: Array[Int], pipes: Array[Array[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minCostToSupplyWater(n: Int, wells: IntArray, pipes: Array<IntArray>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn min_cost_to_supply_water(n: i32, wells: Vec<i32>, pipes: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[] $wells\n     * @param Integer[][] $pipes\n     * @return Integer\n     */\n    function minCostToSupplyWater($n, $wells, $pipes) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minCostToSupplyWater(n: number, wells: number[], pipes: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (min-cost-to-supply-water n wells pipes)\n  (-> exact-integer? (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec min_cost_to_supply_water(N :: integer(), Wells :: [integer()], Pipes :: [[integer()]]) -> integer().\nmin_cost_to_supply_water(N, Wells, Pipes) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec min_cost_to_supply_water(n :: integer, wells :: [integer], pipes :: [[integer]]) :: integer\n  def min_cost_to_supply_water(n, wells, pipes) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"33.2K\", \"totalSubmission\": \"51.7K\", \"totalAcceptedRaw\": 33184, \"totalSubmissionRaw\": 51691, \"acRate\": \"64.2%\"}",
        "hints": [
            "What if we model this problem as a graph problem?",
            "A house is a node and a pipe is a weighted edge.",
            "How to represent building wells in the graph model?",
            "Add a virtual node, connect it to houses with edges weighted by the costs to build wells in these houses.",
            "The problem is now reduced to a Minimum Spanning Tree problem."
        ],
        "solution": {
            "id": "1150",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "3\n[1,2,2]\n[[1,2,1],[2,3,1]]",
        "metaData": "{\n  \"name\": \"minCostToSupplyWater\",\n  \"params\": [\n    {\n      \"name\": \"n\",\n      \"type\": \"integer\"\n    },\n    {\n      \"name\": \"wells\",\n      \"type\": \"integer[]\"\n    },\n    {\n      \"name\": \"pipes\",\n      \"type\": \"integer[][]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1150",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n#### Overview\r\n\r\nSince the problem description involves connecting houses (vertices) using pipes (edges), we can tell that this problem is a variant of graph problems.\r\nMore precisely, we can convert it into a standard [minimum spanning tree (MST)](https://en.wikipedia.org/wiki/Minimum_spanning_tree) problem, which we will discuss in detail how to do so in this article.\r\n\r\nConcerning the MST problem, there exist several classic algorithms.\r\nIn particular, we will demonstrate two of them, namely [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm) and [Kruskal's algorithm](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm), which are arguably the most popular ones and feasible to implement during an interview.\r\n\r\n**Intuition**\r\n\r\nFirst of all, let us introduce the problem of the minimum spanning tree.\r\n\r\n>Given a _connected_, _edge-weighted_ and _undirected_ graph, a minimum spanning tree is a **_subset_** of edges that connect all vertices while the total weights of these edges are minimum among all possible subsets.\r\n\r\nOne can draw some similarities between the above definition and our problem here.\r\nSpecifically, we can consider each house as a vertex in a graph, and the pipes between the houses as edges in the graph.\r\n\r\nHowever, there is one major **difference** between them.\r\nIn our problem, every vertex and every edge comes with a cost.\r\nWhile in the setting of MST, only the edges are associated with the costs.\r\n\r\n>To bridge the **_gap_**, as suggested in the hints, the trick is to add **one virtual vertex** to the existing graph. Along with the addition of vertex, we also add edges between the virtual vertex and the rest of the vertices.\r\nFinally, we reassign the cost of each vertex to the corresponding newly-added edge.\r\n\r\nHere is an illustration showing how we convert the graph in the example with the above trick.\r\n\r\n![graph conversion](../Figures/1168/1168_graph_conversion.png)\r\n\r\nWith the converted graph, we then can take into account the costs from the vertex, via the additional edges.\r\nWe can focus entirely on selecting the appropriate edges to create an MST.\r\nThus, our problem is simplified to creating an MST from a list of weighted edges.\r\n\r\n![MST solution](../Figures/1168/1168_mst_solution.png)\r\n\r\nIn the above graph, we demonstrate the solution that we will find after solving the MST problem, which we can translate as _\"to minimize the cost, we should dig a well in the house indexed with `1` (denoted by the edge between indices `1` and `0`), and then supply the water to the rest of the houses_.\"\r\n\r\n\r\n---\r\n#### Approach 1: Prim's Algorithm with Heap\r\n\r\n**Intuition**\r\n\r\n[Prim's](https://en.wikipedia.org/wiki/Prim%27s_algorithm) (also known as Jarn\u00edk's) algorithm is a **_greedy_** algorithm used to find the minimum spanning tree in a _weighted_ and _undirected_ graph.\r\n\r\n>The algorithm operates by building the tree one vertex at a time, from an arbitrary starting vertex, at each step adding the **_cheapest_** possible connection from any vertex in the tree to a vertex that is not in the tree.\r\n\r\n![Prim Demo](../Figures/1168/PrimAlgDemo.gif)\r\n{:align=\"center\"}\r\n\r\nThe above illustration demonstrates how Prim's algorithm works.\r\nStarting from an arbitrary vertex, Prim's algorithm **_grows_** the minimum spanning tree by adding one vertex at a time to the tree.\r\nThe choice of a vertex is based on the **_greedy_** strategy, _i.e._ the addition of the new vertex incurs the minimum cost.\r\n\r\n\r\n**Algorithm**\r\n\r\nTo implement Prim's algorithm, essentially we will need the following three data structures:\r\n\r\n- **adjacency list**: we need this to represent the graph, _i.e._ vertices and edges. The adjacency list can be a list of lists or a dictionary of lists.\r\n\r\n- **set**: we need a set to maintain all the vertices that we have added to the final minimum spanning tree, during the construction of the tree.\r\nWith the help of set, we can determine whether a vertex has been added or not.\r\n\r\n- **heap**: due to the nature of the greedy strategy, at each step, we can determine the best edge to be added based on the cost it will add to the tree.\r\n[Heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) (also known as a priority queue) is a data structure that allows us to retrieve the minimum element in constant time and to remove the minimum element in logarithmic time. This fits our need to repeatedly find the lowest cost edge perfectly.\r\n\r\n**Implementation**\r\n\r\nBy applying the above three data structures, the following steps can be used to implement Prim's algorithm.\r\n\r\n- First of all, given the input, we need to build a graph representation with the adjacency list.\r\n    - Note that, since the graph is undirected (_i.e._ bidirectional), for each pipe, we need to add two entries in the adjacency list, with each end of the pipe as a starting vertex.\r\n    - Also, to convert our problem into the MST problem, we need to add a virtual vertex (we index it as `0`) together with the additional `n` edges to each house.\r\n\r\n- Starting from the virtual vertex, we build the MST by **_iteratively_** adding one vertex at a time.\r\n    - Note, when using Prim's algorithm, we can use any vertex as a starting point.\r\n    Here, for the sake of convenience, we start from the newly-added virtual vertex.\r\n\r\n- The process of building MST consists of a loop with the following substeps:\r\n\r\n  - Each iteration, we pop an element from the heap. This element contains a vertex along with the cost that is associated with the edge that connecting the vertex to the tree.\r\n  The vertex is chosen if it is not already in the tree.\r\n  We know that the cost of this vertex is minimal among all choices because it was popped from the heap.\r\n\r\n  - Once the vertex is added, we then examine its neighboring vertices.\r\n  Specifically, we add these vertices along with their edges into the heap as the candidates for the next round of selection.\r\n\r\n  - The loop **terminates** when we have added all the vertices from the graph into the MST.\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/U5jyPL3a/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"U5jyPL3a\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$N$$ be the number of houses, and $$M$$ be the number of pipes from the input.\r\n\r\n- Time Complexity: $$O\\big( (N+M) \\cdot \\log(N+M) \\big)$$\r\n\r\n    - To build the graph, we iterate through the houses and pipes in the input, which takes $$O(N + M)$$ time.\r\n\r\n    - While building the MST, we might need to iterate through all the edges in the graph in the worst case, which amounts to $$N + M$$ in total.\r\n    For each edge, it would enter and exit the heap data structure at most once. The enter of edge into heap (_i.e._ `push` operation) takes $$\\log(N+M)$$ time, while the exit of edge (_i.e._ `pop` operation) takes a constant time.\r\n    Therefore, the time complexity of the MST construction process is $$O\\big( (N+M) \\cdot \\log(N+M) \\big)$$.\r\n\r\n    - To sum up, the overall time complexity of the algorithm is $$O\\big( (N+M) \\cdot \\log(N+M) \\big)$$.\r\n\r\n\r\n- Space Complexity: $$O(N+M)$$\r\n\r\n    - We break down the analysis accordingly into the three major data structures that we used in the algorithm.\r\n\r\n    - The graph that we built consists of $$N+1$$ vertices and $$2 \\cdot M$$ edges (_i.e._ pipes are bidirectional).\r\n    Therefore, the space complexity of graph is $$O(N + 1 + 2 \\cdot M) = O(N + M)$$.\r\n\r\n    - The space complexity of the set that is used to hold the vertices in MST is $$O(N)$$.\r\n\r\n    - Finally, in the worst case, the heap we used might hold all the edges in the graph which is $$(N+M)$$.\r\n\r\n    - To summarize, the overall space complexity of the algorithm is $$O(N+M)$$.\r\n\r\n\r\n---\r\n#### Approach 2: Kruskal's Algorithm with Union-Find\r\n\r\n**Intuition**\r\n\r\nAnother classical algorithm to solve the MST problem is called [Kruskal's algorithm](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm).\r\n\r\n>Similiar to Prim's algorithm, Kruskal's algorithm applies the **_greedy_** strategy to **_incrementally_** add new edges to the final solution.\r\n\r\n![Kruskal Demo](../Figures/1168/KruskalDemo.gif)\r\n{:align=\"center\"}\r\n\r\nThe above animation shows how Kruskal's algorithm **_grows_** the minimum spanning tree.\r\n\r\n>A major difference between them is that in Prim's algorithm the MST (minimal spanning tree) remains **_connected_** as a whole throughout the entire process, while in Kruskal's algorithm, the tree is formed by _merging_ the _**disjoint components**_ together.\r\n\r\n\r\n**Algorithm**\r\n\r\nRather than adding vertices as in Prim's algorithm, the Kruskal's algorithm focuses on adding edges.\r\nFurthermore, in Kruskal's algorithm, we consider **_all edges at once_** ranked by their costs, while in Prim's algorithm, although edges are ranked by costs in a heap or priority queue, at each iteration, we only explore **_edges that are connected to the vertices that are already in the MST_**.\r\n\r\n>The overall idea of Kruskal's algorithm is that we **_iterate_** through all the edges *ordered* by their costs. For each edge, we decide whether to add it to the final MST. The decision is based on whether this new addition will help to **_connect_** more dots (_i.e._ vertices).\r\n\r\n![Union-Find examples](../Figures/1168/1168_union_find_examples.png)\r\n{:align=\"center\"}\r\n\r\n*Add or Not to Add ?*\r\n{:align=\"center\"}\r\n\r\nThe above diagram shows three example scenarios and for each scenario, specifies whether a new edge should be added or not.\r\nThe solid edges have already been added to the MST, while the dashed edges have yet to be decided.\r\n\r\n- In the example on the left, we should add the new edge, since the edge **_bridges_** the gap between the two disjoint components.\r\n- In the middle example, we should also add the new edge, since it **_connects_** to an unseen vertex (_i.e._ connecting more dots).\r\n- In the example on the right, we should **not** add the new edge. Because it does not help us to make the current MST more **_connected_**, since all vertices are connected already.\r\n\r\n>A more concise **_criteria_** to determine whether we should add a new edge in Kruskal's algorithm is that whether both ends of the edge belong to the same component (group).\r\n\r\n**Implementation**\r\n\r\nIn order to determine the membership for a collection of elements, we often apply the data structure called [Disjoint Set](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) which is also known as **Union-Find** data structure.\r\n\r\nEssentially, the Union-Find data structure provides two interfaces:\r\n\r\n- `find(a)`: the function returns the id of the group where the element `a` belongs to.\r\n- `union(a, b)`: the function joins the two groups that the element `a` and `b` belong to. If they belong to the same group already, then the function does nothing.\r\n\r\nWe provide a full-fledged version of the Union-Find data structure with *path compression* and *link-by-rank* in the sample implementation.\r\n\r\nIf one would like to know more about how the Union-Find data structure works, one can refer to the solution for the problem of [323. Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) and a [tutorial](https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/UnionFind.pdf) from Princeton University.\r\n\r\nGiven the Union-Find data structure, we can implement Kruskal's algorithm with the following two steps:\r\n\r\n- First of all, we __sort__ all the edges based on their costs, including the additional edges that are added with the virtual vertex.\r\n\r\n- We then **iterate** through the _sorted_ edges. For each edge, if both ends of the edge belong to different groups, with the help of the Union-Find data structure, we then add this edge into the final MST.\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/KP8SHCFf/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"KP8SHCFf\"></iframe>\r\n\r\n**Note:** in the above implementation, we **tweak** the `union(a, b)` a bit to make the code more efficient and concise.\r\n\r\nIn most implementations of Union-Find data structure, we do not return anything for the function of `union(a, b)`.\r\nHowever, in our case, we return a flag to indicate whether the joining actually happens within the function.\r\nWith this tweak, we only need to invoke the `union(a,b)` function in our iteration, rather than invoking `find(a) == find(b)` functions in addition.\r\n\r\n\r\n**Complexity Analysis**\r\n\r\nSince we applied the Union-Find data structure in our algorithm, let's begin with a statement on the time complexity of the data structure:\r\n\r\n>If $$K$$ operations, either Union or Find, are applied to $$L$$ elements, the total run time is $$\\mathcal{O}(K \\cdot \\log^{*}{L})$$, where $$\\log^{*}$$ is the [iterated logarithm](https://en.wikipedia.org/wiki/Iterated_logarithm).\r\n\r\nOne can refer to the [proof of Union-Find complexity](https://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union%E2%80%93find) and the [tutorial](https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/UnionFind.pdf) from Princeton University for more details.\r\n\r\n\r\nLet $$N$$ be the number of houses, and $$M$$ be the number of pipes from the input.\r\n\r\n- Time Complexity: $$O\\big((N+M) \\cdot \\log(N+M) \\big)$$\r\n\r\n    - First, we build a list of edges, which takes $$O(N + M)$$ time.\r\n\r\n    - We then sort the list of edges, which takes $$O\\big((N+M) \\cdot \\log(N+M) \\big)$$ time.\r\n\r\n    - At the end, we iterate through the sorted edges. For each iteration, we invoke a Union-Find operation. Hence, the time complexity for iteration is $$O\\big( (N+M) * \\log^{*}(N) \\big)$$.\r\n\r\n    - To sum up, the overall time complexity of the algorithm is $$O\\big((N+M) \\cdot \\log(N+M) \\big)$$ which is dominated by the sorting step.\r\n\r\n\r\n- Space Complexity: $$O(N+M)$$\r\n\r\n    - The space complexity of our Union-Find data structure is $$O(N)$$.\r\n\r\n    - The space required by the list of edges is $$O(N+M)$$.\r\n\r\n    - Finally, the space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, the `list.sort()` function in Python is implemented with the [Timsort](https://en.wikipedia.org/wiki/Timsort) algorithm whose space complexity is $$\\mathcal{O}(n)$$ where $$n$$ is the number of the elements.\r\n    While in Java, the [Collections.sort()](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List)) is implemented as a variant of quicksort algorithm whose space complexity is $$\\mathcal{O}(\\log{n})$$.\r\n\r\n    - To sum up, the overall space complexity of the algorithm is $$O(N+M)$$ which is dominated by the list of edges.\r\n\r\n\r\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1155",
            "count": 86,
            "average": "4.954",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "optimize-water-distribution-in-a-village",
    "playgroundData": {
        "U5jyPL3a": {
            "playground": {
                "testcaseInput": "",
                "name": "optimize-water-distribution-in-a-village-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "KP8SHCFf": {
            "playground": {
                "testcaseInput": "",
                "name": "optimize-water-distribution-in-a-village-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}