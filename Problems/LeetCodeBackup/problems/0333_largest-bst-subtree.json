{
    "id": "333",
    "question": {
        "questionId": "333",
        "questionFrontendId": "333",
        "boundTopicId": null,
        "title": "Largest BST Subtree",
        "titleSlug": "largest-bst-subtree",
        "content": "<p>Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.</p>\n\n<p>A <strong>Binary Search Tree (BST)</strong> is a tree in which all the nodes follow the below-mentioned properties:</p>\n\n<ul>\n\t<li>The left subtree values are less than the value of their parent (root) node&#39;s value.</li>\n\t<li>The right subtree values are greater than the value of their parent (root) node&#39;s value.</li>\n</ul>\n\n<p><strong>Note:</strong> A subtree must include all of its descendants.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/17/tmp.jpg\" style=\"width: 571px; height: 302px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> root = [10,5,15,1,8,null,7]\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>The Largest BST Subtree in this case is the highlighted one. The return value is the subtree&#39;s size, which is 3.</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you figure out ways to solve it with <code>O(n)</code> time complexity?</p>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 1237,
        "dislikes": 103,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[10,5,15,1,8,null,7]\n[4,2,7,2,3,5,null,2,null,null,null,null,null,1]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Tree",
                "slug": "tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Search Tree",
                "slug": "binary-search-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Tree",
                "slug": "binary-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Cohesity\", \"slug\": \"cohesity\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int largestBSTSubtree(TreeNode* root) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int largestBSTSubtree(TreeNode root) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def largestBSTSubtree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def largestBSTSubtree(self, root: Optional[TreeNode]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint largestBSTSubtree(struct TreeNode* root){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int LargestBSTSubtree(TreeNode root) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar largestBSTSubtree = function(root) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef largest_bst_subtree(root)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func largestBSTSubtree(_ root: TreeNode?) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc largestBSTSubtree(root *TreeNode) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def largestBSTSubtree(root: TreeNode): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun largestBSTSubtree(root: TreeNode?): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn largest_bst_subtree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function largestBSTSubtree($root) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction largestBSTSubtree(root: TreeNode | null): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (largest-bst-subtree root)\n  (-> (or/c tree-node? #f) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec largest_bst_subtree(Root :: #tree_node{} | null) -> integer().\nlargest_bst_subtree(Root) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec largest_bst_subtree(root :: TreeNode.t | nil) :: integer\n  def largest_bst_subtree(root) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"85.7K\", \"totalSubmission\": \"205.6K\", \"totalAcceptedRaw\": 85664, \"totalSubmissionRaw\": 205629, \"acRate\": \"41.7%\"}",
        "hints": [
            "You can recursively use algorithm similar to <a href=\"https://leetcode.com/problems/validate-binary-search-tree/\">98. Validate Binary Search Tree</a> at each node of the tree, which will result in O(nlogn) time complexity."
        ],
        "solution": {
            "id": "1208",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[10,5,15,1,8,null,7]",
        "metaData": "{\r\n  \"name\": \"largestBSTSubtree\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1208",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nWe need to find the largest subtree which is also a Binary Search Tree (BST), where the largest means subtree has the maximum number of nodes.\n\n**Binary Search Tree** is a binary tree data structure in which all of its nodes have the following properties:\n\n- The left subtree of a node contains only nodes with values less than the node\u2019s value.\n- The right subtree of a node contains only nodes with values greater than the node\u2019s value.\n- The left and right subtree of each node in a BST should also be binary search trees. While this property is not directly stated in the problem description, it can be inferred since all nodes must have the above two properties.\n\nIf you are unfamiliar with binary search trees, we encourage you to check out our [BST Explore Card](https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/). We have also included a few similar practice problems that you can try:\n\n1. [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\n2. [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\n3. [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\n4. [House Robber III](https://leetcode.com/problems/house-robber-iii/)\n\n</br>\n\n---\n\n#### Approach 1: Pre-Order Traversal\n\n**Intuition**\n\nWe need to find the largest BST of the given tree. The root of the largest BST could be any node in the given tree. Hence we can think of traversing each node of the given tree and check if the subtree rooted at the current node is a BST or not. If it is a valid BST, we can count the nodes in this tree and update the answer. Otherwise, we will search for the largest BST in the left and right subtrees.\n\nThis approach is suboptimal and might result in time limit exceeded (TLE). However, it is presented here for learning purposes. It explains a few methods that solve classic problems related to binary trees, such as counting the number of nodes and finding the maximum and minimum valued nodes in subtrees. As such, the intention of this approach is to provide a better foundation for understanding the subsequent approaches.\n\nNote that the efficiency of this approach could be improved by caching the results for each of the operations listed below. However, this optimization is not implemented here because this approach is only intended to be used as a stepping stone to help us understand the subsequent optimized solutions.\n\n##### How to check if a binary tree is a Binary Search Tree?\n> We can create a function isValidBST which will return True if the subtree rooted at the current node is a valid BST. At each node of the tree: <br />\n> - **The left subtree of a node contains only nodes with values less than the current node\u2019s value.**    \n   We can call a findMax function which will explore all of the nodes in the left subtree and return the maximum node value. If the max value is less than the current node value it means all nodes in the left subtree have a smaller value than the current node. <br /> <br />\n> - **The right subtree of a node contains only nodes with values greater than the current node\u2019s value.**     \n   We can call a findMin function which will explore all of the nodes in the right subtree and return the minimum node value. If the min value is more than the current node's value it means all nodes in the right subtree have greater value than the current node. <br /> <br />\n> - **The left and right subtree of a node must also be a binary search tree.**    \n   To check this condition we can recursively call this isValidBST function on the left child and the right child of the current node. <br /> <br />\n>   If all these three conditions are true then the subtree rooted at the current node is also a Binary Search Tree.\n\n```scala\nisValidBST root:\n    // An empty tree is a valid Binary Search Tree.\n    if root is NULL\n        return True\n\n    leftMax = max node value in root's left subtree\n\n    if leftMax >= root's value\n        return False\n\n    rightMin =  min node value in root's right subtree\n\n    if rightMin <= root's value\n        return False\n\n    if root's left and root's right subtree are BST\n        return True\n\n    return False\n```\n\n![check BST](../Figures/333/Slide1.JPG)\n\n##### How to find min / max node value in a binary tree?\n> We can create a function findMax which will return the max node value in the subtree rooted at the current node. Recursively get max value from the left and right subtrees of the current node.     \n> The max node of the current subtree will be the max value from `left subtree max value`, `right subtree max value`, or `current node value`.    \n> We can use a similar process to get the minimum node value.\n\n```scala\nfindMax in root:\n    // Max node in an empty tree should be smaller than parent.\n    if root is NULL\n        return INT_MIN (Max node is smallest possible value)\n\n    maxValue = max of root's value and root's left subtree and root's right subtree\n    return maxValue\n\n\nfindMin in root:\n    // Min node in an empty tree should be larger than parent.\n    if root is NULL\n        return INT_MAX (Min node is largest possible value)\n\n    minValue = min of root's value and root's left subtree and root's right subtree\n    return minValue\n```\n\n<br />\n\n!?!../Documents/333/slideshow1.json:960,540!?!\n\n<br />\n\n\n##### How to count nodes in a given binary tree?\n> We can create a function countNodes which will return the number of nodes in the subtree rooted at the current node. Recursively get the number of nodes in the left and right subtree of the current node.      \n> Then, the total number of nodes in the subtree rooted at the current node will be 1 (for the current node) plus the number of nodes in the left subtree plus the number of nodes in the right subtree.\n\n```scala\ncountNodes in root:\n    if root is NULL\n        return 0 (No nodes in an empty tree)\n\n    current size = 1 (for current root) + nodes in root's left subtree + nodes in root's right subtree\n    return current size\n```\n\n<br />\n\n!?!../Documents/333/slideshow2.json:960,540!?!\n\n<br />\n\n**Algorithm**\n\n1. Traverse each node of the given tree one by one.\n2. For each node of the given tree:\n    - Perform the following steps to check if the subtree rooted at the current node is a BST:\n      - For each node in the current tree, find the maximum value in the left subtree of the current node, and find the minimum value in the right subtree of the current node.\n      - If the current node is greater than the left subtree's max value **and** smaller than the right subtree's min value **and** the left and right subtrees are also BSTs, then return `True`.\n  \t- Otherwise, the subtree rooted at the current node is not a BST, so return `False`.\n    - If it is a BST, then perform the following steps to count the number of nodes in this subtree:\n      - Recursively get the number of nodes in the left and right subtree of the current node.\n      - Return 1 (for the current node) plus the number of nodes in its left subtree plus the number of nodes in its right subtree.\n3. If the tree rooted at the current node is BST, then its subtrees must contain smaller size BSTs.  In this case, return the current BST size as there is no need to check either of the subtrees.\n4. Otherwise, we need to return the maximum size BST found in the left or right subtree of the current node.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/9RRxBs45/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9RRxBs45\"></iframe>\n\n\n**Complexity Analysis**\n\nHere, $$N$$ and $$H$$ are the number of nodes and the max height of the given tree respectively.\n\n* Time complexity: $$O(N^3)$$.\n\n  - In the `isValidBST` function, each node of the tree is traversed and at each node, the max node value is found in each left subtree and min node value is found in each right subtree.\n  \n    To find the max and min valued nodes we traverse the whole subtrees, which leads to a total of $$O(N)$$ time for both of the functions.\n  \n    Thus, an $$O(N)$$ operation is performed at each node to find the min and max valued node. This is done once for each of the $$N$$ nodes in the tree, which leads to an overall time of $$O(N^2)$$ to determine if the given tree is a Binary Search Tree.\n\n  - The `countNodes` function traverses all of the nodes in the given tree, hence it takes $$O(N)$$ time.\n\n  - In the `largestBSTSubtree` function, we traverse all nodes of the given tree, and for each node, we find if the subtree rooted at the current node is a BST which takes $$O(N^2)$$ time and if it is a BST we count the nodes in this subtree which takes $$O(N)$$ time. Hence, it is $$O(N^2 + N)$$ time operation for each tree node. \n  \n  Thus to check all $$N$$ nodes, this approach requires $$O(N \\cdot (N^2 + N))$$ time.\n  \n* Space complexity: $$O(N)$$.\n\n  - The recursion call stack can take at most $$O(H)$$ space; in the worst-case scenario, the height of the tree will equal $$N$$.\n    \n\n<br/>\n\n---\n\n#### Approach 2: Pre-Order Traversal Optimized\n\n**Intuition**\n\nOne strategy we can use when trying to improve an approach is to identify the bottleneck of the performance and try to fix it. Our time complexity analysis revealed that the `isValidBST` function takes $$O(N^2)$$ time, which makes it a good candidate for us to try to improve. To reduce the time complexity of this step, let's consider if there are any alternative ways to determine if a binary tree is a BST. \nAs it turns out, binary search trees have a special property; the node values, when printed using an in-order traversal, are strictly increasing. We can take advantage of this property to efficiently determine if a subtree is BST or not.\n\nRemember, in BST, all of the node values in the left subtree are lower than the root, and all of the node values in the right subtree are higher than the root. So traversing all left subtree nodes first then the current node and then the right subtree (i.e. inorder-traversal) will traverse the nodes in strictly increasing order of their values. \n\nWe can store the in-order traversal of the given tree in an array, and check if the array is strictly increasing or not.\n\n![inorder](../Figures/333/Slide41.JPG)\n\nFurthermore, we can implement this optimization without using the extra array space. We only need to compare the current node value with the previous node value in the in-order traversal. So we only need to store one variable that points to the previous node and compare it with the current node. If at any step the previous node is not strictly smaller than the current node then the in-order traversal will not be strictly increasing. Hence, it is not a BST. \n\n<br />\n\n!?!../Documents/333/slideshow3.json:960,540!?!\n\n<br />\n\nNow, we can traverse each node of the given tree and check if the subtree rooted at the current node is a valid BST or not in $$O(N)$$ time as opposed to $$O(N^2)$$ time. If it is a BST we can count the nodes in this tree and return the answer. Otherwise, we will look for the largest BST in left and right subtrees.\n\n**Algorithm**\n\n1. Traverse each node in the given tree one by one.\n2. For each node of the given tree:\n    - Perform the following steps to check if the subtree rooted at the current node is a BST.\n      - Check if the in-order traversal of the tree is in sorted order.   \n      - Keep a `previous` variable to point to the previously visited node while performing an in-order traversal of the tree.\n      - Traverse the left subtree first.\n      - Compare the current node with the previous node (if it is the first node of the traversal, then there is no need to compare), if the previous node's value is not smaller than the current node's value then it means the in-order traversal is not in strictly increasing order, so return `false`.\n      - Update `previous` with the current node.\n      - Traverse the right subtree of the current node.\n    - If it is a BST, perform the following steps to count the number of nodes in this subtree.\n      - Recursively get the number of nodes in the left and right subtree of the current node.\n      - Return 1 plus the number of nodes in left subtree plus the number of nodes in right subtree.\n3. If the tree rooted at the current node is a BST, then its subtrees will contain smaller BSTs so return the BST size from here. There is no need to check further.\n4. Otherwise, we need to return the size of the largest BST found in the left or right subtree of the current node.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/ARxtGydi/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ARxtGydi\"></iframe>\n\n\n**Complexity Analysis**\n\nHere, $$N$$ and $$H$$ are the number of nodes and the max height of the given tree respectively.\n\n* Time complexity: $$O(N^2)$$.\n\n   - In the `isValidBST` function, we perform an in-order traversal of the tree rooted at the given node, hence each node is visited once. So it takes $$O(N)$$ time.\n\n  - The `countNodes` function traverses all of the nodes in the given tree, hence it takes $$O(N)$$ time.\n\n  - In the `largestBSTSubtree` function, we traverse all nodes of the given tree, and for each node, we find if the subtree rooted at the current node is a BST which takes $$O(N)$$ time. If it is a BST, we count the nodes in this subtree which also takes $$O(N)$$ time. Hence, it is an $$O(N + N)$$ time operation for each tree node. Thus for $$N$$ nodes it takes $$O(N \\cdot (N + N))$$ time.\n\n* Space complexity: $$O(N)$$.\n\n  - Recursive stack can take at most $$O(H)$$ space; in the worst-case scenario, the height of the tree will equal $$N$$.\n\n\n<br/>\n\n---\n\n#### Approach 3: Post-Order Traversal\n\n**Intuition**\n\nIn the previous approaches, we traversed the tree from root to leaf. This resulted in us checking some of the same subtrees multiple times because a smaller subtree can be a part of many larger subtrees.\n\nFor example, in the first approach, we repeatedly found the minimum and maximum elements in some smaller subtrees. In the second approach, we performed an in-order traversal of smaller subtrees multiple times. Instead of performing repeat calculations, we can bubble up the results `(like minimum, maximum, isSubtreeBST)` from the subtrees. This allows us to evaluate `isValidBST` for each subtree before we evaluate it for the subtree's parent node, thus avoiding redundant traversals.\n\n![repeated-checks](../Figures/333/Slide69.JPG)\n\nBy traversing each tree's children first, we can pass information about subtrees up to the parent. This information can be used by the parent to determine if the parent node is a BST in constant time. \n\nA left subtree needs to tell its parent whether it is BST and the maximum value in it. This allows us to compare the maximum value with the parent\u2019s data to check the BST property. \n\nSimilarly, the right subtree needs to tell its parent whether it is BST and the minimum value it contains.\n\nIn the previous approaches, we also used the `countNodes` function to traverse the same set of nodes on which `isValidBST` was called.     \nWe know that the size of a tree is equal to 1 plus the left subtree size plus the right subtree size.\n\nSo, instead of calling `countNodes` separately, we can pass the number of nodes in the current subtree up to the parent as well to get the size of the current tree in constant time.\n\nThus, the following information must be passed up the tree when finding the largest BST: \n1. Whether each subtree itself is BST.  \n2. The maximum value in the subtree. \n3. The minimum value in the subtree.\n4. Size of the subtree.\n\n<br />\n\n!?!../Documents/333/slideshow4.json:960,540!?!\n\n<br />\n\nWhen checking if a node is the root of a BST, we check if its value is larger than the largest value in the left subtree, smaller than the smallest value in the right subtree, and both the left and right subtrees are also binary search trees.\n\nHowever, we do not need to make all of these checks. We can observe that to determine if the current node is a BST, we only need to use the minimum, and maximum values returned by the calls to its children.\n\nWhen a subtree is not a BST, all the trees this subtree is a part of will also not be binary search trees. So whenever the current subtree is not a BST, instead of returning the minimum and maximum value stored in the tree, we can return $$[-infinity, infinity]$$, such that all of the nodes above this subtree will also fail the BST check.\n\nNote that this return value is the opposite of what we return for a $$NULL$$ node, $$[infinity, -infinity]$$. This range is used so that a $$NULL$$ node will never cause its parent to fail the BST check.\n\n**Algorithm**\n\n1. Traverse each node of the given tree in a post-order manner. <br>That is, visit the left child, then the right child, and then the root node.\n2. For each node, perform the following checks to determine if the subtree rooted at the current node is a BST:\n\t- Current node's value should be smaller than minimum node value of right subtree.\n\t- Current node's value should be greater than maximum node value of left subtree.\n3. If the tree rooted at the current node is BST:\n\t- Calculate the size of the current subtree by adding 1 (for the current node) to the size of the left subtree plus the size of the right subtree.\n4. Otherwise, if the current node is not a BST, return max BST size in left or right subtree of the current node.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/VWk6mmkc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VWk6mmkc\"></iframe>\n\n\n**Complexity Analysis**\n\nHere, $$N$$ and $$H$$ are the number of nodes and the max height of the given tree respectively.\n\n* Time complexity: $$O(N)$$.\n\n  - In `largestBSTSubtree` function, we traverse all nodes of the given tree, and for each node, we find if the subtree rooted at the current node is a BST which takes $$O(1)$$ time and if it is a BST, we calculate the number of nodes in this subtree which also takes $$O(1)$$ time. Thus, for $$N$$ nodes this algorithm takes $$O(N)$$ time.\n\n* Space complexity: $$O(N)$$.\n\n  - Recursive stack can take at most $$O(H)$$ space; in the worst-case scenario, the height of the tree will equal $$N$$.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1213",
            "count": 26,
            "average": "4.962",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "largest-bst-subtree",
    "playgroundData": {
        "9RRxBs45": {
            "playground": {
                "testcaseInput": "",
                "name": "largest-bst-subtree-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "ARxtGydi": {
            "playground": {
                "testcaseInput": "",
                "name": "largest-bst-subtree-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "VWk6mmkc": {
            "playground": {
                "testcaseInput": "",
                "name": "largest-bst-subtree-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}