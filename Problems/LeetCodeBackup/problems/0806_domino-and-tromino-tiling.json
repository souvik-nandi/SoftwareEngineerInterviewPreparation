{
    "id": "806",
    "question": {
        "questionId": "806",
        "questionFrontendId": "790",
        "boundTopicId": null,
        "title": "Domino and Tromino Tiling",
        "titleSlug": "domino-and-tromino-tiling",
        "content": "<p>You have two types of tiles: a <code>2 x 1</code> domino shape and a tromino shape. You may rotate these shapes.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg\" style=\"width: 362px; height: 195px;\" />\n<p>Given an integer n, return <em>the number of ways to tile an</em> <code>2 x n</code> <em>board</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The five different ways are show above.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 1602,
        "dislikes": 607,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "3\n1",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Walmart Global Tech\", \"slug\": \"walmart-labs\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"tiktok\", \"slug\": \"tiktok\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int numTilings(int n) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int numTilings(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def numTilings(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def numTilings(self, n: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint numTilings(int n){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int NumTilings(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar numTilings = function(n) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef num_tilings(n)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func numTilings(_ n: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func numTilings(n int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def numTilings(n: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun numTilings(n: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn num_tilings(n: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function numTilings($n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function numTilings(n: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (num-tilings n)\n  (-> exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec num_tilings(N :: integer()) -> integer().\nnum_tilings(N) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec num_tilings(n :: integer) :: integer\n  def num_tilings(n) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"50.2K\", \"totalSubmission\": \"104.2K\", \"totalAcceptedRaw\": 50164, \"totalSubmissionRaw\": 104225, \"acRate\": \"48.1%\"}",
        "hints": [],
        "solution": {
            "id": "1247",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "3",
        "metaData": "{\n  \"name\": \"numTilings\",\n  \"params\": [\n    {\n      \"name\": \"n\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1247",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\nThe objective of this question is as follows: Count how many ways to completely fill a `2 x n` board using 2 shapes (`2 x 1` dominos and `L` shaped trominos). Note that rotation of these shapes is allowed.\n\nAt first glance, one might consider testing every possible combination of dominos and trominos and then count the ones that completely fill the `2 x n` board.  This can be achieved through backtracking, where we fill the board from left to right and, at each step, we try all valid ways to place a domino or a tromino.  Once the board is full or no tile will fit in the remaining space, we remove the last tile placed (backtrack) to return to the previous board state and try all of the remaining tile placement options. As you can imagine, constructing every possible board would be a time-consuming process. Furthermore, we are not actually interested in finding every possible way to completely fill the board - we are only interested in the number of ways the board can be completely filled. With this in mind, there should be a more efficient way to solve this problem.  It seems like we are stuck now. What else can we do to solve this problem?\n\nWhenever you are not sure how to approach a problem, it is a good idea to draw out the first couple of scenarios. \n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/566292903\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\nTake a close look at the above animation.  Notice that for a board with width `k`, some of the possible tilings can directly be derived from the two previous fully covered boards as shown below. \n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/566292920\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/566292936\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\nHowever, some of the possible tilings cannot be derived from previous fully covered boards directly. Instead, they must be derived from partially covered boards with a width of `k-1` as shown below (e.g. a fully covered board of width `k=3` can be derived from a partially covered board of width `k=2`).\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/566292948\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\nThe above animations provide a basic idea of where the possible tilings come from for a board with width $$k$$. Let's find out how we can derive an algorithm from these patterns.\n\nNow, let's define:\n- **Fully covered board**: All tiles on board are covered by a _domino_ or a _tromino_.\n- **Partially covered board**: Same as a **_fully covered board_**, except leave the tile in the upper-right corner (the top row of the rightmost column) uncovered.  Note, a board with only the lower-right corner uncovered is also considered \"partially covered.\" However, as we will discover soon, we do not need to keep track of which corner is uncovered because of symmetry.\n- $$f(k)$$: The number of ways to **_fully cover a board_** of width $$k$$.\n- $$p(k)$$: The number of ways to **_partially cover a board_** of width $$k$$.\n\nWe can determine the number of ways to fully or partially tile a board of width $$k$$ by considering every possible way to arrive at $$f(k)$$ or $$p(k)$$ by placing a domino or a tromino.  Let's find $$f(k)$$ together and then you can pause to practice by finding $$p(k)$$ on your own.  All of the ways to arrive at a fully tiled board of width $$k$$ are as follows:\n\n- From $$f(k-1)$$ we can add 1 vertical domino for each tiling in a fully covered board with a width of $$k-1$$, as shown in the second animation.\n- From $$f(k-2)$$ we can add 2 horizontal dominos for each tiling in a fully covered board with a width of $$k-2$$, as shown in the third animation.\n    - Note that we don't need to add 2 **vertical** dominos to $$f(k-2)$$, since $$f(k-1)$$ will cover that case and it will cause duplicates if we count it again.\n- From $$p(k-1)$$ we can add an L-shaped tromino for each tiling in a partially covered board with a width of $$k-1$$, as shown above (in the fourth animation).\n    - We will **multiply by $$p(k-1)$$ by 2** because for any partially covered tiling, there will be a horizontally symmetrical tiling of it. For example, the animation below shows two $$p(k - 1)$$ board states that are identical when reflected over the horizontal edge of the board. Logically, there must be an equal number of ways to fully tile the board from both $$p(k - 1)$$ states.  So rather than count the number of ways twice, we simply multiply the number of ways from one $$p(k - 1)$$ state by 2.\n\nSumming the ways to reach $$f(k)$$ gives us the following equation:\n<center>\n$$f(k) = f(k-1) + f(k-2) + 2 * p(k-1)$$\n</center>  \n<br/>\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/566292973\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n<!-- ![Tromino horizontally symmetrical flip](../Documents/790/tromino_flip.gif) -->\n\nNow that we know where tilings on $$f(k)$$ are coming from, how about $$p(k)$$? Can we apply the same logic and find that out? Absolutely yes!\n\nTake a pen and start drawing scenarios that contribute to $$p(4)$$ (this is a good technique to aid critical thinking during an interview). Start by drawing $$p(4)$$, remember $$p(4)$$ is a board of width 4 with the first 3 columns fully covered and the last column half covered. Now, try removing a domino or a tromino to find which scenarios contribute to $$p(4)$$. Notice that $$p(k)$$ can come from the below scenarios: \n- Adding a tromino to a fully covered board of width $$k-2$$ (i.e. $$f(k-2)$$)\n- Adding a horizontal domino to a partially covered board of width $$k-1$$ (i.e. $$p(k-1)$$)\n\nThus, we arrive at the following conclusion for $$p(k)$$: \n\n<center>\n$$p(k) = p(k-1) + f(k-2)$$\n</center>\n\n<br />\n\nWith all this information, we are very close to our first approach - **Dynamic Programming**.\n\n> Why Dynamic Programming?   \n> \n> When a question asks us to minimize, maximize, or find the number of ways to do something, it doesn't always mean that dynamic programming is the best approach, but it is usually a good indicator that we should at least consider using a dynamic programming approach.  \n> \n> The number of ways to reach the current state depends on the number of ways to reach the previous state. This can be seen in the functions $$f(k)$$ and $$p(k)$$ which depend on previous fully and partially filled boards. When using dynamic programming, these functions are called *transition functions*.\n\n</br>\n\n---\n\n#### Approach 1: Dynamic Programming (Top-down)\n\n**Intuition**\n\nIn this approach, we will use the two *transition functions* as the recurrence relation. Then we will create a recursive solution from the top ($$f(n)$$) to the bottom (base cases described in the algorithm section) since it's generally more intuitive to solve dynamic programming problems in a top-down manner. Additionally, to avoid repeat calculations, we will memoize the result for each subproblem by storing the calculated results in two maps (`f_cache` and `p_cache`). Note that in the python implementation, this will be handled automatically by the `@cache` decorator.\n\n**Algorithm**\n\n1. We'll start from $$f(n)$$ and then dive all the way down to the base cases, $$f(1)$$, $$f(2)$$, and $$p(2)$$. \n2. Use the same definition for $$f$$ and $$p$$ from the **_Overview_** section\n    - $$f(k)$$: The number of ways to **_fully cover a board_** of width $$k$$\n    - $$p(k)$$: The number of ways to **_partially cover a board_** of width $$k$$\n3. Recursion calls will use the results of subproblems and base cases to help us get the final result, $$f(n)$$.\n    - The stop condition for the recursive calls is when $$k$$ reaches a base case (i.e. $$k <= 2$$). \n    - Values for the base cases will be directly returned instead of making more recursive calls. \n        - $$f(1) = 1$$\n        - $$f(2) = 2$$\n        - $$p(2) = 1$$\n    - To avoid repeated computations, we will use 2 hashmaps (`f_cache` and `p_cache`) to store calculated values for $$f$$ and $$p$$. In Python, the built-in `@cache` wrapper will automatically maintain these hashmaps for us.\n4. If $$k$$ is greater than $$2$$, then we will make recursive calls to $$f$$ and $$p$$ according to the transition function:\n    - $$f(k) = f(k-1) + f(k-2) + 2 * p(k-1)$$  \n    - $$p(k) = p(k-1) + f(k-2)$$  \n5. $$f(n)$$ will be returned once all recursive calls are finished.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/Txjc6teR/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Txjc6teR\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the width of the board.\n\n* Time complexity: $$O(N)$$\n\n    From top ($$N$$) to bottom ($$1$$), there will be $$N$$ non-memoized recursive calls to $$f$$ and to $$p$$, where each non-memoized call requires constant time. Thus, $$O(2 \\cdot N)$$ time is required for the non-memoized calls.  \n\t\n\tFurthermore, there will be $$2 \\cdot N$$ memoized calls to $$f$$ and $$N$$ memoized calls to $$p$$, where each memoized call also requires constant time. Thus $$O(3 \\cdot N)$$ time is required for the memoized calls. \n\t\n\tThis leads to a time complexity of $$O(2 \\cdot N + 3 \\cdot N) = O(N)$$.\n\n* Space complexity: $$O(N)$$\n\n    Each recursion call stack will contain at most $$N$$ layers. Also, each hashmap will use $$O(N)$$ space. Together this results in $$O(N)$$ space complexity.\n    \n---\n\n#### Approach 2: Dynamic Programming (Bottom-up)\n\n**Intuition**\n\nOne of the drawbacks to the previous top-down DP solution is that it uses a recursive call stack which requires additional time and space to maintain.  When we know that all of the subproblems (i.e. $$f(1)$$ through $$f(n-1)$$) must be solved and there is a logical order to the subproblems (i.e. $$f(1)$$ must be solved before $$f(2)$$, and $$f(2)$$ before ... $$f(n-1)$$), then bottom-up DP will generally be more efficient than top-down DP because it will solve the same number of subproblems and do so without maintaining a call stack. Different from the previous *top-down* solution, this solution will be in a *bottom-up* fashion. As such, we will start by calculating the base case (when $$n$$ is very small, like 0, 1, 2 etc.), then move to the next case (when $$n$$ grows to a larger number) and gradually get the result for the final case $$f(n)$$.\n\n\n**Algorithm**\n1. Create two arrays, $$f$$ and $$p$$, of size $$n+1$$, where $$f(k)$$ represents the number of ways to **_fully cover a board_** of width $$k$$ and $$p(k)$$ represents the number of ways to **_partially cover a board_** of width $$k$$ (as described in the overview).\n2. Initialize $$f$$ and $$p$$ according to the following base cases:\n    - $$f(1) = 1$$ because to **_fully cover a board_** of width 1, there is only one way, add one vertical domino.\n    - $$f(2) = 2$$ because to **_fully cover a board_** of width 2, there are two ways, either add two horizontal dominos or add two vertical dominos.\n    - $$p(2) = 1$$ because to **_partially cover a board_** of width 2, there is only one way using an L-shaped tromino (leave the upper-right corner uncovered).\n3. Iterate $$k$$ from $$2$$ to $$n$$ (inclusive) and at each iteration update $$f$$ and $$p$$ according to the transition functions we derived in the overview: \n    - $$f(k) = f(k-1) + f(k-2) + 2 * p(k-1)$$  \n    - $$p(k) = p(k-1) + f(k-2)$$\n4. Return $$f(n)$$ which now represents the number of ways to **_fully cover a board_** of width $$n$$.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/fv8ZmyRP/shared\" frameBorder=\"0\" width=\"100%\" height=\"446\" name=\"fv8ZmyRP\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the width of the board. \n\n* Time complexity: $$O(N)$$\n\n    Array iteration requires $$N-2$$ iterations where each iteration takes constant time. \n\n* Space complexity: $$O(N)$$\n\n    Two arrays of size $$N+1$$ are used to store the number of ways to fully and partially tile boards of various widths between $$1$$ and $$N$$.\n\n---\n\n#### Approach 3: Dynamic Programming (Bottom-up, space optimization)\n\n**Intuition**\n\nIn the previous approach, we used arrays of length $$N+1$$ to store the number of ways to fully and partially cover boards of varying width. In total $$O(N)$$ space was used for this purpose. However, based on the *transition function*, we find that only $$f(n - 1)$$, $$f(n - 2)$$ and $$p(n - 1)$$ are used in each iteration. One of the benefits of bottom-up dynamic programming is that we have some control over how long to cache the result of each subproblem.  For instance if the result of a subproblem like $$f(3)$$ is only needed to find the result for $$f(4)$$ and $$f(5)$$, then we no longer need to store the result for $$f(3)$$ after $$f(4)$$ and $$f(5)$$ have been calculated.  \n\nThus, instead of using an entire array to store this information, we can use just 3 numeric variables to store the result of $$f(k-1)$$, $$f(k-2)$$, and $$p(k-1)$$. In this way, we can further optimize the space complexity to $$O(1)$$!\n\n**Algorithm**\n\n1. Create three numerical variables, \n    - `fCurrent` represents $$f(k-1)$$, where $$f(k)$$ is number of ways to **_fully cover a board_** of width $$k$$.\n    - `pCurrent` represents $$p(k-1)$$, where $$p(k)$$ is number of ways to **_partially cover a board_** (as described in the **_Overview_** section) of width $$k$$.\n    - `fPrevious` represents $$f(k-2)$$.\n\n    Since `k` starts from 3, the three variables will have the following initial values:\n    - `fCurrent = 2` (i.e. $$f(k-1) = f(2) = 2$$), because there are two ways to **_fully tile a board_** of width 2: add two vertical dominos or add two horizontal dominos.\n    - `pCurrent = 1` (i.e. $$p(k-1) = p(2) = 1$$), because there is exactly one way to **_partially cover a board_** with one column.\n        - Besides, $$p(1) = 0$$, because it is impossible to **_partially cover a board_** with one column.\n    - `fPrevious = 1` (i.e. $$f(k-2) = f(1) = 1$$), because there is exactly one way to **_fully cover a board_** of width 1: add one vertical domino.\n\n2. Iterate $$k$$ from $$3$$ to $$n$$ (inclusive) and at each iteration update the above three variables according to the transition functions:\n    - $$f(k) = f(k-1) + f(k-2) + 2 * p(k-1)$$  \n    - $$p(k) = p(k-1) + f(k-2)$$\n\n    By applying the optimization mentioned in the *intuition* section, we get the following:   \n    - `fCurrent = fCurrent + fPrevious + 2 * pCurrent`\n    - `pCurrent = pCurrent + fPrevious`\n    - `fPrevious = fCurrent` (use the value of `fCurrent` before its update in the first step)\n\n3. Return `fCurrent` which now represents the number of ways to **_fully cover a board_** of width $$n$$.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/n4f9DtgV/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"n4f9DtgV\"></iframe>\n\n\n**Complexity Analysis**\n\n* Time complexity: $$O(N)$$\n\n    Array iteration takes $$O(N)$$ time where $$N$$ is the width of the board.\n\n* Space complexity: $$O(1)$$\n\n    Only a constant number of numeric (`long`/`int`) variables were used. \n\n---\n\n#### Approach 4: Matrix Exponentiation\n\n**Intuition**  \n\nMatrix Exponentiation? It's a big word, but don't let it scare you! It's a simple math technique based on the previous dynamic programming idea. The only prerequisite knowledge you need is [Matrix Multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication). Trust me, this approach will help turn matrix exponentiation from a big word into a piece of cake.\n\nPreviously, we used the following *transition function*:\n<center>\n$$f(k) = f(k-1) + f(k-2) + 2 * p(k-1)$$ \n\n$$p(k) = p(k-1) + f(k-2)$$\n</center>\n\nNow, let's take this relationship and convert it to a matrix representation as shown below. We will discuss why it's represented this way later, for now, let's just follow along.\n\n![Matrix Exponentiation 1](../Documents/790/matrix_expo_1.svg)\n\n> Notice, the 1, 1, 2 in the first row corresponds to the one $$f(k-1)$$, one $$f(k-2)$$, and two $$p(k-1)$$ that add up to $$f(k)$$.\n\nBy replacing $$k$$ with $$k-1$$, we will get:\n\n![Matrix Exponentiation 2](../Documents/790/matrix_expo_2.svg)\n\n> Notice, the leftmost matrix is now the same as the rightmost matrix from the first step.\n\nTake the equation above and insert it in the first equation. This gives us the following equation:\n\n![Matrix Exponentiation 3](../Documents/790/matrix_expo_3.svg)\n\nThis process can be repeated until the base case is reached:\n\n![Matrix Exponentiation 4](../Documents/790/matrix_expo_4.svg)\n\nWe can use the equation above to find the relationship between the target case ($$f(k)$$) and the base cases. Take the `3 x 3` matrix and multiply it by itself $$k-2$$ times, and we will arrive at the solution for $$f(k)$$.\n\nNow we've covered the basic idea of matrix exponentiation; but why we are doing it like this and how did this decomposition of the *transition functions* come up in the first place?\n\nFirst, matrix exponentiation is a technique, just like binary search, depth-first search, etc. It's not supposed to be something you come up with on your own, instead, it is something that you can learn and apply elsewhere.\n\nNow, let's follow up with some experimental conclusions about matrix exponentiation:\n\n![Matrix Exponentiation 5](../Documents/790/matrix_expo_5.svg)\n\n- It's often possible to solve a `Dynamic Programming (DP)` question with `Matrix Exponentiation` when there is a DP *transition function*  \n- The integer matrix (the second matrix) has to be a square matrix (`m x n`, where `m = n`, we will use `m x m` for simplicity). This is because only the square matrix doesn't change its dimension after multiplication, meaning it will still be `m x m` after multiplication.\n- The dimension of the third matrix has to be `m x 1`, it should include all used elements on the right side of the *transition function*. In our case, they are $$f(k-1)$$, $$f(k-2)$$ and $$p(k-1)$$.\n- The first matrix will be the same as the third matrix, except that we will use $$k+1$$ to replace $$k$$.\n- With knowledge of the first matrix, the third matrix, *transition function*, and the fact that the second matrix must be a square matrix, you can fill in the values of the second matrix on your own using basic matrix multiplication knowledge.\n  - $$f(k) = 1 * f(k - 1) + 1 * f(k - 2) + 2 * p(k - 1)$$ (transition function)\n  - $$f(k - 1) = 1 * f(k - 1) + 0 * f(k - 2) + 0 * p(k - 1)$$\n  - $$p(k) = 0 * f(k - 1) + 1 * f(k - 2) + 1 * p(k - 1)$$ (transition function)\n\nWith the above knowledge, a good practice question will be [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/). See if this time you can come up with a matrix exponentiation solution by yourself.\n\n**Algorithm**\n\n1. Again, we use the same definition of `f` and `p` as previously described in the **_Overview_** section\n    - $$f(k)$$: The number of ways to **_fully cover a board_** of width $$k$$\n    - $$p(k)$$: The number of ways to **_partially cover a board_** of width $$k$$\n2. Pre-calculate base cases:\n    - $$f(1) = 1$$ because to **_fully cover a board_** of width 1, there is only one way, add one vertical domino.\n    - $$f(2) = 2$$ because to **_fully cover a board_** of width 2, there are two ways, either add two horizontal dominos or add two vertical dominos.\n    - $$p(2) = 1$$ because to **_partially cover a board_** of width 2, there is only one way using a L-shaped tromino (leave the upper-right corner uncovered).\n3. Prepare the square matrix based on the transition function.\n4. Create a function/method to calculate [matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication).\n5. Calculate the square matrix multiplication `k-2` times iteratively.\n6. Take the resulting square matrix from the above step and calculate $$f(k)$$ as shown below:\n\n![Matrix Exponentiation 4](../Documents/790/matrix_expo_4.svg)\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/QJrJocHE/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"QJrJocHE\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the width of the board.\n\n* Time complexity: $$O(N)$$\n\n    We need to perform matrix multiplication of `3 x 3` matrix $$N - 2$$ times which will take $$O(N)$$ time. This dominates the time costs of the rest of operations.\n\n* Space complexity: $$O(1)$$\n\n    We only used a `3 x 3` matrix and a few other numeric variables.\n\n---\n\n#### Approach 5: Matrix Exponentiation (time optimization, space/time trade off)\n\n\n**Intuition**\n\nIn the previous method, we calculate the matrix $$M$$ to the power of $$n$$ in an iterative fashion. This iterative approach is equivalent to calculating $$M$$ times $$M$$ times $$M$$ ... for $$n$$ times. This is why the previous approach requires linear time. \n\nHowever, when finding the result of some number (or matrix in this case) to the power of another number, there is an optimization we can use to perform the operation in logarithmic time. If you are unfamiliar with this optimization, we encourage you to try [50. Pow(x, n)](https://leetcode.com/problems/powx-n/). Which uses the same optimization but for a less complicated problem.\n\nTo use this optimization, we must first observe that $$M^n$$ is equivalent to $$M^{n/2} \\cdot M^{n/2}$$ which is equivalent to $$(M^{n/4} \\cdot M^{n/4})$$ $$\\cdot$$ $$(M^{n/4} \\cdot M^{n/4})$$. Thus, we can obtain $$M^n$$ by recursively dividing the power by 2 and multiplying the results until we reach $$M^1$$, which is just $$M$$. As long as $$n$$ is an even number, this process can be represented as the following binary tree. \n\n![Matrix Exponentiation Optimization](../Documents/790/matrix_expo_optimization.svg)\n\nWhat if $$n$$ is an odd number, you may ask. Well, if $$n$$ is odd then $$n-1$$ will be even, we can apply the above process on $$n-1$$ and take the result of $$pow(M, n-1)$$ and multiply it with the base. This will result in $$pow(M, n) = pow(M, n-1) * M$$.\n\nOne basic fact about the binary tree is that the binary tree is a recursive data structure. By using recursion, we can reduce the time complexity down to the height of the tree, which is $$\\log(n)$$. At the same time, we will use a cache to avoid repeat calculations. As you may have noticed, the same number is being used multiple times during the calculation.\n\n**Algorithm**\n\nThe algorithm used here is very similar to the previous approach.  The only difference is, in step 4, we will use **recursion** to perform the square matrix multiplication rather than iteration.     \n\n1. Again, we use the same definition of `f` and `p` as previously described in the **_Overview_** section\n    - $$f(k)$$: The number of ways to **_fully cover a board_** of width $$k$$\n    - $$p(k)$$: The number of ways to **_partially cover a board_** of width $$k$$\n2. Pre-calculate base cases:\n    - $$f(1) = 1$$ because to **_fully cover a board_** of width 1, there is only one way, add one vertical domino.\n    - $$f(2) = 2$$ because to **_fully cover a board_** of width 2, there are two ways, either add two horizontal dominos or add two vertical dominos.\n    - $$p(2) = 1$$ because to **_partially cover a board_** of width 2, there is only one way using a L-shaped tromino (leave the upper-right corner uncovered).\n3. Prepare the square matrix based on the previous description.\n4. Create a function/method to calculate matrix multiplication **recursively**.\n5. Calculate the square matrix multiplication `k-2` times recursively. Meanwhile, store the intermediate results in a map to avoid repeat calculations (caching).\n6. Take the square matrix that results from the above step and calculate $$f(k)$$ as shown below:\n![Matrix Exponentiation 4](../Documents/790/matrix_expo_4.svg)\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/9FdBk6Sj/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9FdBk6Sj\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the width of the board.\n\n* Time complexity: $$O(\\log N)$$\n\n    With the use of recursion and memoization, we only need to make one calculation per level of the recursion tree. As previously shown, the number of matrix multiplications can be further reduced down to $$O(\\log N)$$. \n\n* Space complexity: $$O(\\log N)$$\n\n   Stack space of $$O(\\log N)$$ will be used due to recursion. Also, an extra $$O(\\log N)$$ space will be used for caching/memoization during recursion, since we used a map to store the intermediate results, where the key is an integer and the value is a 3 by 3 matrix. Together they will take $$O(\\log N)$$ space.\n\n---\n\n\n#### Approach 6: Math optimization (Fibonacci sequence like)\n\n> Hint: Can you take the transition functions from *Approach 2* and get rid of $$p$$?\n\n**Intuition**\n\nThis is the ultimate optimization for this question, there won't be any advance to the time or space complexity, but it will make the code cleaner and the logic much more clear. It's all based on simple math operations and 5 other solutions we discussed previously. Let's take a closer look at the derivation below.\n\n![Derive Process](../Documents/790/fibonacci-like-derive.svg)\n\nDoes this final result remind you of something? Yes, the Fibonacci Sequence had a similar *transition function*. Now, we can remove $$p(k)$$ from our *transition function*, and focus solely on $$f(k)$$. With this new *transition function*, we can re-apply every single method we mentioned earlier. Here we will observe a replica of *approach 2*. For practice, you can try out the method mentioned in *Approach 5* with this new *transition function*.\n\n**Algorithm**\n\nThis algorithm is very similar to *Approach 3: Space Optimized Bottom-up DP*, but this time, we only need one transition function, and we no longer need to use $$p$$.\n1.  Create three numeric variables.\n    - `fCurrent` represents $$f(k-1)$$, where $$f(k)$$ is number of ways to **_fully cover a board_** of width $$k$$.\n    - `fPrevious` represents $$f(k-2)$$.\n    - `fBeforePrevious` represents $$f(k-3)$$.\n\n    Since `k` starts from 4, the three variables will have the following initial values:\n    - $$fCurrent = 5$$ (i.e. $$f(k-1) = f(3) = 5$$), because there are five ways to **_fully tile a board_** of width 3 (as shown in the first animation in the **_Overview_** section).\n    - $$fPrevious = 2$$ (i.e. $$f(k-2) = f(2) = 2$$), because there are two ways to **_fully tile a board_** of width 2 (as shown in the first animation in the **_Overview_** section).\n    - $$fBeforePrevious = 1$$ (i.e. $$f(k-3) = f(1) = 1$$), because there is exactly one way to **_fully cover a board_** of width 1: add one vertical domino\n\n2. Iterate $$k$$ from $$4$$ to $$n$$ and at each iteration update the above three variables according to the transition function mentioned previously: $$f(k) = 2*f(k-1) + f(k-3)$$\n\n3. Return `fCurrent` which now represents the number of ways to fully tile a board of width $$n$$.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/gXwAYoAP/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"gXwAYoAP\"></iframe>\n\n> Don't forget to try out the $$O(\\log N)$$ matrix exponentiation solution with this new *transition function*.\n\n**Complexity Analysis**\n\n* Time complexity: $$O(N)$$\n\n    Array iteration takes $$O(N)$$ time, where $$N$$ is the width of the board.\n\n* Space complexity: $$O(1)$$\n    \n    Only a constant number of numeric (`long`/`int`) variables were used.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1252",
            "count": 70,
            "average": "4.700",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "domino-and-tromino-tiling",
    "playgroundData": {
        "Txjc6teR": {
            "playground": {
                "testcaseInput": "",
                "name": "domino-and-tromino-tiling-5",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "fv8ZmyRP": {
            "playground": {
                "testcaseInput": "",
                "name": "domino-and-tromino-tiling-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "n4f9DtgV": {
            "playground": {
                "testcaseInput": "",
                "name": "domino-and-tromino-tiling-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "QJrJocHE": {
            "playground": {
                "testcaseInput": "",
                "name": "domino-and-tromino-tiling-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "9FdBk6Sj": {
            "playground": {
                "testcaseInput": "",
                "name": "domino-and-tromino-tiling-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "gXwAYoAP": {
            "playground": {
                "testcaseInput": "",
                "name": "domino-and-tromino-tiling-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}