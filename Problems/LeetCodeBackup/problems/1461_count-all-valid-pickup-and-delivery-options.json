{
    "id": "1461",
    "question": {
        "questionId": "1461",
        "questionFrontendId": "1359",
        "boundTopicId": null,
        "title": "Count All Valid Pickup and Delivery Options",
        "titleSlug": "count-all-valid-pickup-and-delivery-options",
        "content": "<p>Given <code>n</code> orders, each order consist in pickup and delivery services.&nbsp;</p>\n\n<p>Count all valid pickup/delivery possible sequences such that delivery(i) is always after of&nbsp;pickup(i).&nbsp;</p>\n\n<p>Since the answer&nbsp;may be too large,&nbsp;return it modulo&nbsp;10^9 + 7.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> All possible orders: \n(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\nThis is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 90\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 1571,
        "dislikes": 144,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "1\n2\n3",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Math",
                "slug": "math",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Combinatorics",
                "slug": "combinatorics",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"DoorDash\", \"slug\": \"doordash\", \"timesEncountered\": 23}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int countOrders(int n) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int countOrders(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def countOrders(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def countOrders(self, n: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint countOrders(int n){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int CountOrders(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar countOrders = function(n) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef count_orders(n)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func countOrders(_ n: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func countOrders(n int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def countOrders(n: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun countOrders(n: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn count_orders(n: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function countOrders($n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function countOrders(n: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (count-orders n)\n  (-> exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec count_orders(N :: integer()) -> integer().\ncount_orders(N) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec count_orders(n :: integer) :: integer\n  def count_orders(n) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"53.3K\", \"totalSubmission\": \"84.3K\", \"totalAcceptedRaw\": 53294, \"totalSubmissionRaw\": 84327, \"acRate\": \"63.2%\"}",
        "hints": [
            "Use the permutation and combination theory to add one (P, D) pair each time until n pairs."
        ],
        "solution": {
            "id": "1303",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "1",
        "metaData": "{\n  \"name\": \"countOrders\",\n  \"params\": [\n    {\n      \"name\": \"n\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "834",
            "date": "2022-03-06",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1303",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nWe have $$N$$ orders, each order consists of a pickup and delivery service.       \nWe have to count all valid pickup/delivery sequences. A valid sequence means that for all elements, delivery of the $$i^{th}$$ element will occur after picking up the $$i^{th}$$ element.\n\n<img src=\"../Figures/1359/Slide1.PNG\" width=\"960\" alt=\"some combinations\"> <br />\n\n--- \n\n#### Approach 1: Recursion with Memoization (Top-Down DP)\n\n**Intuition**\n\nA trivial way to approach this problem is to recursively explore every valid pickup and delivery option.  \nWe can do so by iterating over all of the orders, and for each order, if it is not picked up, pick up the order, mark the order as picked up, and make another recursive call. If the order is already picked up but not delivered, then deliver the order and mark it as delivered. After delivering all packages, we return from the recursive call and unmark the deliveries and pickups so that we can use them in another combination. This step of discarding a chosen element and then using that element during later recursive calls is called <b>[backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/)</b>.\nHence, we can solve this problem using a recursive backtracking algorithm.   \n\nThis approach is **not optimal** and will result in **Time Limit Exceeded**. Let's try optimizing it further.     \n\nIn this backtracking approach, we pick up each order one by one in order to generate all valid combinations. This step of generating all valid combinations is very time-consuming as we must visit every possible combination once. Since the problem asks us \"**count** all valid pickup/delivery sequences,\" let's see if we can count the number of combinations without actually generating them.\n\nIf there are $$n$$ unpicked orders, then we have $$n$$ different options for orders that we can pick up at the current step. So instead of picking up each order one by one and making a recursive call for each one, we could count the number of ways to pick $$(n-1)$$ unpicked orders and multiply it by the number of choices at the current step, $$n$$.\nThus, we improved the approach from calling the function $$n$$ times to only calling once.       \nLikewise, we can apply the same idea for delivering the orders.\n\nIf we pick one order then we need to count ways for the rest remaining orders.    \nNow, how to count ways for the remaining orders? Well, you might have noticed, it is similar problem but with a smaller input.      \nThus, we can break this problem into some smaller **subproblems** and it can be solved recursively.    \n\n> If you're new to recursion, this may be a challenging problem to solve. You may wish to check out the [recursion explore card](https://leetcode.com/explore/featured/card/recursion-i/) and become more comfortable with recursion by practicing on less difficult problems before returning.\n\nLet's say we have `unpicked` number of orders that have not been picked up and `undelivered` number orders to be delivered.\nIf we want to pick one order then there are `unpicked` different choices to pick at the current step. Or if we want to deliver one order then there are `undelivered - unpicked` (orders which are picked but not delivered) different choices.\n\nHence, we can say,\n```\n// If we want to pick one order then,\nwaysToPick = unpicked * totalWays(unpicked - 1, undelivered)\n\n// If we want to deliver one order then,    \nwaysToDeliver = (undelivered - unpicked) * totalWays(unpicked, undelivered - 1)\n```\nThis recursive pattern is known as a **recurrence relation.**\n\nFor recursive approaches, we need base cases. \n\n>Base cases are states (any combination of `unpicked` and `undelivered`) for which we can calculate the answer without using recursion. \n\nNow what could be our base cases, when should we stop the recursion? \nWhen we deliver all the orders that means we have generated some combination of pickup and delivery, so we can count this sequence, thus `return 1`.\n\nSome of the subproblems occur again and again, thus these subproblems are also **overlapping** - for example, we would need to calculate `totalWays(4, 5)` in both `totalWays(4, 6)` and `totalWays(5, 5)`.\n\n<img src=\"../Figures/1359/Slide2.PNG\" width=\"960\" alt=\"recursion tree\"> <br />\n\nBy caching the result of each subproblem, we can avoid recalculating previously seen subproblems, hence improving the time complexity.\n\nThis optimization technique of storing the results of the expensive function calls and returning the cached result when the input occurs again is called **memoization**.\n\n**Algorithm**\n\n1. Initialize some variables:\n    - `MOD` as $$10^{9} + 7$$ to prevent integer overflow (as stated in the problem description).\n    - `memo`, a data structure that we will use to cache results to prevent duplicate computation.       \n      In python, we will use [@cache](https://docs.python.org/3/library/functools.html), which can automatically memoize the function's return values for each combination of input arguments and will return the cached result if the function is called again with the same combination of arguments. \n\n2. Create a function `totalWays(unpicked, undelivered)` that will be used for recursion.\n    - First, check if we have delivered all the orders (`unpicked == 0` and `undelivered == 0`). If they are all delivered, `return 1`.\n    - We can't deliver/pick up more than `N` orders or deliver more orders than we picked up. If `unpicked < 0` or `undelivered < 0` or `undelivered < unpicked`, then `return 0`.\n    - Check if this subproblem has already been visited once. If it has, then return the cached result.\n    - Otherwise, add the ways to pick `unpicked` and deliver `undelivered` orders while preventing integer overflow.\n    - At the end of each recursive call, store the number of valid pickup and delivery options for the current subproblem in the cache and return it.\n\n3. Call the function we created in step 2 (`totalWays`) with the initial input values of `N` unpicked and `N` undelivered orders.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/RLgfeZXC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"RLgfeZXC\"></iframe>\n\n\n**Complexity Analysis**\n\nIf $$N$$ is the number of the orders given.\n\n* Time complexity: $$O(N^2)$$.    \n \n  The recursive function would have made approximately $$2^N$$ recursive calls, but due to caching, we will avoid recomputation of results, and only unique function calls may result in more recursive calls. The recursive function depends on two variables (`unpicked` and `undelivered`). Since the values for `unpicked` and `undelivered` must be in the range $$0$$ to $$N$$, there will be at most $$(N + 1) \\cdot (N + 1)$$ unique function calls.\n\n* Space complexity: $$O(N^2)$$.     \n\n  Our cache must store the results for all of the unique function calls that are valid states. There are approximately $$N^{2}/2$$ valid states.\n    \n<br/>\n\n---\n\n#### Approach 2: Tabulation (Bottom-Up DP)\n\n**Intuition**\n   \nThe top-down dynamic programming approach requires some time and space to maintain a function call stack. To avoid the overhead that results from using a recursive function, we can use bottom-up dynamic programming (tabulation) instead. Since tabulation is performed iteratively, it does not require a function call stack.   \n\n> If you are not familiar with Dynamic Programming, then be sure to check out our distinguished [Dynamic Programming Explore Card](https://leetcode.com/explore/learn/card/dynamic-programming/).\n\nIn the recursive approach, the variables that change are the number of unpicked and undelivered orders. Hence, each state in our DP table will be some combination of values for `unpicked` and `undelivered`. \n\nWhat is a state? If we picture this scenario in real life, what information do we need at any given moment? We only need to know what is the number of unpicked and undelivered orders. In a DP problem (iterative or recursive), a state is a set of variables that can sufficiently describe a scenario. \n\nSo in this problem let's define a state `(unpicked, undelivered)`, where `dp[unpicked][undelivered]` denotes, the number of ways to arrange the `unpicked` unpicked and `undelivered` undelivered orders.    \nWhen all orders are picked and delivered (`unpicked` and `undelivered` are `0`) it is assumed there is one way to arrange the `0` remaining orders, hence `dp[0][0] = 1`. Which will be our base case.       \n\nWe build our table in a bottom-up manner. Going bottom-up is a common strategy for dynamic programming problems, in which we first solve smaller problems and use those already solved smaller problems to solve a bigger problem.\n\nIf there are $$n$$ unpicked orders then we have $$n$$ choices of picking orders, so the number of ways to pick these $$n$$ orders will be $$n$$ multiplied by the number of ways to pick $$(n-1)$$ orders, which will already be stored in the DP table.   \n\nLet's say we have `unpicked` number of orders to be picked and `undelivered` orders to be delivered.     \nIf we want to pick one order then there are `unpicked` different choices to pick at the current step. Or if we want to deliver one order then there are `undelivered - unpicked` (orders which are picked but not delivered) different choices.\n\nHence, we can say,\n```\n// There are some unpicked elements left. \nif unpicked > 0\n    // We have the choice to pick any one of those orders.\n    waysToPick += unpicked * dp[unpicked - 1][undelivered]\n\n// Delivery done are less than picked orders.\nif undelivered > unpicked \n    // We have the choice to deliver any one of (undelivered - unpicked) orders. \n    waysToDeliver += (undelivered - unpicked) * dp[unpicked][undelivered - 1]\n```\n\n!?!../Documents/1359/slideshow1.json:960,540!?!\n\n**Algorithm**\n\n1. Initialize some variables:\n    - `MOD` as $$10^{9} + 7$$ to prevent integer overflow (as stated in the problem description).\n    - `dp`, a data structure that will be used to store all subproblems results.\n\n2. We iterate over each subproblem of unpicked and undelivered orders.        \n  We start from the base case `(unpicked = 0 and undelivered = 0)` and increment `undelivered` count whenever we reach `undelivered` equal to `N`, we increment `unpicked` count and reset `undelivered` to `unpicked` count because the count of undelivered orders can't be less than unpicked orders `(i.e. delivered orders can't be more than picked orders)`.              \n  The outer loop will iterate over unpicked orders and the inner loop will iterate over undelivered orders.           \n    - If both the unpicked and undelivered orders are `0`, the number of ways to arrange them is `1`.\n    - Otherwise, add the ways to pick unpicked and deliver undelivered orders with handling the integer overflow.\n\n3. Return the number of ways to pick and deliver `N` unpicked and undelivered orders, stored in `dp[N][N]`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/GTmGnH6T/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"GTmGnH6T\"></iframe>\n\n\n**Complexity Analysis**\n\nIf $$N$$ is the number of the orders given.\n\n* Time complexity: $$O(N^2)$$.\n\n  We have two state variables, and each subproblem is a configuration of those two state variables. Thus, there will be at most $$(N + 1) \\cdot (N + 1)$$ unique subproblems and we will iterate over half of them using two nested for loops.\n\n* Space complexity: $$O(N^2)$$.     \n\n  Our DP table must be large enough to store all of the $$(N + 1) \\cdot (N + 1)$$ possible states.\n\n  > **Note:** You can further reduce the space complexity of this approach as we can see in the slideshow while building the DP table we only need previous and current rows. Thus instead of keeping an $$N \\cdot N$$ size array we could just keep two $$N$$ size arrays. \n  > It would follow the same approach explained above, but it's not implemented here.\n    \n<br/>\n\n---\n\n#### Approach 3: Permutations (Math)\n\n**Intuition**\n\nLet's assume we want to place 4 different objects `(A, B, C, D respectively)` in some order in a row, what are all the possible ways to do it?        \nNow how can we approach this problem?\n\nWe can say we have 4 empty positions and at each position, we have to place one object.      \nAt the 1st position, we can place any one of the 4 objects so we have 4 choices here.        \nAt the 2nd position, we can only place any one of 3 objects because one object is already placed at the 1st position.      \nAt the 3rd position, we can place any one of the remaining 2 objects (2 objects are already placed).     \nAt the 4th position, we can place the remaining 1 object (3 objects are already placed).     \n\nHence, total number of ways to place $$4$$ different objects = $$4 \\cdot 3 \\cdot 2 \\cdot 1 = 4! $$.    \n\n<img src=\"../Figures/1359/Slide4.PNG\" width=\"960\" alt=\"rearrange\"> <br />\n\n> A permutation is a mathematical calculation of the **number of ways** a particular set can be arranged, where the order of the arrangement matters.\n\nNow, the given problem can be changed to a similar permutations problem.  \n    \nWe have $$N$$ orders each with a pickup and delivery, let's denote $$P_i = Pickup \\space of \\space i^{th} \\space order,$$ and $$D_i = Delivery \\space of \\space i^{th} \\space order$$.     \n\nWe have $$2N$$ empty positions and we need to count all ways to place all $$P_i$$ and $$D_i$$ such that all $$D_i$$ is placed after $$P_i$$.\n\nSo, we first place all the $$N$$ pickups in some random order as we don't have any constraints on placing pickups.            \nAs we saw with an example above, to place $$N$$ different objects, we have $$N!$$ ways. So $$N$$ pickups can be placed in $$N!$$ ways.     \n\nNow, let's take an example of 4 orders.\n\n<img src=\"../Figures/1359/Slide5A.PNG\" width=\"960\" alt=\"pickups\"> <br />\n \nNow we start placing all the deliveries one by one.     \nThe last pickup was `P3`, hence for `D3` we have only **one** place i.e. after `P3`.     \n\n<img src=\"../Figures/1359/Slide5B.PNG\" width=\"960\" alt=\"del-1\"> <br />\n\nNow, the second last pickup was `P1`, so we have **three** places to place the delivery `D1`.\n\n<img src=\"../Figures/1359/Slide6.PNG\" width=\"960\" alt=\"del-2\"> <br />\n\nSimilarly, for `D4` we have **five** places and for `D2` we have **seven** places.\n\n<img src=\"../Figures/1359/Slide7.PNG\" width=\"960\" alt=\"del-4\"> <br />\n\nSo, the number of ways to place all deliveries is $$1 \\cdot 3 \\cdot 5 \\cdot 7$$.\n\nThus, we can come to the formula that, to place $$N$$ pickups we have $$N!$$ ways,     \nand to place the $$N$$ deliveries we have $$1 \\cdot 3 \\cdot 5 \\space \\cdot .... \\cdot \\space (2N-1)$$ ways.\n\n> So, **total ways to arrange all pickups and deliveries are, $$ N! * \\prod_{i=1}^{N} (2 * i - 1) $$.**\n\n**Algorithm**\n\n1. Initialize some variables:\n    - `MOD` as $$10^{9} + 7$$ to prevent integer overflow (as stated in the problem description).\n    - `ans`, to store the final result.\n\n2. Calculate the number of ways to arrange pickups and deliveries, `i.e. $$N!$$ and $$\\prod_{i=1}^{N} (2 * i - 1) $$` and multiply them to calculate total ways to arrange pickups and deliveries for `N` orders with handling the overflow.\n\n3. Return the final result `ans`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/fbBaDtZ7/shared\" frameBorder=\"0\" width=\"100%\" height=\"344\" name=\"fbBaDtZ7\"></iframe>\n\n\n**Complexity Analysis**\n\nIf $$N$$ is the number of the orders given.\n\n* Time complexity: $$O(N)$$.     \n\n  To calcualte $$N!$$ and $$\\prod_{i=1}^{N} (2 * i - 1) $$ we need to iterate over $$N$$ elements. \n\n* Space complexity: $$O(1)$$.     \n\n  We have used only constant space to store the result.\n    \n<br/>\n\n---\n\n#### Approach 4: Probability (Math)\n\n**Intuition**\n\nProbability is simply how likely something is to happen.       \nWe can generate the mathematical formula using probability and permutations concepts.\n\n<img src=\"../Figures/1359/Slide23.PNG\" width=\"960\" alt=\"prob4\"> <br />\n\nLet's define a favorable outcome as a sequence where each $$P_i$$ occurs before $$D_i$$.      \nThus for this problem, \n> (Number of arrangements of N orders in a valid sequence) = (Probability of arranging N orders in a valid sequence) * (Total number of possible arrangements with N orders)\n\n<br />\n\n<u>Calculating Probability: </u>\n\nIf we have only 1 order, i.e. one pickup $$P1$$ and one delivery $$D1$$.  \nTwo arrangements are possible, `$$P1 \\space D1$$` and `$$D1 \\space P1$$`.       \nThus, the probability to arrange one pickup and delivery in the right sequence is, `$$1 / 2$$`.\n\nIf we have $$N$$ orders and the pickup/delivery is reversed for any one of the orders, then the sequence is not valid.  \nSo to have a valid sequence of $$N$$ orders, we must have all $$N$$ pairs of $$P_i$$ and $$D_i$$ in the correct order, where each pair has a probability of $$1 / 2$$ of being in the correct order. \nSo, the probability of arranging $$N$$ orders in a valid sequence is:\n$$ = 1/2 \\cdot 1/2 \\cdot 1/2 \\cdot \\space..... \\space \\cdot 1/2 $$ (N times)   \n$$ \\bf{ = 1 / 2^N} $$\n\n\n<u>Total Number of Outcomes: </u> \n\nTotal number of arrangements possible using $$2N$$ objects ($$N$$ pickups and $$N$$ deliveries) is, $$\\bf{(2N)!}$$.\n\n<u>Total Number of Favorable Outcomes: </u>\n\n> Thus, **total number of arrangements possible** using $$2N$$ objects in right sequence is, $$\\bf{(2N)! / 2^N}$$.\n\n**Algorithm**\n\n1. Initialize some variables:\n    - `MOD` = to handle the integer overflow as stated in the problem.\n    - `ans` = to store the final result.\n\n2. Calculate $$(2N)! / 2^N$$ and return it.\n \n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/hGugoLoZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"hGugoLoZ\"></iframe>\n\n\n**Complexity Analysis**\n\nIf $$N$$ is the number of the orders given.\n\n* Time complexity: $$O(N)$$.     \n  - For calculating $$(2N)!$$ we need to iterate over $$2N$$ elements. \n  - And for calculating $$1 / 2^N$$ we multiply $$2$$ N-times.\n  - Thus, it leads to a time complexity of $$O(N)$$.\n\n* Space complexity: $$O(1)$$.     \n  We have used only constant space to store the result.\n\n  > **Note:** In python, we can use the `$$factorial()$$` function, a direct function that can compute the factorial of a number without writing the whole code for computing factorial.     \n  > But then the approach will not count as `$$O(1)$$` space, the reason is that in the worst case we will calculate `$$factorial(2 * n)$$` which may have a lot of digits. The way python handles extremely long numbers is that it requires an extra `$$4$$` bytes of memory every time the number increases by a factor of `$$2^{30}$$`.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1308",
            "count": 69,
            "average": "4.855",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "count-all-valid-pickup-and-delivery-options",
    "playgroundData": {
        "RLgfeZXC": {
            "playground": {
                "testcaseInput": "",
                "name": "count-all-valid-pickup-and-delivery-options-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "GTmGnH6T": {
            "playground": {
                "testcaseInput": "",
                "name": "count-all-valid-pickup-and-delivery-options-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "fbBaDtZ7": {
            "playground": {
                "testcaseInput": "",
                "name": "count-all-valid-pickup-and-delivery-options-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "hGugoLoZ": {
            "playground": {
                "testcaseInput": "",
                "name": "count-all-valid-pickup-and-delivery-options-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}