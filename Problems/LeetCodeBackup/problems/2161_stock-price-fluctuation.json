{
    "id": "2161",
    "question": {
        "questionId": "2161",
        "questionFrontendId": "2034",
        "boundTopicId": null,
        "title": "Stock Price Fluctuation ",
        "titleSlug": "stock-price-fluctuation",
        "content": "<p>You are given a stream of <strong>records</strong> about a particular stock. Each record contains a <strong>timestamp</strong> and the corresponding <strong>price</strong> of the stock at that timestamp.</p>\n\n<p>Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream <strong>correcting</strong> the price of the previous wrong record.</p>\n\n<p>Design an algorithm that:</p>\n\n<ul>\n\t<li><strong>Updates</strong> the price of the stock at a particular timestamp, <strong>correcting</strong> the price from any previous records at the timestamp.</li>\n\t<li>Finds the <strong>latest price</strong> of the stock based on the current records. The <strong>latest price</strong> is the price at the latest timestamp recorded.</li>\n\t<li>Finds the <strong>maximum price</strong> the stock has been based on the current records.</li>\n\t<li>Finds the <strong>minimum price</strong> the stock has been based on the current records.</li>\n</ul>\n\n<p>Implement the <code>StockPrice</code> class:</p>\n\n<ul>\n\t<li><code>StockPrice()</code> Initializes the object with no price records.</li>\n\t<li><code>void update(int timestamp, int price)</code> Updates the <code>price</code> of the stock at the given <code>timestamp</code>.</li>\n\t<li><code>int current()</code> Returns the <strong>latest price</strong> of the stock.</li>\n\t<li><code>int maximum()</code> Returns the <strong>maximum price</strong> of the stock.</li>\n\t<li><code>int minimum()</code> Returns the <strong>minimum price</strong> of the stock.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;StockPrice&quot;, &quot;update&quot;, &quot;update&quot;, &quot;current&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;minimum&quot;]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n<strong>Output</strong>\n[null, null, null, 5, 10, null, 5, null, 2]\n\n<strong>Explanation</strong>\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].\nstockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].\nstockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.\nstockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.\nstockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.\n                          // Timestamps are [1,2] with corresponding prices [3,5].\nstockPrice.maximum();     // return 5, the maximum price is 5 after the correction.\nstockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].\nstockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timestamp, price &lt;= 10<sup>9</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made <strong>in total</strong> to <code>update</code>, <code>current</code>, <code>maximum</code>, and <code>minimum</code>.</li>\n\t<li><code>current</code>, <code>maximum</code>, and <code>minimum</code> will be called <strong>only after</strong> <code>update</code> has been called <strong>at least once</strong>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 602,
        "dislikes": 38,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Time Based Key-Value Store\", \"titleSlug\": \"time-based-key-value-store\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[\"StockPrice\",\"update\",\"update\",\"current\",\"maximum\",\"update\",\"maximum\",\"update\",\"minimum\"]\n[[],[1,10],[2,5],[],[],[1,3],[],[4,2],[]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Design",
                "slug": "design",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Data Stream",
                "slug": "data-stream",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Ordered Set",
                "slug": "ordered-set",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 36}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"3\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class StockPrice {\npublic:\n    StockPrice() {\n        \n    }\n    \n    void update(int timestamp, int price) {\n        \n    }\n    \n    int current() {\n        \n    }\n    \n    int maximum() {\n        \n    }\n    \n    int minimum() {\n        \n    }\n};\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice* obj = new StockPrice();\n * obj->update(timestamp,price);\n * int param_2 = obj->current();\n * int param_3 = obj->maximum();\n * int param_4 = obj->minimum();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class StockPrice {\n\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        \n    }\n    \n    public int current() {\n        \n    }\n    \n    public int maximum() {\n        \n    }\n    \n    public int minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = new StockPrice();\n * obj.update(timestamp,price);\n * int param_2 = obj.current();\n * int param_3 = obj.maximum();\n * int param_4 = obj.minimum();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class StockPrice(object):\n\n    def __init__(self):\n        \n\n    def update(self, timestamp, price):\n        \"\"\"\n        :type timestamp: int\n        :type price: int\n        :rtype: None\n        \"\"\"\n        \n\n    def current(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def maximum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def minimum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice()\n# obj.update(timestamp,price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class StockPrice:\n\n    def __init__(self):\n        \n\n    def update(self, timestamp: int, price: int) -> None:\n        \n\n    def current(self) -> int:\n        \n\n    def maximum(self) -> int:\n        \n\n    def minimum(self) -> int:\n        \n\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice()\n# obj.update(timestamp,price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n\ntypedef struct {\n    \n} StockPrice;\n\n\nStockPrice* stockPriceCreate() {\n    \n}\n\nvoid stockPriceUpdate(StockPrice* obj, int timestamp, int price) {\n  \n}\n\nint stockPriceCurrent(StockPrice* obj) {\n  \n}\n\nint stockPriceMaximum(StockPrice* obj) {\n  \n}\n\nint stockPriceMinimum(StockPrice* obj) {\n  \n}\n\nvoid stockPriceFree(StockPrice* obj) {\n    \n}\n\n/**\n * Your StockPrice struct will be instantiated and called as such:\n * StockPrice* obj = stockPriceCreate();\n * stockPriceUpdate(obj, timestamp, price);\n \n * int param_2 = stockPriceCurrent(obj);\n \n * int param_3 = stockPriceMaximum(obj);\n \n * int param_4 = stockPriceMinimum(obj);\n \n * stockPriceFree(obj);\n*/",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class StockPrice {\n\n    public StockPrice() {\n        \n    }\n    \n    public void Update(int timestamp, int price) {\n        \n    }\n    \n    public int Current() {\n        \n    }\n    \n    public int Maximum() {\n        \n    }\n    \n    public int Minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = new StockPrice();\n * obj.Update(timestamp,price);\n * int param_2 = obj.Current();\n * int param_3 = obj.Maximum();\n * int param_4 = obj.Minimum();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "\nvar StockPrice = function() {\n    \n};\n\n/** \n * @param {number} timestamp \n * @param {number} price\n * @return {void}\n */\nStockPrice.prototype.update = function(timestamp, price) {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.current = function() {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.maximum = function() {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.minimum = function() {\n    \n};\n\n/** \n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "class StockPrice\n    def initialize()\n        \n    end\n\n\n=begin\n    :type timestamp: Integer\n    :type price: Integer\n    :rtype: Void\n=end\n    def update(timestamp, price)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def current()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def maximum()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def minimum()\n        \n    end\n\n\nend\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice.new()\n# obj.update(timestamp, price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "\nclass StockPrice {\n\n    init() {\n        \n    }\n    \n    func update(_ timestamp: Int, _ price: Int) {\n        \n    }\n    \n    func current() -> Int {\n        \n    }\n    \n    func maximum() -> Int {\n        \n    }\n    \n    func minimum() -> Int {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * let obj = StockPrice()\n * obj.update(timestamp, price)\n * let ret_2: Int = obj.current()\n * let ret_3: Int = obj.maximum()\n * let ret_4: Int = obj.minimum()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "type StockPrice struct {\n    \n}\n\n\nfunc Constructor() StockPrice {\n    \n}\n\n\nfunc (this *StockPrice) Update(timestamp int, price int)  {\n    \n}\n\n\nfunc (this *StockPrice) Current() int {\n    \n}\n\n\nfunc (this *StockPrice) Maximum() int {\n    \n}\n\n\nfunc (this *StockPrice) Minimum() int {\n    \n}\n\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Update(timestamp,price);\n * param_2 := obj.Current();\n * param_3 := obj.Maximum();\n * param_4 := obj.Minimum();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "class StockPrice() {\n\n    def update(timestamp: Int, price: Int) {\n        \n    }\n\n    def current(): Int = {\n        \n    }\n\n    def maximum(): Int = {\n        \n    }\n\n    def minimum(): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class StockPrice() {\n\n    fun update(timestamp: Int, price: Int) {\n        \n    }\n\n    fun current(): Int {\n        \n    }\n\n    fun maximum(): Int {\n        \n    }\n\n    fun minimum(): Int {\n        \n    }\n\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "struct StockPrice {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockPrice {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn update(&self, timestamp: i32, price: i32) {\n        \n    }\n    \n    fn current(&self) -> i32 {\n        \n    }\n    \n    fn maximum(&self) -> i32 {\n        \n    }\n    \n    fn minimum(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * let obj = StockPrice::new();\n * obj.update(timestamp, price);\n * let ret_2: i32 = obj.current();\n * let ret_3: i32 = obj.maximum();\n * let ret_4: i32 = obj.minimum();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class StockPrice {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $timestamp\n     * @param Integer $price\n     * @return NULL\n     */\n    function update($timestamp, $price) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function current() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function maximum() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * $obj = StockPrice();\n * $obj->update($timestamp, $price);\n * $ret_2 = $obj->current();\n * $ret_3 = $obj->maximum();\n * $ret_4 = $obj->minimum();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "class StockPrice {\n    constructor() {\n\n    }\n\n    update(timestamp: number, price: number): void {\n\n    }\n\n    current(): number {\n\n    }\n\n    maximum(): number {\n\n    }\n\n    minimum(): number {\n\n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define stock-price%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; update : exact-integer? exact-integer? -> void?\n    (define/public (update timestamp price)\n\n      )\n    ; current : -> exact-integer?\n    (define/public (current)\n\n      )\n    ; maximum : -> exact-integer?\n    (define/public (maximum)\n\n      )\n    ; minimum : -> exact-integer?\n    (define/public (minimum)\n\n      )))\n\n;; Your stock-price% object will be instantiated and called as such:\n;; (define obj (new stock-price%))\n;; (send obj update timestamp price)\n;; (define param_2 (send obj current))\n;; (define param_3 (send obj maximum))\n;; (define param_4 (send obj minimum))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec stock_price_init_() -> any().\nstock_price_init_() ->\n  .\n\n-spec stock_price_update(Timestamp :: integer(), Price :: integer()) -> any().\nstock_price_update(Timestamp, Price) ->\n  .\n\n-spec stock_price_current() -> integer().\nstock_price_current() ->\n  .\n\n-spec stock_price_maximum() -> integer().\nstock_price_maximum() ->\n  .\n\n-spec stock_price_minimum() -> integer().\nstock_price_minimum() ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_price_init_(),\n%% stock_price_update(Timestamp, Price),\n%% Param_2 = stock_price_current(),\n%% Param_3 = stock_price_maximum(),\n%% Param_4 = stock_price_minimum(),\n\n%% stock_price_init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule StockPrice do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec update(timestamp :: integer, price :: integer) :: any\n  def update(timestamp, price) do\n\n  end\n\n  @spec current() :: integer\n  def current() do\n\n  end\n\n  @spec maximum() :: integer\n  def maximum() do\n\n  end\n\n  @spec minimum() :: integer\n  def minimum() do\n\n  end\nend\n\n# Your functions will be called as such:\n# StockPrice.init_()\n# StockPrice.update(timestamp, price)\n# param_2 = StockPrice.current()\n# param_3 = StockPrice.maximum()\n# param_4 = StockPrice.minimum()\n\n# StockPrice.init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"36.7K\", \"totalSubmission\": \"74.9K\", \"totalAcceptedRaw\": 36658, \"totalSubmissionRaw\": 74926, \"acRate\": \"48.9%\"}",
        "hints": [
            "How would you solve the problem for offline queries (all queries given at once)?",
            "Think about which data structure can help insert and delete the most optimal way."
        ],
        "solution": {
            "id": "1458",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"StockPrice\",\"update\",\"update\",\"current\",\"maximum\",\"update\",\"maximum\",\"update\",\"minimum\"]\n[[],[1,10],[2,5],[],[],[1,3],[],[4,2],[]]",
        "metaData": "{\n  \"classname\": \"StockPrice\",\n  \"constructor\": {\n    \"params\": []\n  },\n  \"methods\": [\n    {\n      \"params\": [\n        {\n          \"type\": \"integer\",\n          \"name\": \"timestamp\"\n        },\n        {\n          \"type\": \"integer\",\n          \"name\": \"price\"\n        }\n      ],\n      \"name\": \"update\",\n      \"return\": {\n        \"type\": \"void\"\n      }\n    },\n    {\n      \"params\": [],\n      \"name\": \"current\",\n      \"return\": {\n        \"type\": \"integer\"\n      }\n    },\n    {\n      \"params\": [],\n      \"name\": \"maximum\",\n      \"return\": {\n        \"type\": \"integer\"\n      }\n    },\n    {\n      \"params\": [],\n      \"name\": \"minimum\",\n      \"return\": {\n        \"type\": \"integer\"\n      }\n    }\n  ],\n  \"return\": {\n    \"type\": \"boolean\"\n  },\n  \"systemdesign\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1458",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nWe are given a stream of **records** of the **price** of stock at different **timestamps**. We need to implement some functions to get the lowest, highest, and latest price of the stock based on the records provided.     \n      \nThe records do not come in chronological order. Another record with the same timestamp may appear later in the stream, correcting the price of the previous wrong record; this correction can affect the lowest, highest, and latest price of the stock.\n\nLet's walk through an example to make sure we clearly understand what this problem is asking. Suppose the stock prices in increasing order of timestamp are, $$ [2, 10, 3, 3, 5, 9] $$.       \nHere, the lowest price of the stock is $$ 2 $$, the highest price is $$ 10 $$, and the latest price is $$ 9 $$.       \n- If the $$ 1^{st} $$ record is corrected from $$ 2 $$ to $$ 4 $$, then the lowest price changes from $$ 2 $$ to $$ 3 $$. \n- If the last record is corrected from $$ 9 $$ to $$ 6 $$, then the latest price changes to $$ 6 $$.      \n- If $$ 2^{nd} $$ record is corrected from $$ 10 $$ to $$ 20 $$, then the highest price changes to $$ 20 $$. \n\nThus, we need to store all the records of the stock price and make corrections when necessary.        \nWe can use a hashmap to store timestamp as key and price as value, where the correction of records will only take constant time.\n\nNow we need to get the highest and lowest price of the stock. We could think of sorting the stock prices but when an update or an insertion of a new price is made we would need to sort the prices again.\n\nThus, we will prefer using a data structure that allows us to track the current minimum and maximum values efficiently. We can use a sorted set, sorted map, or min and max-heaps; the intuition will remain the same only the implementation will differ. \nAll these data structures keep the elements sorted, and the insertion and removal of elements take only logarithmic time.\n\n---\n\n#### Approach 1: Hashed and Sorted Map\n\n**Intuition**\n\nWe will use a hashmap (`timestampPriceMap`) to store the price of the stocks. A hashmap stores the elements as key-value pairs. Here, our key is the timestamp and the value is the price of the stock at the respective timestamp, i.e. the hashmap maps `timestamp` to `price`.    \n\nNow, we will use a sorted map (`priceFrequency`) to store the stock prices in increasing order.         \nA sorted map also stores the elements as key-value pairs and keeps elements sorted on the basis of the key. Thus, we will store the price of the stocks as the key and its occurrence (count) in our records stream as the value, i.e. the sorted map maps the `price` to the `frequency`. It denotes how many times a price is present in our records stream.\n\n**Insertion of Record:**     \n- Insert the stock price at the current timestamp in `timestampPriceMap`.\n- Increase the stock price's count in `priceFrequency`. Initially, it is assumed the count is 0 when the price is not present in the map.   \n\n**Updation of Record:**     \n- Update the stock price of the current timestamp in `timestampPriceMap`.       \n- Decrease the count of the old price from `priceFrequency` and if the count reaches $$ 0 $$ then remove it and increase the correct stock price's count.\n\n**Get the Latest Price:**\n- Use one variable to keep track of the latest time and get the stock's price at the latest time from `timestampPriceMap`.\n\n**Get Minimum and Maximum Stock Price:** \n- The first element's key of `priceFrequency` is the lowest price of the stock.\n- The last element's key of `priceFrequency` is the highest price of the stock.\n\n!?!../Documents/2034/slideshow1.json:960,540!?!\n\n<br />\n\n\n\n**Algorithm**\n\n1. Initialize variables:\n    - `latestTime`, variable to store the latest timestamp according to the records.\n    - `timestampPriceMap`, a hashmap to store timestamp and prices of the stock.\n    - `priceFrequency`, a sorted map to store all prices in increasing order.\n2. In the `update` function, the current record can be a new record or a correction to an old record:\n    - Try to update `latestTime`, to the current timestamp.\n    - If the current timestamp is already present in `timestampPriceMap` it means this record is a correction then we reduce the count of the old price from `priceFrequency`.\n    - Add/update the current timestamp's price in `timestampPriceMap`.\n    - Increment the count of the current timestamp's price in `priceFrequency`.\n3. In the `current` function, we need to return the latest price of the stock, i.e. price of the stock at `latestTime` in `timestampPriceMap`.\n4. In the `maximum` function, we need to return the maximum stock price, i.e. the key of the last element in `priceFrequency's`.\n5. In the `minimum` function, we need to return the minimum stock price, i.e. the key of the first element in `priceFrequency's`.\n\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/4jGoRcuN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4jGoRcuN\"></iframe>\n\n\n\n**Complexity Analysis**\n\nIf $$ N $$ is the number of records in the input stream.\n\n* Time complexity: $$ O(N \\log N) $$\n\n  - In the `update` function, we add and remove a record in both hashmap and sorted map. In hashmap, both operations take constant time, but in the sorted map they take $$ O(\\log N) $$ time.\n\n  - Each call to the `maximum`, `minimum`, or `current` function will take only constant time to return the result.\n    > But in Java, getting first or last element of tree map takes `log(N)` time. Thus, here `maximum`, `minimum` functions will take `O(log(N))` time for each function call.\n  \n  - In the worst-case scenario, all $$ N $$ calls will be to the `update` function, which will require a total of $$ O(N \\log N) $$ time. \n\n\n* Space complexity: $$ O(N) $$\n\n  -  In the `update` function, we add and remove a record in both the hashmap and sorted map. Thus each function call takes $$ O(1) $$ space. So for $$ N $$ update calls, it will take $$ O(N) $$ space.\n\n  - The `maximum`, `minimum`, and `current` functions do not use any additional space.\n\n  - Thus, in the worst-case, we will add all $$ N $$ records in both the hashmap and sorted map, which takes $$ O(N) $$ space.\n\n<br />\n\n---\n\n\n\n#### Approach 2: Hashmap and Heaps\n\n**Intuition**\n\nIn this approach, again, we will use a hashmap (`timestampPriceMap`) to record the stock's price at each `timestamp`. \n\nHowever, it is not necessary for us to maintain a sorted map as we did in the previous approach. Any time we need to efficiently keep track of the lowest or highest value, we should consider using a heap data structure. Here, we will store each record in 2 different heaps, a min-heap to efficiently track the lowest stock price and a max-heap to efficiently track the highest stock price.\n\nNow the real challenge will be, how to update stock prices?     \nWe can directly change the stock price in the hashmap, but in the heaps, we would have to pop all stock prices until the old price comes on top and then push the new price and all other popped prices back. This would make the update operation very costly.\n\nOne way to resolve this issue is every time we get a new price, we push it into each heap, and only while getting the top element we need to verify if the price is correct or outdated.   \n\nBut how do we know which prices are outdated?        \nFor this, we can use our hashmap (`timestampPriceMap`). Every time we receive a `(price, timestamp)` pair, we will set the value for the key (`timestamp`) to the given `price`. If the `timestamp` already exists in the hashmap, we overwrite the old price. \nSo, when finding the maximum or minimum price, we will check to see if the `(price, timestamp)` pair on the top of the heap agrees with the `price` listed for the `timestamp` in the hashmap. If it does not, then the price is outdated, and we discard this pair and get the next top element and again check with the hashmap.           \n\n\n**Insertion/Updation of Record:**     \n- Insert/Update the stock price at the current timestamp in `timestampPriceMap`.\n- Push the `(price, timestamp)` pair into the `minHeap` and `maxHeap`.  \n\n**Get the Latest Price:**\n- Use one variable to keep track of the latest time and get the stock's price at the latest time from `timestampPriceMap`.\n\n**Get Minimum and Maximum Stock Price:** \n- Get the `(price, timestamp)` pair from the top of `minHeap`/`maxHeap`.\n- If `timestampPriceMap[timestamp] != price`, it means the price for the current `timestamp` was updated and that this `price` is outdated. So we discard this pair and repeat the above step. Otherwise, return the current `price`.\n\n!?!../Documents/2034/slideshow2.json:960,540!?!\n\n<br />\n\n\n\n**Algorithm**\n\n1. Initialize variables:\n    - `latestTime`, variable to store the latest timestamp according to the records.\n    - `timestampPriceMap`, a hashmap to store timestamp and prices of the stock.\n    - `minHeap, maxHeap`, heaps to store `(price, timestamp)` pairs and sort elements based on `price`.\n2. In the `update` function, the current record can be a new record or a correction to an old record:\n    - Try to update `latestTime`, to the current timestamp.\n    - Add/update the current timestamp's price in `timestampPriceMap`.\n    - Push `(price, timestamp)` pair in the heaps.\n3. In the `current` function, we need to return the latest price of the stock, i.e. price of the stock at `latestTime` in `timestampPriceMap`.\n4. In the `maximum` / `minimum` function, we get the `(price, timestamp)` pair from the top of `maxHeap` / `minHeap`. If `timestampPriceMap[timestamp]` is not same as `price`, we discard this pair and repeat the same step again. Otherwise, return the current `price`.\n\n**Implementation**\n\n> **Note:** In python, in min-heap we push stock prices after multiplying with `-1` so that the min-heap behaves as a max-heap. This helps in keeping the implementation simpler.    \n\n<iframe src=\"https://leetcode.com/playground/KsYu7HKG/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"KsYu7HKG\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$ N $$ be the number of records in the input stream.\n\n* Time complexity: $$ O(N \\log N) $$\n\n  - In the `update` function, we add one record to the hashmap and to each heap. Adding the record to the hashmap takes constant time. However, for a heap, each push operation takes $$ O(\\log N) $$ time. So for $$ N $$ update calls, it will take $$ O(N\\log N) $$ worst-case time.\n\n  - Each `current` function call takes only constant time to return the result. \n  \n  - In the `maximum` and `minimum` functions, we pop any outdated records that are at the top of the heap. In the worst-case scenario, we might pop $$ (N - 1) $$ elements and each pop takes $$ O(\\log N) $$ time, so it might seem for one function call the time complexity is $$N \\log N$$, so for $$ N $$ functions calls it could be $$ N^{2} \\log N $$. \n  However, when we pop a record from the heap, it's gone and won't be popped again. So overall, if we push $$N$$ elements into a heap, we cannot pop more than $$N$$ elements, taking into account all function calls. Thus, calls to `maximum` and `minimum` will at most require $$ O(N \\log N) $$ time.\n\n\n\n* Space complexity: $$ O(N) $$\n\n  -  In the `update` function, we add a record to the hashmap and each heap. Since each stock price takes $$ O(1) $$ space, for $$ N $$ update calls, it will take $$ O(N) $$ space.\n\n  - The `current` function does not use any additional space.\n\n  - In the `maximum` and `minimum` functions, we only remove elements from the heap thus these functions also do not use any additional space.\n\n  - Thus, in the worst-case, we will add all $$ N $$ records to the hashmap and to both heaps, which takes $$ O(N) $$ space.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1463",
            "count": 11,
            "average": "5.000",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "stock-price-fluctuation",
    "playgroundData": {
        "4jGoRcuN": {
            "playground": {
                "testcaseInput": "",
                "name": "stock-price-fluctuation-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "KsYu7HKG": {
            "playground": {
                "testcaseInput": "",
                "name": "stock-price-fluctuation-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}