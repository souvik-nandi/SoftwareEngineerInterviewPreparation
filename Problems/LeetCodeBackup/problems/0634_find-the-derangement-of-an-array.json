{
    "id": "634",
    "question": {
        "questionId": "634",
        "questionFrontendId": "634",
        "boundTopicId": null,
        "title": "Find the Derangement of An Array",
        "titleSlug": "find-the-derangement-of-an-array",
        "content": "<p>In combinatorial mathematics, a <strong>derangement</strong> is a permutation of the elements of a set, such that no element appears in its original position.</p>\n\n<p>You are given an integer <code>n</code>. There is originally an array consisting of <code>n</code> integers from <code>1</code> to <code>n</code> in ascending order, return <em>the number of <strong>derangements</strong> it can generate</em>. Since the answer may be huge, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 180,
        "dislikes": 145,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "3\n2",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Math",
                "slug": "math",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"IXL\", \"slug\": \"ixl\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int findDerangement(int n) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int findDerangement(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def findDerangement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def findDerangement(self, n: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint findDerangement(int n){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int FindDerangement(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar findDerangement = function(n) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef find_derangement(n)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func findDerangement(_ n: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func findDerangement(n int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def findDerangement(n: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun findDerangement(n: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn find_derangement(n: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function findDerangement($n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function findDerangement(n: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (find-derangement n)\n  (-> exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec find_derangement(N :: integer()) -> integer().\nfind_derangement(N) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec find_derangement(n :: integer) :: integer\n  def find_derangement(n) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"8.8K\", \"totalSubmission\": \"21.4K\", \"totalAcceptedRaw\": 8850, \"totalSubmissionRaw\": 21390, \"acRate\": \"41.4%\"}",
        "hints": [],
        "solution": {
            "id": "193",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "3",
        "metaData": "{\r\n  \"name\": \"findDerangement\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"n\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "193",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Approach 1: Brute Force\n\n\nThe simplest solution is to consider every possible permutation of the given numbers from $$1$$ to $$n$$ and count the number of permutations which are dereangements of the \noriginal arrangement. \n\n\n**Complexity Analysis**\n\n* Time complexity : $$O\\big((n+1)!\\big)$$. $$n!$$ permutations are possible for $$n$$ numbers. For each permutation, we need to traverse over the whole arrangement to check if it \nis a derangement or not, which takes $$O(n)$$ time.\n\n* Space complexity : $$O(n)$$. Each permutation would require $$n$$ space to be stored.\n<br />\n<br />\n---\n#### Approach 2: Recursion\n\n**Algorithm**\n\nIn order to find the number of derangements for $$n$$ numbers, firstly we can consider the the original array to be \n`[1,2,3,...,n]`. Now, in order to generate the derangements of this array, assume that firstly, we move the number 1 from \nits original position and place at the place of the number $$i$$. But, now, this $$i^{th}$$ position can be chosen \nin $$n-1$$ ways. Now, for placing the number $$i$$ we have got two options:\n\n1. We place $$i$$ at the place of $$1$$: By doing this, the problem of finding the derangements reduces to finding the derangements of the \nremaining $$n-2$$ numbers, since we've got $$n-2$$ numbers and $$n-2$$ places, such that every number can't be placed at exactly one position.\n\n2. We don't place $$i$$ at the place of $$1$$: By doing this, the problem of finding the derangements reduces to finding the \nderangements for the $$n-1$$ elements(except 1). This is because, now we've got $$n-1$$ elements and these $$n-1$$ elements can't be placed at \nexactly one location(with $$i$$ not being placed at the first position).\n\n![Derangement_Split](../Figures/634/634_Find_Derangements_split.PNG)\n{:align=\"center\"}\n\nBased, on the above discussion, if $$d(n)$$ represents the number of derangements for $$n$$ elements, it can be obtained as:\n\n$$d(n) = (n-1) \\cdot [d(n-1) + d(n-2)]$$\n\nThis is a recursive equation and can thus, be solved easily by making use of a recursive function.\n\nBut, if we go with the above method, a lot of duplicate function calls wiil be made, with the same parameters being passed. This is because the same state can be reached through various paths in the recursive tree. In order to avoid these duplicate calls, we can store the result of a function call, once its made, \ninto a memoization array. Thus, whenever the same function call is made again, we can directly return the result from this memoization array. \nThis helps to prune the search space to a great extent.\n\n> **Caution:** The maximum recursion depth of this implementation is $$n$$. So when $$n$$ is very large, it is possible to exceed the recursion limit or the memory limit.  As such, the following code **will not** pass all test cases.  Thus, in the following approaches we will discuss two improvements that can be applied to circumvent this issue. \n\n<iframe src=\"https://leetcode.com/playground/ZAQZ4ne4/shared\" frameBorder=\"0\" width=\"100%\" height=\"344\" name=\"ZAQZ4ne4\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. $$memo$$ array of length $$n$$ is filled once only.\n\n* Space complexity : $$O(n)$$. $$memo$$ array of length $$n$$ is used.\n<br />\n<br />\n---\n\n#### Approach 3: Dynamic Programming\n\n**Algorithm**\n\nAs we've discussed above, the recursive formula for finding the derangements for $$n$$ elements is given by:\n\n$$d(n) = (n-1) \\cdot [d(n-1) + d(n-2)]$$\n\nFrom this expression, we can see that the result for derangements for $$i$$ numbers depends only on the result of the derangments \nof numbers lesser than $$i$$. Thus, we can solve the given problem by making use of Dynamic Programming.\n\nThe equation for Dynamic Programming remains identical to the recursive equation.\n\n$$dp[i] = (i - 1) \\cdot (dp[i-1]+dp[i-2])$$\n\nHere, $$dp[i]$$ is used to store the number of derangements for $$i$$ elements. We start filling the $$dp$$ array from $$i=0$$ and move towards the larger values of $$i$$. At the end, the value of \n$$dp[n]$$ gives the required result.\n\nThe following animation illustrates the $$dp$$ filling process.\n\n!?!../Documents/634_Find_Derangements.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/VjHVXyNB/shared\" frameBorder=\"0\" width=\"100%\" height=\"293\" name=\"VjHVXyNB\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. Single loop upto $$n$$ is required to fill the $$dp$$ array of size $$n$$.\n\n* Space complexity : $$O(n)$$. $$dp$$ array of size $$n$$ is used.\n<br />\n<br />\n---\n#### Approach 4: Constant Space Dynamic Programming\n\n**Algorithm**\n\nIn the last approach, we can easily observe that the result for $$dp[i]$$ depends only on the previous two elements, $$dp[i-1]$$ and \n$$dp[i-2]$$. Thus, instead of maintaining the entire 1-D array, we can just keep a track of the last two values required to calculate the \nvalue of the current element. By making use of this observation, we can save the space required by the $$dp$$ array in the last approach.\n\n<iframe src=\"https://leetcode.com/playground/N7tfSLdg/shared\" frameBorder=\"0\" width=\"100%\" height=\"310\" name=\"N7tfSLdg\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. Single loop upto $$n$$ is required to find the required result.\n\n* Space complexity : $$O(1)$$. Constant extra space is used.\n<br />\n<br />\n---\n#### Approach 5: Formula\n\n**Algorithm**\n\nBefore discussing this approach, we need to look at some preliminaries.\n\nIn combinatorics (combinatorial mathematics), the inclusion\u2013exclusion principle is a counting \ntechnique which generalizes the familiar method of obtaining the number of elements in the union of two \nfinite sets; symbolically expressed as\n\n$$\\left|A\\cup B\\right|=\\left|A\\right|+\\left|B\\right|-\\left|A\\cap B\\right|$$ \n\nwhere $$A$$ and $$B$$ are two finite sets and $$\\left|S\\right|$$ indicates the cardinality of a set $$S$$ \n(which may be considered as the number of elements of the set, if the set is finite). \n\n![AUB](../Figures/634/634_AUB.PNG)\n{:align=\"center\"}\n\nThe formula expresses the fact that the sum of the sizes of the two sets may be too large since\n some elements may be counted twice. The double-counted elements are those in the intersection of \n the two sets and the count is corrected by subtracting the size of the intersection.\n\nThe principle is more clearly seen in the case of three sets, which for the sets $$A$$, $$B$$ and $$C$$ is given by\n\n$$\\left|A\\cup B\\cup C\\right|=\\left|A\\right|+\\left|B\\right|+\\left|C\\right|-\\left|A\\cap B\\right|-\\left|A\\cap C\\right|-\\left|B\\cap C\\right|+\\left|A\\cap B\\cap C\\right|$$.\n\nThis formula can be verified by counting how many times each region in the \nVenn diagram figure shown below. \n\n![AUBUC](../Figures/634/634_AUBUC.png)\n{:align=\"center\"}\n\nIn this case, \nwhen removing the contributions of over-counted elements, the number of elements in the mutual \nintersection of the three sets has been subtracted too often, so must be added back in to get the correct total.\n\nIn its general form, the principle of inclusion\u2013exclusion states that for finite sets $$A_1, ..., A_n$$, one\n has the identity\n\n$$\\bigg|\\bigcup _{i=1}^{n}A_{i}\\bigg|=\\sum_{i=1}^{n}\\left|A_{i}\\right|-\\sum_{1 \\leq; i < j \\leq; n}\\left|A_{i}\\cap A_{j}\\right|+...$$\n\n$$+...+\\sum_{1 \\leq; i < j < k \\leq; n}\\left|A_{i}\\cap A_{j}\\cap A_{k}\\right|-..... +(-1)^{n}\\left|A_{1}\\cap... \\cap A_{n}\\right|$$\n\n\nBy applying De-Morgan's law to the above equation, we can obtain\n\n$$\\bigg|\\bigcap _{i=1}^{n}\\bar{A_{i}}\\bigg|=\\bigg|S-\\bigcup _{i=1}^{n}A_{i}\\bigg|=\\left|S\\right|-$$  $$\\sum_{i=1}^{n}\\left|A_{i}\\right|+\\sum_{1 \\leq; i < j \\leq; n}\\left|A_{i}\\cap A_{j}\\right|-.... +(-1)^{n}\\left|A_{1}\\cap....\\cap A_{n}\\right|$$\n\nHere, $$S$$ represents the universal set containing all of the $$A_i$$ and $$\\bar{A_{i}}$$ denotes the complement of $$A_i$$ in $$S$$.\n\nNow, let $$A_i$$ denote the set of permutations  which leave $$A_i$$ in its natural position. Thus, the number of permutations in which \nthe $$i^{th}$$ element remains at its natural position is $$(n-1)!$$. Thus, the component $$\\sum_{i=1}^{n}\\left|A_{i}\\right|$$ above \nbecomes $${{n}\\choose{1}} (n-1)!$$. Here, $${{n}\\choose{1}}$$ represents the number of ways of choosing 1 element out of $$n$$ elements.\n\n Making use of this notation, the required number of derangements can be denoted by $$\\left|\\bigcap _{i=1}^{n}\\bar{A_{i}}\\right|$$ term. \n\nThis is the same term which has been expanded in the last equation. Putting appropriate values of the elements, we can expand the above equation as:\n\n$$\\bigg|\\bigcap _{i=1}^{n}\\bar{A_{i}}\\bigg|=n! -{n \\choose 1}(n-1)! + {n\\choose 2}(n-2)! - {n \\choose 3}(n-3)! +...$$\n$$...+(-1)^{p}{n \\choose p}(n-p)! +...+ (-1)^{n}{n \\choose n} (n-n)!$$\n\n$$ = n! - \\frac{n!}{1!} + \\frac{n!}{2!} - \\frac{n!}{3!}+...+(-1)^n \\frac{n!}{n!}$$\n\nWe can make use of this formula to obtain the required number of derangements.\n\n<iframe src=\"https://leetcode.com/playground/jPVhp9aG/shared\" frameBorder=\"0\" width=\"100%\" height=\"225\" name=\"jPVhp9aG\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. Single loop upto $$n$$ is used.\n\n* Space complexity : $$O(1)$$. Constant space is used.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "188",
            "count": 11,
            "average": "4.727",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "find-the-derangement-of-an-array",
    "playgroundData": {
        "ZAQZ4ne4": {
            "playground": {
                "testcaseInput": "",
                "name": "find-derangements-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "VjHVXyNB": {
            "playground": {
                "testcaseInput": "",
                "name": "find-derangements-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "N7tfSLdg": {
            "playground": {
                "testcaseInput": "",
                "name": "find-derangements-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "jPVhp9aG": {
            "playground": {
                "testcaseInput": "",
                "name": "find-derangements-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}