{
    "id": "659",
    "question": {
        "questionId": "659",
        "questionFrontendId": "659",
        "boundTopicId": null,
        "title": "Split Array into Consecutive Subsequences",
        "titleSlug": "split-array-into-consecutive-subsequences",
        "content": "<p>You are given an integer array <code>nums</code> that is <strong>sorted in non-decreasing order</strong>.</p>\n\n<p>Determine if it is possible to split <code>nums</code> into <strong>one or more subsequences</strong> such that <strong>both</strong> of the following conditions are true:</p>\n\n<ul>\n\t<li>Each subsequence is a <strong>consecutive increasing sequence</strong> (i.e. each integer is <strong>exactly one</strong> more than the previous integer).</li>\n\t<li>All subsequences have a length of <code>3</code><strong> or more</strong>.</li>\n</ul>\n\n<p>Return <code>true</code><em> if you can split </em><code>nums</code><em> according to the above conditions, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., <code>[1,3,5]</code> is a subsequence of <code>[<u>1</u>,2,<u>3</u>,4,<u>5</u>]</code> while <code>[1,3,2]</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,4,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> nums can be split into the following subsequences:\n[<strong><u>1</u></strong>,<strong><u>2</u></strong>,<strong><u>3</u></strong>,3,4,5] --&gt; 1, 2, 3\n[1,2,3,<strong><u>3</u></strong>,<strong><u>4</u></strong>,<strong><u>5</u></strong>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,4,4,5,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> nums can be split into the following subsequences:\n[<strong><u>1</u></strong>,<strong><u>2</u></strong>,<strong><u>3</u></strong>,3,<strong><u>4</u></strong>,4,<strong><u>5</u></strong>,5] --&gt; 1, 2, 3, 4, 5\n[1,2,3,<strong><u>3</u></strong>,4,<strong><u>4</u></strong>,5,<strong><u>5</u></strong>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,4,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 2265,
        "dislikes": 558,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Divide Array in Sets of K Consecutive Numbers\", \"titleSlug\": \"divide-array-in-sets-of-k-consecutive-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[1,2,3,3,4,5]\n[1,2,3,3,4,4,5,5]\n[1,2,3,4,4,5]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Greedy",
                "slug": "greedy",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    bool isPossible(vector<int>& nums) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public boolean isPossible(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def isPossible(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nbool isPossible(int* nums, int numsSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public bool IsPossible(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossible = function(nums) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef is_possible(nums)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func isPossible(_ nums: [Int]) -> Bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func isPossible(nums []int) bool {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def isPossible(nums: Array[Int]): Boolean = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun isPossible(nums: IntArray): Boolean {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn is_possible(nums: Vec<i32>) -> bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function isPossible($nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function isPossible(nums: number[]): boolean {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (is-possible nums)\n  (-> (listof exact-integer?) boolean?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec is_possible(Nums :: [integer()]) -> boolean().\nis_possible(Nums) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec is_possible(nums :: [integer]) :: boolean\n  def is_possible(nums) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"71.8K\", \"totalSubmission\": \"156.6K\", \"totalAcceptedRaw\": 71754, \"totalSubmissionRaw\": 156552, \"acRate\": \"45.8%\"}",
        "hints": [],
        "solution": {
            "id": "1296",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,2,3,3,4,5]",
        "metaData": "{\r\n  \"name\": \"isPossible\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1296",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nAt first read, this problem might sound challenging. But the key to solving this problem lies in the details. Read the problem statement again and again. Try to list all the conditions given. \n\nThe key phrase is written in the first line of the problem statement itself, i.e., the array is **sorted in non-decreasing (increasing) order**. How is this important? Let's go through the conditions for a subsequence to be valid: \n\n1. Each subsequence should consist of **consecutive** numbers in increasing order.\n2. Each subsequence should be of length 3 or more.\n\nLet's go through all the details one by one.\n\n- Subsequence - it is an ordered subset of an array where the sequential ordering of elements is the same as in the parent array.\n- Consecutive & Increasing sequence - every element should be exactly 1 more than the previous element. \n\nOur job is to split the `nums` array into subsequences that satisfy the above conditions. We will think about implementation later. First, let's try to create subsequences on the paper. Suppose, at the $$i^{th}$$ index, we have `x` number of subsequences. There are two options we have:\n\n- Add `nums[i]` to one of the `x` subsequences if possible.\n- Create a new subsequence with `nums[i]` as the starting number. \n\nAlso, we need to keep in mind that each subsequence should be of length 3 or more. So at $$i ^ {th}$$ index, if we need to create a new subsequence and there is one or more existing subsequences of length less than 3, we can return `false` then. This is because the `nums` array is **sorted in increasing order** and each subsequence consists of **consecutive** elements. As we move from left to right in the array, the value of the elements keeps increasing, so it is impossible to find consecutively increasing elements for these subsequences (of length < 3) in the future.\n\nThis can be better understood with an example. Let's consider an array `nums = {1, 2, 3, 5, 6, 8, 9, 10}`.\n\n- At $$0^{th}$$ index: {1} [new subsequence formed]\n- At $$1^{st}$$ index: {1, 2} [add to the existing subsequence]\n- At $$2^{nd}$$ index: {1, 2, 3}  [add to the existing subsequence]\n- At $$3^{rd}$$ index: {1, 2, 3}, {5}  [new subsequence formed]\n- At $$4^{th}$$ index: {1, 2, 3}, {5, 6}  [add to the existing subsequence]\n- At $$5^{th}$$ index: {1, 2, 3}, {5, 6}, {8}  [new subsequence formed]\n\nAt this point, we see the second subsequence (`{5, 6}`) is of length 2. Because the elements are sorted in increasing order, there is no way we will get a `7` or a `4` to make this subsequence valid. So we can safely return `false` at this point.\n\nNow let us think about ways to implement this logic using popular data structures.\n\n</br>\n\n---\n\n#### Approach 1: Greedy using Heap\n\n**Intuition**\n\nFrom the above discussion, it is clear that first of all, we need to consider ways to store the subsequences created so far. We can use a list of lists to store each subsequence. But wait, do we need to store the entire subsequence? Give it a thought.\n\nWell, we need only the metadata of each subsequence. We know the subsequence consists of consecutive increasing numbers. So isn't it enough to know the first and the last element in the subsequence? We can also find the length of the subsequence from this information: `last - first + 1`.  We can store this information in an array of size `2`.\n\nNow that we have found out a possible way to store each subsequence, the next question is the order. As discussed earlier, at $$i ^ {th}$$ index, `nums[i]` has two options - to be a part of any existing subsequence or to start a new subsequence. If we choose the first option, it will be a part of a subsequence whose last element value is `nums[i] - 1`. How can we find such a subsequence easily? By sorting subsequences in increasing order of their last element. Have doubt in believing this? Please refer to the intuition part again.\n\nNow the next question is, what if the last element is the same for two or more subsequences? (Yes, it is possible, consider `{0, 1, 1, 2, 2, 3}`). In this case, at $$5 ^ {th}$$ index, `3` has two subsequences that it can be a part of: `{0, 1, 2}`, `{1, 2}`. But if it becomes a part of the first subsequence, the second subsequence will become invalid and we will return `false`. However, the answer should be `true`. How? By appending `3` to the second subsequence, we will get two valid subsequences: `{0, 1, 2}` and `{1, 2, 3}`. So what can we keep in mind from this example? Yes, we got the answer to the previously asked question, i.e., if the last element is the same for two or more subsequences, sort the subsequences based on the increasing order of their size.\n\nNow when it comes to storing arrays in a sorted manner, what's the first thing that comes to your mind? Heaps. So can we use a heap in this use case? Let's try to use one. The heap will store 1D arrays of size `2` comprising of the first and the last element of each subsequence. The arrays in the heap will be stored based on two conditions:\n\n- Increasing order of their last element.\n- When the subsequences' last elements are equal, then the two subsequences will be placed in increasing order of length.\n\nFor each element (`nums[i]`) we compare the element with the last element (`last = subsequences.peek()[1]`) of the existing subsequences in the heap one by one. There can be only 3 conditions:\n\n1. `nums[i]` > `last + 1`: `nums[i]` cannot be a part of this subsequence. So we remove this subsequence from the heap and compare `nums[i]` with the next subsequence in the heap.\n2. `nums[i]` == `last` (or the heap is empty): `nums[i]` cannot be a part of this subsequence either. As the subsequences are stored in increasing order of their last element in the heap, there will be no other subsequences in the heap to append `nums[i]`. So the only way here is to start a new subsequence with `nums[i]` as the only element.\n3. `nums[i] == last + 1`: we add `nums[i]` to this subsequence. As the subsequences with equal last elements are stored in increasing order of their length, this current subsequence will be the shortest subsequence ending with `nums[i] - 1`.\n\nThis can be better understood with the following animation.\n\n!?!../Documents/659_rewrite_1.json:960,540!?!\n\n</br>\n\n**Algorithm**\n\n1. Create a heap to store 1D arrays with the required conditions. Each array is of size 2 and represents a subsequence. We store the first and the last element of each subsequence in the array.\n\n2. Iterate over the `nums` array.\n\n    - Compare the last element of each existing subsequence in the heap with the current element `num`. If the last element is smaller than `num - 1`, we cannot add `num` or any future element to that subsequence. So we remove it from the heap. While removing, check if its length is greater than or equal to 3. If not, return `false`.\n\n    - If the heap is empty or the last element of the first subsequence in the heap is equal to `num`, create a new subsequence with `num` as the only element and add it to the heap.\n\n    - If there exists a valid subsequence of which `num` can be a part of, add `num` to it. If there are multiple valid subsequences, choose the subsequence with the smallest length possible.\n\n3. Check the length of all the subsequences present in the heap. If any of them is of length less than `3`, return `false`. Otherwise, return `true`.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/nvzu6Vrg/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"nvzu6Vrg\"></iframe>\n\n\n**Complexity Analysis**\n\nHere $$N$$ is the size of the `nums` array.\n\n* Time complexity: $$O(N \\log (N))$$.\n\n    In the worst case, each subsequence will be of length $$1$$ (say for `nums = {1, 1, 1, 1}`). So there will be a total `N` arrays (subsequences) in the heap. Each subsequence is added and removed from the heap only once and each such operation takes $$\\log (N)$$ time. So the overall time complexity will be $$O(N \\log (N))$$.\n\n* Space complexity: $$O(N)$$.\n\n    Each of the $$N$$ elements in the `nums` array is added as a part of a subsequence in the heap only once. So the extra space occupied by the heap will be in the order of $$N$$.\n    \n\n<br/>\n\n---\n\n#### Approach 2: Greedy using Maps\n\n**Intuition**\n\nIn our previous approach, we applied the Greedy algorithm to create increasing subsequences consisting of consecutive elements. In this approach, for each element (say `nums[i]`) we will see if it is possible to form a valid subsequence with the remaining elements. Previously we were trying to find a subsequence to which we can append `nums[i]`. We will continue to do that here as well. However, while creating a new subsequence with `nums[i]` as the starting element, we will check if a valid subsequence is possible or not with `nums[i]` as the starting element. If not, we will return `false` without any further operations.\n\nThe first thing that comes to mind while reading the last line of the previous paragraph is that we need to know if a valid subsequence is possible or not with `nums[i]` as the starting element at the $$i ^ {th}$$ iteration. For a valid subsequence we need `nums[i] + 1` and `nums[1] + 2` to be present in the array. Thus we need to know the count of these two numbers in advance to make the decision at the $$i ^ {th}$$ iteration. We can use a `map` here since it's the most convenient data structure to store the frequency of each element in the array. \n\nBut is one `map` enough? Well, what if we want to add `nums[i]` in one of the existing subsequences? How are we going to store the existing subsequences? By using a `heap` like before? When we are creating a new subsequence at the $$i ^ {th}$$ iteration, we are ensuring that a valid subsequence is possible with `nums[i]`. So we don't need a heap to record the length or sort the subsequences. For adding `nums[i]` to an existing subsequence we only need to know if such a subsequence exists whose last element is `nums[i] - 1`.\n\nNow can you think of how to store this information? We just need to store the last element in the subsequence in a `set` when a subsequence is created or modified. This way, if we want to add `nums[i]` to an existing subsequence, we can just check if `nums[i] - 1` exists in the `set`. But wait, is using a `set` enough? Of course, we can get the answer in $$O(1)$$ time using `sets`. But what if there is more than one subsequence with the same last element? Well, in this case, we need to store the frequency as well. We can use another `map` for that. The time complexity will remain the same and our problem will also be solved.\n\nYou can do a dry run in pen and paper. See if you can find out the conditions for entry and exit in each `map`. Then have a look at this animation.\n\n!?!../Documents/659_rewrite_2.json:960,540!?!\n\n</br>\n\n**Algorithm**\n\n1. Initialize two maps - one to store the frequency of each element present in `nums` array (`frequency`), the other to store the frequency of subsequences ending with the `key` (`subsequences`).\n\n2. Iterate over the `nums` array to update the `frequency` map.\n\n3. Iterate over the `nums` array.\n\n    - If the frequency of the current element `num` is `0`, it means the num is already considered to be a part of a valid subsequence. Continue.\n    \n    - Next, check if it is possible to add `num` to one of the existing subsequences. For this, check if there is an entry with `key` as `num - 1` in the `subsequences` map. If there exists such an entry, it means we can add `num` to an existing subsequence. Make the necessary changes in `subsequences` map to keep it consistent.\n\n    - If no such subsequence exists, we need to create a new subsequence with `num` as the first element. For this, we need to check if `num + 1` and `num + 2` exist or not. If they don't, no valid subsequence is possible with `num` as the starting element. Return `false`. Otherwise, make the necessary changes in `subsequences` map to keep it consistent. \n\n4. After the traversal is done, return `true`.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/4z2taZkX/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4z2taZkX\"></iframe>\n\n\n**Complexity Analysis**\n\nHere $$N$$ is the length of the `nums` array.\n\n* Time complexity: $$O(N)$$.\n\n    We are iterating over the `nums` array twice, which adds $$O(2 * N) = O(N)$$ to the time complexity. Operations on an unordered map/hashmap take $$O(1)$$ time in the average case. Thus the overall time complexity is $$O(N)$$.\n\n* Space complexity: $$O(N)$$.\n\n    We are using two maps. `frequency` map will store at max $$N$$ elements. The total number of subsequences will also be $$N$$ in the worst case. Thus the size of the `subsequences` map will also be at max $$N$$. Therefore, it's a $$O(N)$$ space solution.\n    \n\n<br/>\n\n---\n\n#### Approach 3: Dynamic Programming\n\n**Intuition**\n\nGiven that the array consists of numbers in non-decreasing order, we can make the following observation:\n\nAnytime we encounter two adjacent elements with a difference of > 1, a new subsequence must start. In other words, these points (of > 1 jump) can be treated as a break-point that separates the array into two segments that can be treated in isolation, since no valid subsequence can cross over from the left segment to the right segment while maintaining the first condition (each subsequence consists of consecutively increasing elements).\n\nThat is the approach we take here, checking each such segment for validity. The idea is to ensure that all elements in each such segment can be accommodated inside a valid subsequence of length >= 3.\n\nHow do we check each segment for validity?\n\nThe idea is to linearly process all elements in the segment and keep track of how many subsequences (consisting of consecutive elements) of lengths one and two can end at the present index. This also requires us to keep track of the total count (frequency) of each element in this segment. Another important observation is that due to the nature of the input, all elements with the same value will be placed consecutively in the segment.\n\nInstead of storing the frequency of each number directly, in order to optimize space usage, we store the frequency of the difference of each number in the segment with the starting number (`nums[start]`) of each segment. This way we can store the frequency of each number in an array of size equal to the total number of unique numbers present in the segment which can be at max the segment length (`noOfUniqueNumbers`). Henceforth, we consider each element in terms of their difference, i.e., `nums[i]` is denoted by `nums[i] - start`. This way we can store all the required values in arrays of size `noOfUniqueNumbers`. Otherwise, arrays of size `nums[end]` would have been required.\n\nWe take three arrays for calculation purposes.\n\n- `lengthOneSubsequences`: at $$i ^ {th}$$ index it holds the number of subsequences of length one ending with $$i$$.\n- `lengthTwoSubsequences`: at $$i ^ {th}$$ index it holds the number of subsequences of length two ending with $$i$$.\n- `totalNoOfSubsequences`: at $$i ^ {th}$$ index it holds the total number of existing subsequences ending with $$i$$.\n\nAt an index $$i$$, we calculate the number of sequences of lengths one and two ending with $$i$$ as follows:\n\n- Note that if `frequency[i]` is less than sum of `lengthOneSubsequences[i - 1]` and `lengthTwoSubsequences[i - 1]`, it means there aren't enough $$i$$ elements to create valid subsequences (`lengthOneSubsequences[i - 1]` and `lengthTwoSubsequences[i - 1]` will be valid only if there are enough $$i$$ elements to append). We can check for this condition and break early if it's true.\n\nNext, we do the following:\n\n- `lengthTwoSubsequences[i] = lengthOneSubsequences[i - 1]` (All sequences of length one, ending at $$i - 1$$ can be extended by adding $$i$$ to the end of it. Also, priority should be given to `lengthOneSubsequences` since we need to choose the smallest length subsequence possible)\n\n- `lengthOneSubsequences[i] = max(0,  frequency[i] - totalNoOfSubsequences[i - 1])`, (`totalNoOfSubsequences[i - 1]` is equal to `frequency[i - 1]`). Since `totalNoOfSubsequences[i - 1]` represents the number of subsequences ending with $$i - 1$$, the difference represents the number of $$i$$ valued elements left over after adding $$i$$ to existing subsequences. These remaining $$i$$ valued elements will form a new subsequence of length `1`.\n\n- We also need to update `totalNoOfSubsequences[i]` to `frequency[i]`.\n\nAfter exiting the loop, we check if there exists any subsequence of length one or two ending with value `end - start`. If there isn't any such subsequence, we return `true`.\n\n**Algorithm**\n\n1. Iterate over the `nums` array.\n2. Initialize `start` variable to `0`. This will hold the starting index of the current segment.\n3. Whenever the difference between consecutive elements (`nums[i] - nums[i -1]`) is more than one, a new segment needs to be created.\n4. Before iterating further, we need to check if valid subsequences are possible with the current segment (between `start` and `i`). To do so make a call to the `isSegmentValid` function.\n5. In the `isSegmentValid` function, \n    - Initialize `noOfUniqueNumbers` to `end - start + 1`. Note this variable does not denote the length of the segment. It denotes the number of unique numbers present in the current segment.\n    - The frequency of each number is stored in terms of their difference with the first number of the segment (`nums[start]`) in the `frequency` array. Thus each segment is considered as a series starting with `0` and ending with `nums[end] - nums[start]`.\n    - Next, we iterate over each unique element in the segment ranging from `0` to `nums[end]- nums[start]`.\n    - If the `frequency[i]` is less than the total number of one and two length subsequences ending with $$i - 1$$, we do not have enough $$i$$ valued numbers to make these one/two length subsequences ending with $$i - 1$$ valid. So return `false`.\n    - For each unique value encountered, we update the `lengthOneSubsequences`, `lengthTwoSubsequences`, `totalNoOfSubsequences` arrays as mentioned in the intuition.\n    - Before exit, check if there are any remaining sequences of length one or two. If not, we return `true`.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/Kxpk8WZC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Kxpk8WZC\"></iframe>\n\n\n**Complexity Analysis**\n\nHere $$N$$ is the size of the `nums` array.\n\n* Time complexity: $$O(N)$$.\n\n    At one glance, it might look that the `isSegmentValid` function takes $$O(N)$$ time. However, if you look at the value of `noOfUniqueNumbers`, you will realize that the `for` loop in the `isSegmentValid` function iterates over each unique element in the `nums` array only once. For the given array of size $$N$$ there can be at max $$N$$ unique elements. Thus the overall time complexity is $$O(N)$$.\n   \n\n* Space complexity: $$O(N)$$.\n\n    In the `isSegmentValid` function four arrays of size at max $$N$$ is used. So the space complexity is $$O(N * 4) = O(N)$$ in Big O notation.\n    \n\n<br/>\n\n---\n#### Approach 4: Optimal Space\n\n**Intuition**\n\nIn this approach, we will try to optimize the space usage in Approach 3. How? Let's go through the `isSegmentValid` again. Do we really need the four arrays of size `N`? First, let's try to remove the `frequency` array. The `frequency` array stores the frequency of each number in the current subsequence in the form of their difference with the first number, i.e., `nums[start]`. If we look at the second `for` loop in the `isSegmentValid` function, we'll notice that at each iteration we only need the value of `frequency[i]`. Also, the value of `frequency[i]` is independent of `frequency[i - 1]`. So we can compute this value on the fly. At any point, we only need the count of how many numbers with the same value are present. This can be easily stored in a variable (say `frequency`) as the same valued numbers are present consecutively in the `nums` array. As long as we get the same value, i.e., `nums[i] == nums[i - 1]`, we increment `frequency`. Whenever we encounter a new value, we will update the value of `frequency` to `1`. \n\nNext, let's check if we need arrays `lengthOneSubsequences`, `lengthTwoSubsequences`, and `totalNoOfSubsequences`. In the second `for` loop of the `isSegmentValid` function at $$i^{th}$$, we are only using the value of these arrays at index $$i - 1$$. Thus we don't need to store the count of subsequences of length one, two, and the total count of all the indices since knowing the previous value is enough. So let's replace these arrays with integer variables.\n\nThis way we can reduce the space complexity of Approach 3 to $$O(1)$$.\n\n**Algorithm**\n1. Iterate over the `nums` array.\n2. Initialize `start` variable to `0`. This will hold the starting index of the current segment.\n3. Whenever the difference between consecutive elements (`nums[i] - nums[i -1]`) is more than one, a new segment needs to be created.\n4. Before iterating further, we need to check if valid subsequences are possible with the current segment (between `start` and `i`). To do so make a call to the `isSegmentValid` function.\n5. In the `isSegmentValid` function, \n    - Intialize variables `lengthOneSubsequences`, `lengthTwoSubsequences`, `totalNoOfSubsequences` to `0`.\n    - Intialize `frequency` to `1`.\n    - Next we iterate over each element in the segment ranging from `start` to `end`.\n    - If the value of `nums[i] == nums[i - 1]`, we just increment the `frequency` value by `1`.\n    - If the `frequency[i]` is less than total number of subsequences ending with i - 1, we do not have enough `i` valued numbers to make these one/two length subsequences ending with `i - 1` valid. So return `false`.\n    - Otherwise, we update the `lengthOneSubsequences`, `lengthTwoSubsequences`, `totalNoOfSubsequences` variables as mentioned in the intuition. Update `frequency` to `1` as a new value has been encountered.\n    - Before exit, check if there are any remaining sequences of length one or two. If there are not, we return `true`.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/ABxecvgh/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ABxecvgh\"></iframe>\n\n\n**Complexity Analysis**\n\nHere $$N$$ is the size of the `nums` array.\n\n* Time complexity: $$O(N)$$.\n\n    At one glance, it might look that the `isSegmentValid` function takes $$O(N)$$ time. However, upon closer inspection of the values of the `start` and `end` variables, we can see that the `for` loop in the `isSegmentValid` function iterates over each element of the `nums` array only once. The `start` and the `end` variables denote the starting and the ending index of a segment at any point respectively. The `isSegmentValid` function is run for each segment only once. Thus, the overall time complexity is $$O(N)$$.\n\n* Space complexity: $$O(1)$$.\n\n    Ony a constant amount of extra space is required for this approach.\n    \n\n<br/>\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1301",
            "count": 24,
            "average": "4.917",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "split-array-into-consecutive-subsequences",
    "playgroundData": {
        "nvzu6Vrg": {
            "playground": {
                "testcaseInput": "",
                "name": "split-array-into-consecutive-subsequences-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "4z2taZkX": {
            "playground": {
                "testcaseInput": "",
                "name": "split-array-into-consecutive-subsequences-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "Kxpk8WZC": {
            "playground": {
                "testcaseInput": "",
                "name": "split-array-into-consecutive-subsequences-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "ABxecvgh": {
            "playground": {
                "testcaseInput": "",
                "name": "split-array-into-consecutive-subsequences-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}