{
    "id": "172",
    "question": {
        "questionId": "172",
        "questionFrontendId": "172",
        "boundTopicId": null,
        "title": "Factorial Trailing Zeroes",
        "titleSlug": "factorial-trailing-zeroes",
        "content": "<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in </em><code>n!</code>.</p>\n\n<p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 3! = 6, no trailing zero.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 5! = 120, one trailing zero.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 2113,
        "dislikes": 1703,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Number of Digit One\", \"titleSlug\": \"number-of-digit-one\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Preimage Size of Factorial Zeroes Function\", \"titleSlug\": \"preimage-size-of-factorial-zeroes-function\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Abbreviating the Product of a Range\", \"titleSlug\": \"abbreviating-the-product-of-a-range\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Trailing Zeros in a Cornered Path\", \"titleSlug\": \"maximum-trailing-zeros-in-a-cornered-path\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "3\n5\n0",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Math",
                "slug": "math",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int trailingZeroes(int n) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int trailingZeroes(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint trailingZeroes(int n){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int TrailingZeroes(int n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar trailingZeroes = function(n) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef trailing_zeroes(n)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func trailingZeroes(_ n: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func trailingZeroes(n int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def trailingZeroes(n: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun trailingZeroes(n: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn trailing_zeroes(n: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function trailingZeroes($n) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function trailingZeroes(n: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (trailing-zeroes n)\n  (-> exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec trailing_zeroes(N :: integer()) -> integer().\ntrailing_zeroes(N) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec trailing_zeroes(n :: integer) :: integer\n  def trailing_zeroes(n) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"325.5K\", \"totalSubmission\": \"791K\", \"totalAcceptedRaw\": 325542, \"totalSubmissionRaw\": 791046, \"acRate\": \"41.2%\"}",
        "hints": [],
        "solution": {
            "id": "908",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "3",
        "metaData": "{\r\n  \"name\": \"trailingZeroes\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"n\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "908",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Approach 1: Compute the Factorial\n\n**Intuition**\n\n*This approach is too slow, but is a good starting point. You wouldn't implement it in an interview, although you might briefly describe it as a possible way of solving the problem.*\n\nThe simplest way of solving this problem would be to compute $$n!$$ and then count the number of zeroes on the end of it. Recall that factorials are calculated by multiplying all the numbers between $$1$$ and $$n$$. For example, $$10! = 10 \\cdot 9 \\cdot 8 \\cdot 7 \\cdot 6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1 = 3,628,800$$. Therefore, factorials can be calculated iteratively using the following algorithm.\n\n```text\ndefine function factorial(n):\n    n_factorial = 1\n    for i from 1 to n (inclusive):\n        n_factorial = n_factorial * i\n    return n_factorial\n```\n\nRecall that if a number has a zero on the end of it, then it is divisible by $$10$$. Dividing by $$10$$ will remove that zero, and shift all the other digits to the right by one place. We can, therefore, count the number of zeroes by repeatedly checking if the number is divisible by $$10$$, and if it is then dividing it by $$10$$. The number of divisions we're able to do is equal to the number of 0's on the end of it. This is the algorithm to count the zeroes (assuming $$x \u2265 1$$, which is fine for this problem, as factorials are always positive integers).\n\n```text\ndefine function zero_count(x):\n    zero_count = 0\n    while x is divisible by 10: \n        zero_count += 1\n        x = x / 10\n    return zero_count\n```\n\nBy putting these two functions together, we can count the number of zeroes on the end of $$n!$$.\n\n**Algorithm**\n\nFor Java, we need to use BigInteger, because $$n!$$ won't fit into a `long` for even moderately small values of $$n$$.\n\n<iframe src=\"https://leetcode.com/playground/HyibyGmb/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"HyibyGmb\"></iframe>\n\n\n**Complexity Analysis**\n\nThe math involved here is very advanced, however we don't need to be precise. We can get a reasonable approximation with a little mathematical reasoning. An interviewer probably won't expect you to calculate it exactly, or even derive the approximation as carefully as we have here. However, they *might* expect you to at least have some ideas and at least attempt to reason about it. Of course, if you've claimed to be an *expert* in algorithms analysis on your r\u00e9sum\u00e9/CV, then they might expect you to derive the entire thing! Our main reason for including it here is because it is a nice example of working with an algorithm that is mathematically challenging to analyse.\n\nLet $$n$$ be the number we're taking the factorial of.\n\n- Time complexity : Worse than $$O(n ^ 2)$$.\n\n    Computing a factorial is repeated multiplication. Generally when we know multiplications are on numbers within a fixed bit-size (e.g. 32 bit or 64 bit ints), we treat them as $$O(1)$$ operations. However, we can't do that here because the size of the numbers to be multiplied grow with the size of $$n$$. \n    \n    So, the first step here is to think about what the cost of multiplication might be, given that we can't assume it's $$O(1)$$. A popular way people multiply two large numbers, that you probably learned in school, has a cost of $$O((\\log \\, x) \\cdot (\\log \\, y))$$. We'll use that in our approximation.\n\n    Next, let's think about what multiplications we do when calculating $$n!$$. The first few multiplications would be as follows:\n\n    $$1 \\cdot 2 = 2$$<br>\n    $$2 \\cdot 3 = 6$$<br>\n    $$6 \\cdot 4 = 24$$<br>\n    $$24 \\cdot 5 = 120$$<br>\n    $$120 \\cdot 6 = 720$$<br>\n    $$...$$\n\n    In terms of cost, these multiplications would have costs of:\n\n    $$\\log \\, 1 \\cdot \\log \\, 2$$<br>\n    $$\\log \\, 2 \\cdot \\log \\, 3$$<br>\n    $$\\log \\, 6 \\cdot \\log \\, 4$$<br>\n    $$\\log \\, 24 \\cdot \\log \\, 5$$<br>\n    $$\\log \\, 120 \\cdot \\log \\, 6$$<br>\n    $$...$$\n\n    Recognising that the first column are all logs of factorials, we can rewrite it as follows:\n\n    $$\\log \\, 1! \\cdot \\log \\, 2$$<br>\n    $$\\log \\, 2! \\cdot \\log \\, 3$$<br>\n    $$\\log \\, 3! \\cdot \\log \\, 4$$<br>\n    $$\\log \\, 4! \\cdot \\log \\, 5$$<br>\n    $$\\log \\, 5! \\cdot \\log \\, 6$$<br>\n    $$...$$\n\n    See the pattern? Each line is of the form $$(\\log \\, k!) \\cdot (\\log \\, k + 1)$$. What would the *last* line be? Well, the last step in calculating a factorial is to multiply by $$n$$. Therefore, the last line must be:\n\n    $$\\log \\, ((n - 1)!) \\cdot \\log \\, (n)$$\n\n\n    Because we're doing each of these multiplications one-by-one, we should *add* them to get the total time complexity. This gives us:\n\n\n    $$\\log \\, 1! \\cdot \\log \\, 2 + \\log \\, 2! \\cdot \\log \\, 3 + \\log \\, 3! \\cdot \\log \\, 4 + \\cdots + \\log \\, ((n - 2)!) \\cdot \\log \\, (n - 1) + \\log \\, ((n - 1)!) \\cdot \\log \\, n$$\n\n    This sequence is quite complicated to add up; instead of trying to find an exact answer, we're going to now focus on a rough *lower bound* approximation by throwing away the less significant terms. While this is not something you'd do if we needed to find the exact time complexity, it will allow us to quickly see that the time complexity is \"too big\" for our purposes. Often finding lower (and upper) bounds is enough to decide whether or not an algorithm is worth using. This includes in interviews!\n\n    At this point, you'll ideally realise that the algorithm is *worse* than $$O(n)$$, as we're adding $$n$$ terms. Given that the question asked us to come up with an algorithm that's no worse than $$O(\\log \\,n)$$, this is definitely not good enough. We're going to explore it a little further, but if you've understood up to this point, you're doing really well! The rest is optional.\n\n    Continuing on, notice that $$\\log \\, ((n - 1)!)$$ is \"a lot bigger\" than $$\\log\\, n$$. Therefore, we'll just drop all these parts, leaving the logs of factorials. This gives us:\n\n\n    $$\\log \\, 1! + \\log \\, 2! + \\log , 3! + \\cdots + \\log \\, ((n - 2)!) + \\log \\, ((n - 1)!)$$\n\n    The next part involves a log rule that you might or might not have heard of. It's definitely worth remembering if you haven't heard of it though, as it can be very useful.\n\n    $$O(\\log \\, n!) = O(n \\, \\log \\, n)$$\n\n    So, let's rewrite the sequence using this rule.\n\n\n    $$1 \\cdot \\log \\, 1 + 2 \\cdot \\log \\, 2 + 3 \\cdot \\log \\, 3 + \\cdots + (n - 2) \\cdot \\log \\, (n - 2) + (n - 1) \\cdot \\log \\, (n - 1)$$\n\n    Like before, we'll just drop the \"small\" $$\\log$$ terms, and see what we're left with.\n\n    $$1 + 2 + 3 + ... + (n - 2) + (n - 1)$$\n\n    This is a very familiar sequence, that you should be familiar with\u2014it describes a cost of $$O(n^2)$$.\n\n    So, what can we conclude? Well, all the discarding of terms leaves us with a time complexity *less* than the real one. In other words, this factorial algorithm must be *slower* than $$O(n^2)$$.\n\n    $$O(n^2)$$ is *definitely* not good enough!\n\n    While this technique of throwing away terms here and there might seem a bit strange, it's very useful to make early decisions quickly, without needing to mess around with advanced math. Only once we had decided we were interested in looking at the algorithm further, would we try to come up with a more exact time complexity. And in this case, our lower bound was enough to convince us that it definitely isn't worth looking at!\n\n    The second part, counting the zeroes at the end, is insignificant compared to the first part. There are $$O(\\log \\, n!) = O(n \\, \\log \\, n)$$ digits, which is smaller than $$O(n^2)$$. Not to mention, only a few of them will be zeroes!\n\n\n- Space complexity : $$O(\\log \\, n!) = O(n \\, \\log \\, n)$$.\n\n    In order to store $$n!$$, we need $$O(\\log \\, n!)$$ bits. As we saw above, this is the same as $$O(n \\, \\log \\, n)$$.\n\n</br>\n\n---\n\n#### Approach 2: Counting Factors of 5\n\n**Intuition**\n\n*This approach is also too slow, however it's a likely step in the problem solving process for coming up with a logarithmic approach.*\n\nInstead of computing the factorial like in Approach 1, we can instead recognize that each $$0$$ on the end of the factorial represents a multiplication by $$10$$.\n\nSo, how many times do we multiply by $$10$$ while calculating $$n!$$ ? Well, to multiply two numbers, $$a$$ and $$b$$, we're effectively multiplying all their factors together. For example, to do $$42 \\cdot 75 = 3150$$, we can rewrite it as follows:\n\n$$42 = 2 \\cdot 3 \\cdot 7$$<br>\n$$75 = 3 \\cdot 5 \\cdot 5$$<br>\n$$42 \\cdot 75 = 2 \\cdot 3 \\cdot 7 \\cdot 3 \\cdot 5 \\cdot 5$$\n\nNow, in order to determine how many zeroes are on the end, we should look at how many complete pairs of $$2$$ and $$5$$ are among the factors. In the case of the example above, we have one $$2$$ and two $$5$$s, giving us **one** complete pair.\n\nSo, how does this relate to factorials? Well, in a factorial we're multiplying *all* the numbers between $$1$$ and $$n$$ together, which is the same as multiplying all the factors of the numbers between $$1$$ and $$n$$.\n\nFor example, if $$n = 16$$, we need to look at the factors of all the numbers between $$1$$ and $$16$$. Keeping in mind that only $$2$$s and $$5$$s are of interest, we'll focus on those factors only. The numbers that contain a factor of $$5$$ are $${5, 10, 15}$$. The numbers that contain a factor of $$2$$ are $${2, 4, 6, 8, 10, 12, 14, 16}$$. Because there are only three numbers with a factor of $$5$$, we can make three complete pairs, and therefore there must be three zeroes on the end of $$16!$$.\n\nPutting this into an algorithm, we get:\n\n```text\ntwos = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 2:\n        twos += 1\n\nfives = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 5:\n        fives += 1\n\ntens = min(fives, twos)\n```\n\nThis gets us most of the way, but it doesn't consider numbers with more than one factor. For example, if `i = 25`, then we've only done `fives += 1`. However, we should've done `fives += 2`, because $$25$$ has *two* factors of $$5$$.\n\nTherefore, we need to count the $$5$$ factors in each number. One way we can do this is by having a loop instead of the if statement, where each time we determine `i` has a $$5$$ factor, we divide that $$5$$ out. The loop will then repeat if there are further remaining $$5$$ factors.\n\nWe can do that like this:\n\n```text\ntwos = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 2:\n        twos += 1\n        remaining_i = remaining_i / 2\n\nfives = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = min(twos, fives)\n```\n\nThis gives us the right answer now. However, there are still some improvements we can make.\n\nFirstly, we can notice that `twos` is **always bigger** than `fives`. Why? Well, every second number counts for a $$2$$ factor, but only every fifth number counts as a $$5$$ factor. Similarly every 4th number counts as an additional $$2$$ factor, yet only every 25th number counts an additional $$5$$ factor. This goes on and on for each power of $$2$$ and $$5$$. Here's a visualisation that illustrates how the density between 2 factors and 5 factors differs.\n\n![A visualisation showing the density of 2 factors vs the density of 5 factors.](../Figures/172/twos_and_fives.png)\n\nAs such, we can simply remove the whole `twos` calculation, leaving us with:\n\n```text\nfives = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = fives\n```\n\nThere is one final optimization we can do. In the above algorithm, we analyzed *every* number from $$1$$ to $$n$$. However, only $$5, 10, 15, 20, 25, 30, ... etc$$ even have at least one factor of $$5$$. So, instead of going up in steps of $$1$$, we can go up in steps of $$5$$. Making this modification gives us:\n\n```text\nfives = 0\nfor i from 5 to n inclusive in steps of 5:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = fives\n```\n\n**Algorithm**\n\nHere's the algorithm as we designed it above.\n\n<iframe src=\"https://leetcode.com/playground/itybpBWn/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"itybpBWn\"></iframe>\n\nAlternatively, instead of dividing by $$5$$ each time, we can check each power of $$5$$ to count how many times $$5$$ is a factor. This works by checking if `i` is divisible by $$5$$, then $$25$$, then $$125$$, etc. We stop when this number does not divide into `i` without leaving a remainder. The number of times we can do this is equivalent to the number of $$5$$ factors in `i`.\n\n<iframe src=\"https://leetcode.com/playground/bC7aMaQE/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"bC7aMaQE\"></iframe>\n\n**Complexity Analysis**\n\n- Time complexity : $$O(n)$$.\n\n    In Approach 1, we couldn't treat division as $$O(1)$$, because we went well outside the 32-bit integer range. In this Approach though, we stay within it, and so can treat division and multiplication as $$O(1)$$.\n    \n    To calculate the zero count, we loop through every fifth number from $$5$$ to $$n$$, this is $$O(n)$$ steps (the $$\\frac{1}{5}$$ is treated as a constant).\n\n    At each step, while it might look like we do a, $$O(\\log \\, n)$$ operation to count the number of fives, it actually amortizes to $$O(1)$$, because the vast majority of numbers checked only contain a single factor of 5. It can be proven that the total number of fives is less than $$\\frac{2 \\cdot n}{5}$$.\n\n    So we get $$O(n) \\cdot O(1) = O(n)$$.\n\n- Space complexity : $$O(1)$$.\n\n    We use only a fixed number of integer variables, therefore the space complexity is $$O(1)$$.\n\n</br>\n\n---\n\n#### Approach 3: Counting Factors of 5 Efficiently \n\n**Intuition**\n\nIn Approach 2, we found a way to count the number of zeroes in the factorial, *without* actually calculating the factorial. This was by looping over each multiple of $$5$$, from $$5$$ up to $$n$$, and counting how many factors of $$5$$ were in each multiple of $$5$$. We added all these counts together to get our final result.\n\nHowever, Approach 2 was still too slow, both for practical means, and for the requirements of the question. To come up with a sufficient algorithm, we need to make one final observation. This observation will allow us to calculate our answer in logarithmic time.\n\nConsider our simplified (but incorrect) algorithm that counted each multiple of $$5$$. Recall that the reason it's incorrect is because it won't count both the $$5$$ factors in numbers such as $$25$$, for example.\n\n```text\nfives = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 5:\n        fives += 1\n```\n\nIf you think about this overly simplified algorithm a little, you might notice that this is simply an inefficient way of performing integer division for $$\\frac{n}{5}$$. Why? Well, by counting the number of multiples of $$5$$ up to $$n$$, we're just counting how many $$5$$s go into $$n$$. That's the *exact* definition of integer division!\n\nSo, a way of simplifying the above algorithm is as follows.\n\n```text\nfives = n / 5\ntens = fives\n```\n\nSo, how can we fix the \"duplicate factors\" problem? Observe that *all* numbers that have (at least) two factors of $$5$$ are multiples of $$25$$. Like with the $$5$$ factors, we can simply divide by $$25$$ to find how many multiples of $$25$$ are below $$n$$. Also, notice that because we've already counted the multiples of $$25$$ in $$\\frac{n}{5}$$ once, we only need to count $$\\frac{n}{25}$$ extra factors of $$5$$ (not $$2 \\cdot \\frac{n}{25})$$), as this is one extra for each multiple of $$25$$.\n\nSo combining this together we get:\n\n```text\nfives = n / 5 + n / 25\ntens = fives\n```\n\nWe still aren't there yet though! What about the numbers which contain *three* factors of $$5$$ (the multiples of $$125$$). We've only counted them twice! In order to get our final result, we'll need to add together all of $$\\dfrac{n}{5}$$, $$\\dfrac{n}{25}$$, $$\\dfrac{n}{125}$$, $$\\dfrac{n}{625}$$, and so on. This gives us:\n\n$$fives = \\dfrac{n}{5} + \\dfrac{n}{25} + \\dfrac{n}{125} + \\dfrac{n}{625} + \\dfrac{n}{3125} + \\cdots$$\n\nThis might look like it goes on forever, but it doesn't! Remember that we're using **integer division**. Eventually, the denominator will be *larger than* $$n$$, and so all the terms from there will be $$0$$. Therefore, we can stop once the term is $$0$$.\n\nFor example with $$n = 12345$$ we get:\n\n$$fives = \\dfrac{12345}{5} + \\dfrac{12345}{25} + \\dfrac{12345}{125} + \\dfrac{12345}{625} + \\dfrac{12345}{3125} + \\dfrac{12345}{16075} + \\dfrac{12345}{80375} + \\cdots$$\n\nWhich is equal to:\n\n$$fives = 2469 +  493 + 98 + 19 + 3 + 0 + 0 + \\cdots = 3082$$\n\nIn code, we can do this by looping over each power of $$5$$, calculating how many times it divides into $$n$$, and then adding that to a running `fives` count. Once we have a power of $$5$$ that's bigger than $$n$$, we stop and return the final value of `fives`.\n\n```text\nfives = 0\npower_of_5 = 5\nwhile n >= power_of_5:\n    fives += n / power_of_5\n    power_of_5 *= 5\n\ntens = fives\n```\n\n**Algorithm**\n\n<iframe src=\"https://leetcode.com/playground/YnJgM3Ef/shared\" frameBorder=\"0\" width=\"100%\" height=\"242\" name=\"YnJgM3Ef\"></iframe>\n\nAn alternative way of writing this algorithm, is instead of trying each power of $$5$$, we can instead divide $$n$$ itself by $$5$$ each time. This works out the same because we wind up with the sequence:\n\n$$fives = \\dfrac{n}{5} + \\dfrac{(\\dfrac{n}{5})}{5} + \\dfrac{(\\dfrac{(\\frac{n}{5})}{5})}{5} + \\cdots$$\n\nNotice that on the second step, we have $$\\dfrac{(\\frac{n}{5})}{5}$$. This is because the previous step divided $$n$$ itself by $$5$$. And so on.\n\nIf you're familiar with the rules of fractions, you'll notice that $$\\dfrac{(\\frac{n}{5})}{5}$$ is just the same thing as $$\\dfrac{n}{5 \\cdot 5} = \\frac{n}{25}$$. This means the sequence is exactly the same as:\n\n$$\\dfrac{n}{5} + \\dfrac{n}{25} + \\dfrac{n}{125} + \\cdots$$\n\nSo, this alternative way of writing the algorithm is equivalent.\n\n<iframe src=\"https://leetcode.com/playground/oNJcR7KA/shared\" frameBorder=\"0\" width=\"100%\" height=\"208\" name=\"oNJcR7KA\"></iframe>\n\n\n**Complexity Analysis**\n\n- Time complexity : $$O(\\log \\, n)$$.\n\n    In this approach, we divide $$n$$ by each power of $$5$$. By definition, there are $$\\log_5n$$ powers of $$5$$ less-than-or-equal-to $$n$$. Because the multiplications and divisions are within the 32-bit integer range, we treat these calculations as $$O(1)$$. Therefore, we are doing $$\\log_5 n \\cdot O(1) = \\log \\, n$$ operations (keeping in mind that $$\\log$$ bases are insignificant in big-oh notation).\n\n- Space complexity : $$O(1)$$.\n\n    We use only a fixed number of integer variables, therefore the space complexity is $$O(1)$$.\n\n\n</br>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "856",
            "count": 34,
            "average": "4.353",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "factorial-trailing-zeroes",
    "playgroundData": {
        "HyibyGmb": {
            "playground": {
                "testcaseInput": "",
                "name": "factorial-trailing-zeroes-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "itybpBWn": {
            "playground": {
                "testcaseInput": "",
                "name": "factorial-trailing-zeroes-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "bC7aMaQE": {
            "playground": {
                "testcaseInput": "",
                "name": "factorial-trailing-zeroes-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "YnJgM3Ef": {
            "playground": {
                "testcaseInput": "",
                "name": "factorial-trailing-zeroes-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "oNJcR7KA": {
            "playground": {
                "testcaseInput": "",
                "name": "factorial-trailing-zeroes-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}