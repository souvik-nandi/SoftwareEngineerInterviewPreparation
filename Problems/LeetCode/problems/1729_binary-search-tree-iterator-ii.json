{
    "id": "1729",
    "question": {
        "questionId": "1729",
        "questionFrontendId": "1586",
        "boundTopicId": null,
        "title": "Binary Search Tree Iterator II",
        "titleSlug": "binary-search-tree-iterator-ii",
        "content": "<p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\">in-order traversal</a></strong> of a binary search tree (BST):</p>\n\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>\n\t<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>\n\t<li><code>boolean hasPrev()</code> Returns <code>true</code> if there exists a number in the traversal to the left of the pointer, otherwise returns <code>false</code>.</li>\n\t<li><code>int prev()</code> Moves the pointer to the left, then returns the number at the pointer.</li>\n</ul>\n\n<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>\n\n<p>You may assume that <code>next()</code> and <code>prev()</code> calls will always be valid. That is, there will be at least a next/previous number in the in-order traversal when <code>next()</code>/<code>prev()</code> is called.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/untitled-diagram-1.png\" style=\"width: 201px; height: 201px;\" /></strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;prev&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;hasPrev&quot;, &quot;prev&quot;, &quot;prev&quot;]\n[[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]\n<strong>Output</strong>\n[null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]\n\n<strong>Explanation</strong>\n// The underlined element is where the pointer currently is.\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // state is <u> </u> [3, 7, 9, 15, 20]\nbSTIterator.next(); // state becomes [<u>3</u>, 7, 9, 15, 20], return 3\nbSTIterator.next(); // state becomes [3, <u>7</u>, 9, 15, 20], return 7\nbSTIterator.prev(); // state becomes [<u>3</u>, 7, 9, 15, 20], return 3\nbSTIterator.next(); // state becomes [3, <u>7</u>, 9, 15, 20], return 7\nbSTIterator.hasNext(); // return true\nbSTIterator.next(); // state becomes [3, 7, <u>9</u>, 15, 20], return 9\nbSTIterator.next(); // state becomes [3, 7, 9, <u>15</u>, 20], return 15\nbSTIterator.next(); // state becomes [3, 7, 9, 15, <u>20</u>], return 20\nbSTIterator.hasNext(); // return false\nbSTIterator.hasPrev(); // return true\nbSTIterator.prev(); // state becomes [3, 7, 9, <u>15</u>, 20], return 15\nbSTIterator.prev(); // state becomes [3, 7, <u>9</u>, 15, 20], return 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, <code>next</code>, <code>hasPrev</code>, and <code>prev</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve the problem without precalculating the values of the tree?",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 227,
        "dislikes": 27,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[\"BSTIterator\",\"next\",\"next\",\"prev\",\"next\",\"hasNext\",\"next\",\"next\",\"next\",\"hasNext\",\"hasPrev\",\"prev\",\"prev\"]\n[[[7,3,15,null,null,9,20]],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Tree",
                "slug": "tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Design",
                "slug": "design",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Search Tree",
                "slug": "binary-search-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Tree",
                "slug": "binary-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Iterator",
                "slug": "iterator",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"1\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass BSTIterator {\npublic:\n    BSTIterator(TreeNode* root) {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n    \n    int next() {\n        \n    }\n    \n    bool hasPrev() {\n        \n    }\n    \n    int prev() {\n        \n    }\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator* obj = new BSTIterator(root);\n * bool param_1 = obj->hasNext();\n * int param_2 = obj->next();\n * bool param_3 = obj->hasPrev();\n * int param_4 = obj->prev();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n\n    public BSTIterator(TreeNode root) {\n        \n    }\n    \n    public boolean hasNext() {\n        \n    }\n    \n    public int next() {\n        \n    }\n    \n    public boolean hasPrev() {\n        \n    }\n    \n    public int prev() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * boolean param_1 = obj.hasNext();\n * int param_2 = obj.next();\n * boolean param_3 = obj.hasPrev();\n * int param_4 = obj.prev();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\n\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasPrev(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def prev(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.hasNext()\n# param_2 = obj.next()\n# param_3 = obj.hasPrev()\n# param_4 = obj.prev()",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        \n\n    def hasNext(self) -> bool:\n        \n\n    def next(self) -> int:\n        \n\n    def hasPrev(self) -> bool:\n        \n\n    def prev(self) -> int:\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.hasNext()\n# param_2 = obj.next()\n# param_3 = obj.hasPrev()\n# param_4 = obj.prev()",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\n\ntypedef struct {\n    \n} BSTIterator;\n\n\nBSTIterator* bSTIteratorCreate(struct TreeNode* root) {\n    \n}\n\nbool bSTIteratorHasNext(BSTIterator* obj) {\n  \n}\n\nint bSTIteratorNext(BSTIterator* obj) {\n  \n}\n\nbool bSTIteratorHasPrev(BSTIterator* obj) {\n  \n}\n\nint bSTIteratorPrev(BSTIterator* obj) {\n  \n}\n\nvoid bSTIteratorFree(BSTIterator* obj) {\n    \n}\n\n/**\n * Your BSTIterator struct will be instantiated and called as such:\n * BSTIterator* obj = bSTIteratorCreate(root);\n * bool param_1 = bSTIteratorHasNext(obj);\n \n * int param_2 = bSTIteratorNext(obj);\n \n * bool param_3 = bSTIteratorHasPrev(obj);\n \n * int param_4 = bSTIteratorPrev(obj);\n \n * bSTIteratorFree(obj);\n*/",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class BSTIterator {\n\n    public BSTIterator(TreeNode root) {\n        \n    }\n    \n    public bool HasNext() {\n        \n    }\n    \n    public int Next() {\n        \n    }\n    \n    public bool HasPrev() {\n        \n    }\n    \n    public int Prev() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * bool param_1 = obj.HasNext();\n * int param_2 = obj.Next();\n * bool param_3 = obj.HasPrev();\n * int param_4 = obj.Prev();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n    \n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n    \n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasPrev = function() {\n    \n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.prev = function() {\n    \n};\n\n/** \n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\nclass BSTIterator\n\n=begin\n    :type root: TreeNode\n=end\n    def initialize(root)\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_next()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def next()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_prev()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def prev()\n        \n    end\n\n\nend\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator.new(root)\n# param_1 = obj.has_next()\n# param_2 = obj.next()\n# param_3 = obj.has_prev()\n# param_4 = obj.prev()",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass BSTIterator {\n\n    init(_ root: TreeNode?) {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasPrev() -> Bool {\n        \n    }\n    \n    func prev() -> Int {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * let obj = BSTIterator(root)\n * let ret_1: Bool = obj.hasNext()\n * let ret_2: Int = obj.next()\n * let ret_3: Bool = obj.hasPrev()\n * let ret_4: Int = obj.prev()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\ntype BSTIterator struct {\n    \n}\n\n\nfunc Constructor(root *TreeNode) BSTIterator {\n    \n}\n\n\nfunc (this *BSTIterator) HasNext() bool {\n    \n}\n\n\nfunc (this *BSTIterator) Next() int {\n    \n}\n\n\nfunc (this *BSTIterator) HasPrev() bool {\n    \n}\n\n\nfunc (this *BSTIterator) Prev() int {\n    \n}\n\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * obj := Constructor(root);\n * param_1 := obj.HasNext();\n * param_2 := obj.Next();\n * param_3 := obj.HasPrev();\n * param_4 := obj.Prev();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nclass BSTIterator(_root: TreeNode) {\n\n    def hasNext(): Boolean = {\n        \n    }\n\n    def next(): Int = {\n        \n    }\n\n    def hasPrev(): Boolean = {\n        \n    }\n\n    def prev(): Int = {\n        \n    }\n\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass BSTIterator(root: TreeNode?) {\n\n    fun hasNext(): Boolean {\n        \n    }\n\n    fun next(): Int {\n        \n    }\n\n    fun hasPrev(): Boolean {\n        \n    }\n\n    fun prev(): Int {\n        \n    }\n\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nstruct BSTIterator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BSTIterator {\n\n    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_prev(&self) -> bool {\n        \n    }\n    \n    fn prev(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * let obj = BSTIterator::new(root);\n * let ret_1: bool = obj.has_next();\n * let ret_2: i32 = obj.next();\n * let ret_3: bool = obj.has_prev();\n * let ret_4: i32 = obj.prev();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass BSTIterator {\n    /**\n     * @param TreeNode $root\n     */\n    function __construct($root) {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasPrev() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function prev() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * $obj = BSTIterator($root);\n * $ret_1 = $obj->hasNext();\n * $ret_2 = $obj->next();\n * $ret_3 = $obj->hasPrev();\n * $ret_4 = $obj->prev();\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass BSTIterator {\n    constructor(root: TreeNode | null) {\n\n    }\n\n    hasNext(): boolean {\n\n    }\n\n    next(): number {\n\n    }\n\n    hasPrev(): boolean {\n\n    }\n\n    prev(): number {\n\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define bst-iterator%\n  (class object%\n    (super-new)\n\n    ; root : (or/c tree-node? #f)\n    (init-field\n      root)\n    \n    ; has-next : -> boolean?\n    (define/public (has-next)\n\n      )\n    ; next : -> exact-integer?\n    (define/public (next)\n\n      )\n    ; has-prev : -> boolean?\n    (define/public (has-prev)\n\n      )\n    ; prev : -> exact-integer?\n    (define/public (prev)\n\n      )))\n\n;; Your bst-iterator% object will be instantiated and called as such:\n;; (define obj (new bst-iterator% [root root]))\n;; (define param_1 (send obj has-next))\n;; (define param_2 (send obj next))\n;; (define param_3 (send obj has-prev))\n;; (define param_4 (send obj prev))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec bst_iterator_init_(Root :: #tree_node{} | null) -> any().\nbst_iterator_init_(Root) ->\n  .\n\n-spec bst_iterator_has_next() -> boolean().\nbst_iterator_has_next() ->\n  .\n\n-spec bst_iterator_next() -> integer().\nbst_iterator_next() ->\n  .\n\n-spec bst_iterator_has_prev() -> boolean().\nbst_iterator_has_prev() ->\n  .\n\n-spec bst_iterator_prev() -> integer().\nbst_iterator_prev() ->\n  .\n\n\n%% Your functions will be called as such:\n%% bst_iterator_init_(Root),\n%% Param_1 = bst_iterator_has_next(),\n%% Param_2 = bst_iterator_next(),\n%% Param_3 = bst_iterator_has_prev(),\n%% Param_4 = bst_iterator_prev(),\n\n%% bst_iterator_init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule BSTIterator do\n  @spec init_(root :: TreeNode.t | nil) :: any\n  def init_(root) do\n\n  end\n\n  @spec has_next() :: boolean\n  def has_next() do\n\n  end\n\n  @spec next() :: integer\n  def next() do\n\n  end\n\n  @spec has_prev() :: boolean\n  def has_prev() do\n\n  end\n\n  @spec prev() :: integer\n  def prev() do\n\n  end\nend\n\n# Your functions will be called as such:\n# BSTIterator.init_(root)\n# param_1 = BSTIterator.has_next()\n# param_2 = BSTIterator.next()\n# param_3 = BSTIterator.has_prev()\n# param_4 = BSTIterator.prev()\n\n# BSTIterator.init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"11.2K\", \"totalSubmission\": \"15.9K\", \"totalAcceptedRaw\": 11217, \"totalSubmissionRaw\": 15872, \"acRate\": \"70.7%\"}",
        "hints": [
            "The inorder traversal of a BST gives us the elements in a sorted order.",
            "We can use a stack to simulate the inorder traversal of the BST.",
            "We can use another stack as a buffer to store numbers returned from calls to next and use this buffer whenever prev is called."
        ],
        "solution": {
            "id": "1054",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"BSTIterator\",\"next\",\"next\",\"prev\",\"next\",\"hasNext\",\"next\",\"next\",\"next\",\"hasNext\",\"hasPrev\",\"prev\",\"prev\"]\n[[[7,3,15,null,null,9,20]],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null]]",
        "metaData": "{\n  \"classname\": \"BSTIterator\",\n  \"constructor\": {\n    \"params\": [\n      {\n        \"type\": \"TreeNode\",\n        \"name\": \"root\"\n      }\n    ]\n  },\n  \"methods\": [\n    {\n      \"params\": [],\n      \"name\": \"hasNext\",\n      \"return\": {\n        \"type\": \"boolean\"\n      }\n    },\n    {\n      \"params\": [],\n      \"name\": \"next\",\n      \"return\": {\n        \"type\": \"integer\"\n      }\n    },\n    {\n      \"params\": [],\n      \"name\": \"hasPrev\",\n      \"return\": {\n        \"type\": \"boolean\"\n      }\n    },\n    {\n      \"params\": [],\n      \"name\": \"prev\",\n      \"return\": {\n        \"type\": \"integer\"\n      }\n    }\n  ],\n  \"return\": {\n    \"type\": \"boolean\"\n  },\n  \"systemdesign\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "897",
            "date": "2022-04-15",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1054",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nWe're asked to implement an iterator, _i.e._, \nsomething that can be used to traverse a [container](https://en.wikipedia.org/wiki/Container_(abstract_data_type)) \nand access its elements  \nwithout entering into the details of the container implementation.  \n \nThere are two standard requirements for the iterators, \nto use them in code easily without impacting time complexity:\n\n- To provide `next` and `prev` operations in a constant time (or in _average_ constant time). \n\n- Do not perform any heavy operations during the iterator's initialization.\n\nHere, the container object is a _binary search tree_ (BST).\nFor the BST, the standard requirement is to return elements in an ascending order.\n_I.e._, `next` operator returns the smallest node _greater_ than the current one.\n`Prev` operator returns the largest node _less_ than the current one.\n\n![img](../Figures/1586/iterator.png)\n*Figure 1. BST iterator. Next operator returns the smallest node _greater_ than the current one.\nPrev operator returns the largest node _less_ than the current one.*\n{:align=\"center\"}\n\nAn essential property of BST is that \n_inorder_ traversal of BST is an array sorted in the ascending order.\nThus, the inorder traversal will be the core of the solution.\nAs a prerequisite, you might want to check the article \n[Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/solution/), \nthere all three types of inorder traversal: recursive, iterative, and Morris are discussed \nin details.  \n\n<br /> \n<br />\n\n\n--- \n#### Approach 1: Flatten Binary Search Tree: Recursive Inorder Traversal\n\nLet's start from the first requirement to the iterator:\nto provide `next` and `prev` operations in a constant time.\nFor that, we could flatten the binary tree using recursive inorder traversal\nand then use a pointer to iterate over the elements. \nThe drawback of this approach is that to initialize an iterator, one has to traverse the entire tree, which takes a linear time. \n\n![img](../Figures/1586/flatten.png)\n*Figure 2. Approach 1. Flatten BST and then use pointer to iterate over.*\n{:align=\"center\"}\n\n**Algorithm**\n\n- Constructor: flatten BST into the `arr` list during the iterator initialization.\nRecursive inorder traversal is simple: \nfollow `Left->Node->Right` direction, _i.e._ do the recursive call\nfor the _left_ child, then do all the business with the node\n(_i.e._, to add node value into the list), and\nthen do the recursive call for the _right_ child.\n\n- Initialize list length `n` and pointer `pointer = -1`.\n\n- `hasNext`: compare the pointer to the list length: \n`return pointer < n - 1`.\n\n- `next`: increase the pointer by one and return `arr[pointer]`.\n\n- `hasPrev`: compare the pointer to zero: \n`return pointer > 0`.\n\n- `prev`: decrease the pointer by one and return `arr[pointer]`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/bb5AbhRh/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bb5AbhRh\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(N)$$ for the iterator constructor,\nand $$\\mathcal{O}(1)$$ for `hasNext`, `next`, `hasPrev`, and `prev`.   \n\n* Space complexity: $$\\mathcal{O}(N)$$ to store list `arr` with $$N$$ elements. \n<br /> \n<br />\n\n\n---\n#### Approach 2: Follow-up: Iterative Inorder Traversal\n\nThe drawback of Approach 1 is that the iterator constructor\ntakes a linear time. For many practical applications, \nthe initialization in constant time is mandatory. \n\nSo, the idea is to do almost nothing during the iterator initialization and \nparse the bare minimum number of nodes at each `next` call. \nThis bare minimum in the worst-case situation is a complete leftmost subtree of the last node. \nSince we need to stop and then restart tree traversal at any moment,\nwe could use _iterative inorder traversal_ here. \n\n![img](../Figures/1586/leftmost4.png)\n*Figure 3. The worst-case situation: one has to parse the leftmost subtree\nof the last processed node during the `next` call.*\n{:align=\"center\"}\n\nThat makes the time complexity of the `next` call to be equal to\n$$\\mathcal{O}(N)$$ because in the worst-case of the skewed tree\none has to parse the entire tree, all $$N$$ nodes.\n\n> However, the important thing to note here is that it's\nthe _worst-case_ time complexity. \nWe only make such a call for the nodes which we've not yet parsed.\nWe could save all parsed nodes in a list and\nthen re-use them if we need to return `next`\nfrom the already parsed area of the tree. \n\n![img](../Figures/1586/parsing.png)\n*Figure 4. The _average_ situation: the node to return is in the  \nparsed area.*\n{:align=\"center\"}\n\nThus, the _amortized_ (average) time complexity for \nthe `next` call would still be $$\\mathcal{O}(1)$$, that is perfectly fine for \nthe practical applications. \n\n**Algorithm**\n\n- Constructor in $$\\mathcal{O}(1)$$:\n    \n    - Initialize the last processed node as root: `last = root`.\n\n    - Initialize a list to store already processed nodes: `arr`.\n    \n    - Initialize service data structure `stack` to be used during \n    the iterative inorder traversal.\n    \n    - Initialize pointer: `pointer = -1`. This pointer serves\n    as indicator if we're in the already parsed area or not. \n    We're in the parsed area if `pointer + 1 < len(arr)`.\n    \n- `hasNext`:\n\n    - Return true if last node is not null, or the stack is not empty,\n    or we're in the already parsed area: `pointer + 1 < len(arr)`.\n    \n- `next`:\n\n    - Increase the pointer by 1: `pointer += 1`.\n    \n    - If we're _not_ in the precomputed part of the tree, parse the bare \n    minimum: the leftmost subtree of the last node:\n    \n        - Go left till you can, while the last node is not null:\n        \n            - Push the last node into the stack: `stack.append(last)`.\n            \n            - Go left: `last = left.last`.\n        \n        - Pop the last node out of the stack: `curr = stack.pop()`.\n        \n        - Append this node value to the list of the parsed nodes:\n        `arr.append(curr.val)`.\n        \n        - Go one step to the right: `last = curr.right`.\n    \n    - Otherwise, return `arr[pointer]`.\n    \n- `hasPrev`: \n    \n    - Compare the pointer to zero: `return pointer > 0`.\n\n- `prev`: decrease the pointer by one and return `arr[pointer]`.  \n\n\n**Implementation**\n\nNote, that \n[Javadocs recommends to use ArrayDeque, and not Stack as a stack implementation](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html).\n\n<iframe src=\"https://leetcode.com/playground/hspv9CUp/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"hspv9CUp\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity. Let's look at the complexities one by one:\n\n    - $$\\mathcal{O}(1)$$ for the constructor.\n    \n    - $$\\mathcal{O}(1)$$ for `hasPrev`.\n    \n    - $$\\mathcal{O}(1)$$ for `prev`.\n    \n    - $$\\mathcal{O}(1)$$ for `hasNext`.\n    \n    - $$\\mathcal{O}(N)$$ for `next`. \n    In the worst-case of the skewed tree\n    one has to parse the entire tree, all $$N$$ nodes.\n\n    > However, the important thing to note here is that it's\n    the _worst-case_ time complexity. \n    We only make such a call for the nodes which we've not yet parsed.\n    We save all parsed nodes in a list, and\n    then re-use them if we need to return `next`\n    from the already parsed area of the tree. \n\n    Thus, the _amortized_ (average) time complexity for \n    the `next` call would still be $$\\mathcal{O}(1)$$.\n\n* Space complexity: $$\\mathcal{O}(N)$$. The space is taken by `stack` and `arr`.\n`stack` contains up to $$H$$ elements, where $$H$$ is the tree height,\nand `arr` up to $$N$$ elements. \n<br /> \n<br />\n\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1009",
            "count": 16,
            "average": "4.875",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "binary-search-tree-iterator-ii",
    "playgroundData": {
        "bb5AbhRh": {
            "playground": {
                "testcaseInput": "",
                "name": "binary-search-tree-iterator-ii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "hspv9CUp": {
            "playground": {
                "testcaseInput": "",
                "name": "binary-search-tree-iterator-ii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}