{
    "id": "1772",
    "question": {
        "questionId": "1772",
        "questionFrontendId": "1649",
        "boundTopicId": null,
        "title": "Create Sorted Array through Instructions",
        "titleSlug": "create-sorted-array-through-instructions",
        "content": "<p>Given an integer array <code>instructions</code>, you are asked to create a sorted array from the elements in <code>instructions</code>. You start with an empty container <code>nums</code>. For each element from <strong>left to right</strong> in <code>instructions</code>, insert it into <code>nums</code>. The <strong>cost</strong> of each insertion is the <b>minimum</b> of the following:</p>\r\n\r\n<ul>\r\n\t<li>The number of elements currently in <code>nums</code> that are <strong>strictly less than</strong> <code>instructions[i]</code>.</li>\r\n\t<li>The number of elements currently in <code>nums</code> that are <strong>strictly greater than</strong> <code>instructions[i]</code>.</li>\r\n</ul>\r\n\r\n<p>For example, if inserting element <code>3</code> into <code>nums = [1,2,3,5]</code>, the <strong>cost</strong> of insertion is <code>min(2, 1)</code> (elements <code>1</code> and <code>2</code> are less than <code>3</code>, element <code>5</code> is greater than <code>3</code>) and <code>nums</code> will become <code>[1,2,3,3,5]</code>.</p>\r\n\r\n<p>Return <em>the <strong>total cost</strong> to insert all elements from </em><code>instructions</code><em> into </em><code>nums</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code></p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> instructions = [1,5,6,2]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong> Begin with nums = [].\r\nInsert 1 with cost min(0, 0) = 0, now nums = [1].\r\nInsert 5 with cost min(1, 0) = 0, now nums = [1,5].\r\nInsert 6 with cost min(2, 0) = 0, now nums = [1,5,6].\r\nInsert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].\r\nThe total cost is 0 + 0 + 0 + 1 = 1.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> instructions = [1,2,3,6,5,4]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> Begin with nums = [].\r\nInsert 1 with cost min(0, 0) = 0, now nums = [1].\r\nInsert 2 with cost min(1, 0) = 0, now nums = [1,2].\r\nInsert 3 with cost min(2, 0) = 0, now nums = [1,2,3].\r\nInsert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].\r\nInsert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].\r\nInsert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].\r\nThe total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> instructions = [1,3,3,3,2,4,2,1,2]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Begin with nums = [].\r\nInsert 1 with cost min(0, 0) = 0, now nums = [1].\r\nInsert 3 with cost min(1, 0) = 0, now nums = [1,3].\r\nInsert 3 with cost min(1, 0) = 0, now nums = [1,3,3].\r\nInsert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].\r\nInsert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].\r\nInsert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].\r\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].\r\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].\r\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].\r\nThe total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= instructions.length &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>1 &lt;= instructions[i] &lt;= 10<sup>5</sup></code></li>\r\n</ul>",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 489,
        "dislikes": 68,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Count Good Triplets in an Array\", \"titleSlug\": \"count-good-triplets-in-an-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Substring of One Repeating Character\", \"titleSlug\": \"longest-substring-of-one-repeating-character\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[1,5,6,2]\n[1,2,3,6,5,4]\n[1,3,3,3,2,4,2,1,2]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Divide and Conquer",
                "slug": "divide-and-conquer",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Indexed Tree",
                "slug": "binary-indexed-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Segment Tree",
                "slug": "segment-tree",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Merge Sort",
                "slug": "merge-sort",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Ordered Set",
                "slug": "ordered-set",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Akuna Capital\", \"slug\": \"akuna-capital\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int createSortedArray(vector<int>& instructions) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int createSortedArray(int[] instructions) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def createSortedArray(self, instructions):\n        \"\"\"\n        :type instructions: List[int]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def createSortedArray(self, instructions: List[int]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint createSortedArray(int* instructions, int instructionsSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int CreateSortedArray(int[] instructions) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} instructions\n * @return {number}\n */\nvar createSortedArray = function(instructions) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} instructions\n# @return {Integer}\ndef create_sorted_array(instructions)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func createSortedArray(_ instructions: [Int]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func createSortedArray(instructions []int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def createSortedArray(instructions: Array[Int]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun createSortedArray(instructions: IntArray): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn create_sorted_array(instructions: Vec<i32>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $instructions\n     * @return Integer\n     */\n    function createSortedArray($instructions) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function createSortedArray(instructions: number[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"20.4K\", \"totalSubmission\": \"54.6K\", \"totalAcceptedRaw\": 20358, \"totalSubmissionRaw\": 54638, \"acRate\": \"37.3%\"}",
        "hints": [
            "This problem is closely related to finding the number of inversions in an array",
            "if i know the position in which i will insert the i-th element in I can find the minimum cost to insert it"
        ],
        "solution": {
            "id": "1045",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,5,6,2]",
        "metaData": "{\n  \"name\": \"createSortedArray\",\n  \"params\": [\n    {\n      \"name\": \"instructions\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1045",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nThe problem is straightforward. We need to obtain the cost of inserting each element in sorted order and return the total cost.\n\nHow to determine the cost? According to the description, we need to find the number of elements on the left side strictly less/larger than the current element.\n\nOne natural idea is to maintain a sorted array and search with [Binary Search](https://leetcode.com/explore/learn/card/binary-search/). However, the array insertion takes $$\\mathcal{O}(M)$$, given that $$M$$ is the length of the array, which is too slow. We need something quicker.\n\nLuckily, there are two helpful and fast data structures: Segment Tree and Binary Indexed Tree.\n\nAlso, if one is not familiar with those trees, a solution of simple modifications on [Merge Sort](https://en.wikipedia.org/wiki/Merge_sort) is available.\n\nBelow, we will discuss three approaches: *Segment Tree*, *Binary Indexed Tree*, and *Merge Sort*.\n\nAt the end of the article, in *Extra* part, we will present some interesting relevant facts that may not be useful in the interview though. We leave that for interested readers.\n\n---\n\n#### Approach 1: Segment Tree\n\n**Intuition**\n\nSince we already have some great explanations on [Segment Tree](https://en.wikipedia.org/wiki/Segment_tree), here we will not provide a detailed explanation of implementation. You can find some comprehensive tutorials on [Recursive Approach to Segment Trees](https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/) or [Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/solution/).\n\nNow, we will have a quick review of the segment tree and then explain how we can use it to tackle our problem.\n\nAs we know, segment tree is a data structure used for storing information about intervals. Given that $$M$$ is the size of the tree, this data structure allows us to `query` and to `update` the information about a certain interval in $$\\mathcal{O}(\\log(M))$$ time.\n\nTake the segment tree for querying interval **sum** for an example:\n\n![Figure 1](../Documents/5564/5564_1.drawio.svg)\n\nUsually, we store the tree in an array. We need twice the size of the original array to store the segment tree.\n\nHere, we leave the index `0` unused for the convenience of indexing. You can also choose to use it by shifting the whole tree one unit left. In our approach, the left and right children of node `i` are `2*i` and `2*i+1` respectively.\n\nGiven that `m` is the size of the original array, from the node `m` to node `2*m - 1`, we store the original array itself. For other nodes, we store the value of node `i` as the sum of node `2*i` and node `2*i+1`.\n\nThe segment tree allows us to `query` the **sum** of a certain interval and to `update` the values of elements. It should be able to process both actions in $$\\mathcal{O}(\\log(M))$$ time. Let's see some examples.\n\n*Updating Value*\n\nFor `update`, what we do is simple. Just update the value from the leaf to the root. For instance:\n\n![Figure 2](../Documents/5564/5564_2.drawio.svg)\n\n*Querying Sum*\n\nFor `query`, the case is a bit complicated. Generally speaking, we are dividing the target interval into a few pre-calculated segments to reduced run time. For example:\n\n![Figure 3](../Documents/5564/5564_3.drawio.svg)\n\nOK. Now back to our problem. We need to find the cost of each element. How can we use the segment tree?\n\nUsing some idea from [Bucket](https://en.wikipedia.org/wiki/Bucket_(computing)), we can store the **occurrence number** of values in a bucket array. Then, by querying the interval sum for the current value to the maximum value, we obtain the number of larger elements.\n\nTo give you an idea, consider this case: `instructions` is `[2, 3, 3, 3, 3, 1, 0]`, and we are processing element `instructions[5] = 1`. When we want to query the number of larger elements, we want to query the sum from `2` to the largest value `3` (i.e., the sum on the right of value `1` in Segment Tree):\n\n![Figure 4](../Documents/5564/5564_4.drawio.svg)\n\nUpdating the segment tree is also easy. We just need to add `1` to the node of the current element and all the path up to the root.\n\n**Algorithm**\n\n*Step 1:* Implement the Segment Tree. Since the tree is initialized to all zeros, only `update` and `query` needs to be implemented.\n\n*Step 2:* Iterate over `instructions`. For each element:\n\n- Calculate the left cost (smaller cost) and right cost (larger cost).\n- Add the minimal one to the total cost.\n- Update the element into the Segment Tree.\n\n*Step 3:* Return the total cost after iteration.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/cTEE2Xcv/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"cTEE2Xcv\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `instructions` and $$M$$ be the maximum value in `instructions`.\n\n* Time Complexity: $$\\mathcal{O}(N\\log(M))$$. We need to iterate over `instructions`, and for each element, the time to find the left cost and right cost is $$\\mathcal{O}(\\log(M))$$, and we spend $$\\mathcal{O}(\\log(M))$$ inserting the current element into the Segment Tree. In total, we need $$\\mathcal{O}(N \\cdot \\log(M)) = \\mathcal{O}(N\\log(M))$$.\n\n* Space Complexity: $$\\mathcal{O}(M)$$, since we need an array of size $$2M$$ to store Segment Tree.\n\n---\n\n#### Approach 2: Binary Indexed Tree (BIT)\n\n**Intuition**\n\n[Binary indexed tree](https://en.wikipedia.org/wiki/Fenwick_tree) (or Fenwick Tree, BIT) is a data structure similar to the segment tree that maintains information about the **prefix**.\n\nCompared with the segment tree, BIT has smaller space complexity and faster performance (same complexity but smaller constant) but lower expandability. For example, it is hard for BIT to address the interval minimum problem while the segment tree can easily handle it.\n\nYou can find some relevant tutorials on [Reverse Pairs](https://leetcode.com/problems/reverse-pairs/solution/) or [Range Sum Query 2D - Mutable](https://leetcode.com/problems/range-sum-query-2d-mutable/solution/).\n\nNow, we will have a quick review of BIT and then explain how we can use it to tackle our problem.\n\nLike the segment tree, BIT empowers us to `update` the values of elements and to `query` the information from node `0` to node `i`. It can answer both actions in $$\\mathcal{O}(\\log(M))$$ time, given that the size of BIT is $$\\mathcal{O}(M)$$.\n\nFor intuitive understanding, it is not recommended to view BIT as a tree but as an **array** with parents relationship for beginners.\n\nTake the BIT for querying prefix **sum** for an example.\n\n![Figure 5](../Documents/5564/5564_5.drawio.svg)\n\nWe construct this relationship: the parent of node `i` is node `i + (i & -i)`, where `&` is the bitwise AND operator.\n\n> In fact, $$i \\& -i$$ have some connections to the position of the rightmost $$1$$ in binary form counting from right. Say, the position of the rightmost $$1$$ in binary representation of $$i$$ is $$k$$, and then we have $$i \\& -i = 2^{k-1}$$. \n> \n> For example, the base-2 form of $$6$$ is $$110$$, the position of the rightmost $$1$$ is in the **second** position counting from right. We have $$6 \\& -6 = 2^{2-1} = 2$$.\n>\n> Also, $$2^{k-1}$$ represents the number of elements adding up. For instance, `BIT[6] = arr[4] + arr[5]`, which consists of **two** elements: `arr[4]` and `arr[5]`.\n\nWhen building BIT, we initialize the array `BIT` of length $$M+1$$, where $$M$$ is the size of the original array.\n\nWe use index `0` as a dummy node for the convenience of indexing. Then for each element `arr[j]` in original array `arr`, we put it in `BIT[j+1]`. Also, we maintain `BIT` such that the value of every node is the sum of the values of its children. Therefore, we add `arr[j]` all the path from `BIT[j+1]` to the root in `BIT`. \n\nSimilarly, `update` and `query` are available in BIT. Let's check the detail.\n\n*Updating Value*\n\nIt is easy to `update` an element. For instance, if we need to `update` `1` to `100` in the last example:\n\n![Figure 6](../Documents/5564/5564_6.drawio.svg)\n\n*Querying Sum*\n\nFor `query`, it is also simple. Say, if we want to calculate the prefix sum to `arr[j]`. We need to initialize `i` to `j+1`, and then add `BIT[i]` to the query answer. After that, replace `i` to `i - (i & -i)`, and then add new `BIT[i]`, until `i` reaches `0`.\n\nFor example, if we need to sum up from `arr[0]` to `arr[4]`:\n\n![Figure 7](../Documents/5564/5564_7.drawio.svg)\n\n> Note that BIT only supports prefix information querying, so we can only query from start to a certain element, not any interval.\n\nOK. Now back to our problem. How can we use BIT to resolve this problem?\n\nSimilar to *Approach 1*, we store the **occurrence number** of values in an array. Then, by querying the interval sum for the current value to the maximum value, we obtain the number of larger elements.\n\nUpdating the BIT is also easy. We just need to add `1` to the node of the current element and add other corresponding nodes.\n\n**Algorithm**\n\n*Step 1:* Implement the Binary Indexed Tree. Since the tree is initialized to all zeros, only `update` and `query` is needed to implement.\n\n*Step 2:* Iterate over `instructions`. For each element:\n\n- Calculate the left cost (smaller cost) and right cost (larger cost).\n- Add the minimal one to the total cost.\n- Update the element into the Binary Indexed Tree.\n\n*Step 3:* Return the total cost after iteration.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/ktoXotVH/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ktoXotVH\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `instructions` and $$M$$ be the maximum value in `instructions`.\n\n* Time Complexity: $$\\mathcal{O}(N\\log(M))$$. We need to iterate over `instructions`, and for each element, the time to find the left cost and right cost is $$\\mathcal{O}(\\log(M))$$, and we spend $$\\mathcal{O}(\\log(M))$$ inserting the current element into the BIT. In total, we need $$\\mathcal{O}(N \\cdot \\log(M)) = \\mathcal{O}(N\\log(M))$$.\n\n* Space Complexity: $$\\mathcal{O}(M)$$, since we need an array of size $$\\mathcal{O}(M)$$ to store BIT.\n\n---\n\n#### Approach 3: Merge Sort\n\n**Intuition**\n\nIn fact, this problem is a kind of extension of the original [Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/). They are similar except we need both smaller and larger ones on the left. \n\nInspired from the approach of the original problem, a simple modification of merge sort will help us address this problem. Let's see the idea.\n\nWithout loss of generality, consider larger ones on the left first.\n\nIf you consider the process of sorting, you will find out a useful insight:\n\n> The larger elements on the left of a number are exactly those that **jump from its left to its right** during a stable sort.\n\nFor example, consider when `instructions = [1, 7, 6, 3, 4]` and we want to calculate the number of larger elements on the left of `instructions[3] = 3`:\n\n![Figure 8](../Documents/5564/5564_8.drawio.svg)\n\n> We use the term **stable** sort here since we do not want to count the jumping of adjacent elements with the same values. We want to keep them as what they are.\n\nTherefore, we want to record the jumping numbers when sorting. \n\nBut which sorting method? Well, many sorting methods can do it. Here, we pick merge sort for an example.\n\nMerge sort is simple: split the array into two parts, recursively call merge sort on each part, and then merge two parts.\n\nNote that in the \"merge\" step what we do is exactly deciding which element goes left and which element goes right. We can record the jumping number when merging.\n\nFor instance, consider when `instructions = [7, 2, 3, 4, 1, 6]` and we already have divided it into two parts and sorted them: `[2, 3, 7]` and `[1, 4, 6]`. Now we need to merge those two parts:\n\n![Figure 9](../Documents/5564/5564_9.drawio.svg)\n\nWhen we decide that we should put the number in the second array, all elements remaining in the first array are jumping from left to right. What we need to do is to add the length of the first array.\n\nThe case of smaller ones is similar. We can record the number of elements that **stay** on left after sorting. To avoid counting those with the same value, we need a totally unstable sort here (i.e., adjacent same values become reversed order).\n\n> Alternatively, you can stably sort them from large to small, and record those jump from left to right.\n\n> However, one should notice that this approach may be slower than previous approaches since we do merge sort twice to solve the larger case and smaller case respectively.\n\n**Algorithm**\n\n*Step 1:* Initialize `larger` array and `smaller` array, which store the number of elements on left strictly larger and smaller than the current element, respectively. \n\n*Step 2:* Implement two merge sort function: `sortLarger`and ``sortSmaller``.\n\n- For `sortLarger`, we perform a stable merge sort. When merging, we record the number of elements jumping from left to right.\n- For `sortSmaller`, we perform a totally unstable merge sort. When merging, we record the number of elements staying on left.\n\n*Step 3:* Iterate over `instructions`. For each element:\n\n- Add the minimal of `smaller[i]` and `larger[i]` to the total cost.\n- Update the element into the Binary Indexed Tree.\n\n*Step 3:* Return the total cost after iteration.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/ZGNFMraq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ZGNFMraq\"></iframe>\n\nNote:\n\n- In C++ code, we used a raw array instead of `vector` to avoid TLE. However, in most cases, `vector` should be preferred since it has more functions and is safer than the array.\n- The Python version is likely to yield a TLE since Python itself is slow. This time limit may be extended in the future.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of `instructions`.\n\n* Time Complexity: $$\\mathcal{O}(N\\log(N))$$. We need to perform $$\\mathcal{O}(N\\log(N))$$ merge sort twice. All other operations take no more than $$\\mathcal{O}(N)$$.\n\n* Space Complexity: $$\\mathcal{O}(N)$$, since we need constant number of arrays of size $$\\mathcal{O}(N)$$.\n\n---\n\n#### Extra\n\n**1. Order Statistic Tree**\n\nIn fact, what we do in *Approach 1* and *Approach 2* is implementing an [Order Statistic Tree](https://en.wikipedia.org/wiki/Order_statistic_tree) interface with different implementations. The wiki page also gives us another implementation, but that requires extra code and we leave that for interested readers.\n\n**2. The $$\\mathcal{O}(N^2)$$ Python Approach**\n\nThough Python itself is slow, its many built-in functions are written in C which is fast. As a result, sometimes the built-in functions are faster than our manual implementation, even with larger time complexity.\n\nIn this case, maintaining a sorted list with `bisect` is sometimes faster than the Segment Tree Approach in the current data scale.\n\n<iframe src=\"https://leetcode.com/playground/6SHvVp74/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"6SHvVp74\"></iframe>\n\n**3. The $$\\mathcal{O}(N\\log(N))$$ built-in Python Approach**\n\nPython is an interesting language with many useful libraries. In a third-party library `sortedcontainers`, we have a `SortedList` that supports update in $$\\mathcal{O}(\\log(N))$$, given that $$N$$ is the length of the sorted list.\n\nYou can check the implementation detail in its [official docs](http://www.grantjenks.com/docs/sortedcontainers/implementation.html). In short, it implements a Segment-Tree-like structure.\n\n<iframe src=\"https://leetcode.com/playground/97xTfB9a/shared\" frameBorder=\"0\" width=\"100%\" height=\"310\" name=\"97xTfB9a\"></iframe>\n\n**4. The $$\\mathcal{O}(N\\sqrt{N})$$ Approach**\n\nThough with larger time complexity, this approach can be solved with *Sqrt Decomposition*. We will not introduce it in detail since it yields TLE for this problem.\n\nGenerally speaking, what we do is to split the sorted list into $$\\mathcal{O}(\\sqrt{N})$$ sublists of size $$\\mathcal{O}(\\sqrt{N})$$, and we only need to spend $$\\mathcal{O}(\\sqrt{N})$$ on insertion. Interested readers can check [Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/solution/) for some idea.\n\nThanks for reading!",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1000",
            "count": 26,
            "average": "4.269",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "create-sorted-array-through-instructions",
    "playgroundData": {
        "cTEE2Xcv": {
            "playground": {
                "testcaseInput": "",
                "name": "create-sorted-array-through-instructions-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "ktoXotVH": {
            "playground": {
                "testcaseInput": "",
                "name": "create-sorted-array-through-instructions-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "ZGNFMraq": {
            "playground": {
                "testcaseInput": "",
                "name": "create-sorted-array-through-instructions-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "6SHvVp74": {
            "playground": {
                "testcaseInput": "",
                "name": "create-sorted-array-through-instructions-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "97xTfB9a": {
            "playground": {
                "testcaseInput": "",
                "name": "create-sorted-array-through-instructions-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}