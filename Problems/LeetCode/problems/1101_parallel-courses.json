{
    "id": "1101",
    "question": {
        "questionId": "1101",
        "questionFrontendId": "1136",
        "boundTopicId": null,
        "title": "Parallel Courses",
        "titleSlug": "parallel-courses",
        "content": "<p>You are given an integer <code>n</code>, which indicates that there are <code>n</code> courses labeled from <code>1</code> to <code>n</code>. You are also given an array <code>relations</code> where <code>relations[i] = [prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code>, representing a prerequisite relationship between course <code>prevCourse<sub>i</sub></code> and course <code>nextCourse<sub>i</sub></code>: course <code>prevCourse<sub>i</sub></code> has to be taken before course <code>nextCourse<sub>i</sub></code>.</p>\n\n<p>In one semester, you can take <strong>any number</strong> of courses as long as you have taken all the prerequisites in the <strong>previous</strong> semester for the courses you are taking.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of semesters needed to take all courses</em>. If there is no way to take all the courses, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/24/course1graph.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> n = 3, relations = [[1,3],[2,3]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The figure above represents the given graph.\nIn the first semester, you can take courses 1 and 2.\nIn the second semester, you can take course 3.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/24/course2graph.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> n = 3, relations = [[1,2],[2,3],[3,1]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> No course can be studied because they are prerequisites of each other.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>1 &lt;= relations.length &lt;= 5000</code></li>\n\t<li><code>relations[i].length == 2</code></li>\n\t<li><code>1 &lt;= prevCourse<sub>i</sub>, nextCourse<sub>i</sub> &lt;= n</code></li>\n\t<li><code>prevCourse<sub>i</sub> != nextCourse<sub>i</sub></code></li>\n\t<li>All the pairs <code>[prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 757,
        "dislikes": 21,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Course Schedule II\", \"titleSlug\": \"course-schedule-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Parallel Courses II\", \"titleSlug\": \"parallel-courses-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Parallel Courses III\", \"titleSlug\": \"parallel-courses-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "3\n[[1,3],[2,3]]\n3\n[[1,2],[2,3],[3,1]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Graph",
                "slug": "graph",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Topological Sort",
                "slug": "topological-sort",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": true, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Twitch\", \"slug\": \"twitch\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minimumSemesters(int n, vector<vector<int>>& relations) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minimumSemesters(int n, int[][] relations) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minimumSemesters(self, n, relations):\n        \"\"\"\n        :type n: int\n        :type relations: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minimumSemesters(int n, int** relations, int relationsSize, int* relationsColSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinimumSemesters(int n, int[][] relations) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number[][]} relations\n * @return {number}\n */\nvar minimumSemesters = function(n, relations) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer} n\n# @param {Integer[][]} relations\n# @return {Integer}\ndef minimum_semesters(n, relations)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minimumSemesters(_ n: Int, _ relations: [[Int]]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minimumSemesters(n int, relations [][]int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minimumSemesters(n: Int, relations: Array[Array[Int]]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minimumSemesters(n: Int, relations: Array<IntArray>): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn minimum_semesters(n: i32, relations: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $relations\n     * @return Integer\n     */\n    function minimumSemesters($n, $relations) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minimumSemesters(n: number, relations: number[][]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (minimum-semesters n relations)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec minimum_semesters(N :: integer(), Relations :: [[integer()]]) -> integer().\nminimum_semesters(N, Relations) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec minimum_semesters(n :: integer, relations :: [[integer]]) :: integer\n  def minimum_semesters(n, relations) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"45.1K\", \"totalSubmission\": \"72.9K\", \"totalAcceptedRaw\": 45138, \"totalSubmissionRaw\": 72914, \"acRate\": \"61.9%\"}",
        "hints": [
            "Try to think of it as a graph problem. It will be impossible to study all the courses if the graph had a cycle.",
            "The graph is a directed acyclic graph (DAG). The answer is the longes path in this DAG.",
            "You can use DP to find the longest path in the DAG."
        ],
        "solution": {
            "id": "1108",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "3\n[[1,3],[2,3]]",
        "metaData": "{\n  \"name\": \"minimumSemesters\",\n  \"params\": [\n    {\n      \"name\": \"n\",\n      \"type\": \"integer\"\n    },\n    {\n      \"name\": \"relations\",\n      \"type\": \"integer[][]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "935",
            "date": "2022-05-29",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1108",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nIn this problem, we need to learn all the courses as fast as possible. The number of courses we can learn in one semester is unlimited, and the only limitation is the prerequisite relationship: we can only learn those courses whose prerequisite(s) is fulfilled.\n\nThis problem is an application of [Topological sorting](https://en.wikipedia.org/wiki/Topological_sorting), and there are mainly two different kinds of solutions: BFS (Breadth-First Search) and DFS (Depth-First Search).\n\nIn this article, three approaches are introduced:\n\n1. _Breadth-First Search (Kahn's Algorithm)_\n2. _Depth-First Search: Depth-First Search: Check for Cycles + Find Longest Path_\n3. _Depth-First Search: Combine_\n\nGenerally, we recommend _Approach 1_ and _Approach 3_ since they are efficient and easy to implement. We include _Approach 2_ for a better understanding to _Approach 3_. (Therefore, it is recommended to read _Approach 2_ before _Approach 3_.)\n\nOnce you've finished this problem, you can try challenging the follow-up [1494. Parallel Courses II](https://leetcode.com/problems/parallel-courses-ii/).\n\n<br/>\n\n---\n\n#### Approach 1: Breadth-First Search (Kahn's Algorithm)\n\n**Intuition**\n\nWe can treat the problem as a directed **graph** problem (the courses are nodes and the prerequisites are egdes). What we need to do is somehow iterate over all the nodes in the graph.\n\nFor iteration, we can do BFS or DFS. We introduce BFS in this approach and DFS in the following approaches.\n\nTo achieve the fastest learning speed, our strategy is:\n\n> Learn **all courses** available in each semester.\n\nThis is intuitive. Even if we deliberately choose not to learn one available course, we still need to learn it in the following semesters. There is no harm to learn it now. Also, if we learn it later, then we have to postpone all courses whose prerequisite is that course.\n\nNow, the first question is:\n\n> Where to start? (Which courses are available?)\n\nWe can not start from courses with prerequisites.\n\n> We start from nodes with **no prerequisites**.\n\nFor example, in this graph, which courses can we learn in the first semester?\n\n![Figure 1.1](../Documents/1136/1136_1_0_0.drawio.svg)\n\nYes, those courses marked with yellow can be learned in the first semester.\n\n![Figure 1.2](../Documents/1136/1136_1_0_1.drawio.svg)\n\nNow, we have learned those courses, what should we learn next?\n\n![Figure 1.3](../Documents/1136/1136_1_0_2.drawio.svg)\n\nYes, the new yellow courses can be learned, since their prerequisites are fulfilled:\n\n![Figure 1.4](../Documents/1136/1136_1_0_3.drawio.svg)\n\nKeep going until no available courses to learn.\n\nBy using this strategy to allocate courses to semesters, we are guaranteed to minimize the number of semesters needed. This is because in each semester, we're learning every course that isn't \"locked\" by a prerequisite, and so there is no possible way to be faster.\n\nLet's finish this example with Breadth-First Search:\n\n!?!../Documents/1136/1136_1_example1.json!?!\n\nIn some other cases, we can not learn all nodes. If the number of nodes we visited is strictly less than the number of total nodes, then there is not way to learn all the courses and we can do nothing but return `-1`.\n\nFor example, in this graph with a cycle, we can not learn all the courses:\n\n!?!../Documents/1136/1136_1_example2.json!?!\n\n> This approach is also called [Kahn's algorithm](https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm) (with some modifications to adapt to the problem).\n\n**Algorithm**\n\n_Step 1:_ Build a directed graph from `relations`.\n\n_Step 2:_ Record the in-degree of each node. (i.e., the number of edges towards the node)\n\n_Step 3:_ Initialize a queue, `queue`. Put nodes with an in-degree of `0` into `queue`. Initialize `step = 0`, `visited_count = 0`.\n\n_Step 4:_ Start BFS: Loop until `queue` is empty:\n\n1. Initialize a queue `next_queue`to record the nodes needed in the next iteration.\n2. Increment `step`.\n3. For each `node` in `queue`:\n   1. Increment `visitedCount`\n   2. For each `end_node` reachable from `node`:\n      1. Decrement the in-degree of `end_node`\n      2. If the in-degree of `end_node` reaches 0, push it into `next_queue`\n4. Assign `queue` to `next_queue`\n\n_Step 5:_ If `visited_count == N`, return `step`. Otherwise, return `-1`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/atkA9rDS/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"atkA9rDS\"></iframe>\n\n**Complexity Analysis**\n\nLet $$E$$ be the length of `relations`. $$N$$ is the number of courses, as explained in the problem description.\n\n- Time Complexity: $$\\mathcal{O}(N+E)$$. For building the graph, we spend $$\\mathcal{O}(N)$$ to initialize the graph, and spend $$\\mathcal{O}(E)$$ to add egdes since we iterate `relations` once. For BFS, we spend $$\\mathcal{O}(N+E)$$ since we need to visit every node and edge once in BFS in the worst case.\n\n- Space Complexity: $$\\mathcal{O}(N+E)$$. For the graph, we spend $$\\mathcal{O}(N+E)$$ since we have $$\\mathcal{O}(N)$$ keys and $$\\mathcal{O}(E)$$ values. For BFS, we spend $$\\mathcal{O}(N)$$ since in the worst case, we need to add all nodes to the queue in the same time.\n\n<br/>\n\n---\n\n#### Approach 2: Depth-First Search: Check for Cycles + Find Longest Path\n\n**Intuition**\n\nThere is an important insight:\n\n> The number of semesters needed is equal to the **length of the longest path** in the graph.\n\nFor example, the longest path in the graph below is `5`, so the number of semesters needed is `5`:\n\n![Figure 2.1](../Documents/1136/1136_2_1.drawio.svg)\n\nWhy? Treat the path as a sequence of prerequisites, and for each prerequisite, we need to spend one semester to advance to the next node.\n\nBut there is a problem: if the graph has a cycle, then the longest path would be infinite.\n\n![Figure 2.3](../Documents/1136/1136_2_2.drawio.svg)\n\nSo firstly, we need to check if the graph has a cycle. If it does, we can directly return `-1` since we can never finish all courses.\n\nNow we break the problem into two parts:\n\n1. Check if the graph has a cycle\n2. Calculate the length of the longest path\n\nEach of the two parts can be done with DFS. In _Approach 3_, we will show how to achieve those two-part simultaneously in one single DFS. However, in this approach, for a better understanding, we separate them into two separate DFS traverals.\n\n_Check If the Graph Has A Cycle_\n\nEach node has one of the three states: unvisited, visiting, and visited.\n\nBefore the DFS, we initialize all nodes in the graph to unvisited.\n\nWhen performing a DFS, we mark the current node as _visiting_ until we search all paths out of the node from the node. If we meet a node marked with processing, it must come from the upstream path and therefore, we've detected a cycle.\n\nIf DFS finishes, and all node are marked as visited, then the graph contains no cycle.\n\n_Calculate the Length of the Longest Path_\n\nThe DFS function should return the maximum out of the recursive calls for its child nodes, plus one (the node itself).\n\nIn order to prevent redundant calculations, we need to store the calculated results. This is an example of dynamic programming, as we're storing the result of subproblems.\n\n**Algorithm**\n\n_Step 1:_ Build a directed graph from `relations`.\n\n_Step 2:_ Implement a function `dfsCheckCycle` to check whether the graph has a cycle.\n\n_Step 3:_ Implement a function `dfsMaxPath` to calculate the length of the longest path in the graph.\n\n_Step 4:_ Call `dfsCheckCycle`, return `-1` if the graph has a cycle.\n\n_Step 5:_ Otherwise, call `dfsMaxPath`. Return the length of the longest path in the graph.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/QAXAZZMo/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"QAXAZZMo\"></iframe>\n\n**Complexity Analysis**\n\nLet $$E$$ be the length of `relations`.\n\n- Time Complexity: $$\\mathcal{O}(N+E)$$. For building the graph, we spend $$\\mathcal{O}(N)$$ to initialize the graph, and spend $$\\mathcal{O}(E)$$ to add egdes since we iterate `relations` once. For DFS, we spend $$\\mathcal{O}(N+E)$$ since we need to visit every node and edge once in DFS in the worst case.\n\n- Space Complexity: $$\\mathcal{O}(N+E)$$. For the graph, we spend $$\\mathcal{O}(N+E)$$ since we have $$\\mathcal{O}(N)$$ keys and $$\\mathcal{O}(E)$$ values. For DFS, we spend $$\\mathcal{O}(N)$$ since in the worst case, we need to add all nodes to the stack to recursively call DFS. Also, we run DFS twice.\n\n<br/>\n\n---\n\n#### Approach 3: Depth-First Search: Combine\n\n**Intuition**\n\n> This approach is an improvement of _Approach 2_. It is recommended to ensure that you fully understood _Approach 2_ before continuing onto this final approach.\n\nHere, we combine the two functions in _Approach 2_, `dfsCheckCycle` and `dfsMaxPath`, into one single function, `dfs`.\n\n> The new `dfs` should return `-1` if a cycle is detected, and return the longest length otherwise.\n\nJust simple modifications on `dfsCheckCycle` will do:\n\nRecall in `dfsCheckCycle`, each node has three states: unvisited, visiting, and visited.\n\nWe can change the **visited** state to the **longest length** starting from the current node, and let the dfs return the longest length starting from the current node.\n\nThe pseudo-code is as below:\n\n```python\nset states of all nodes to unvisited\n\ndef dfs(node):\n    if the state of node is visiting:\n        # detects cycles\n        return -1\n    else if the state of node is visited:\n        return the state of node # the longest length\n\n    set the state of node to visiting\n\n    max_length = -1\n    for child_node in child_nodes:\n        child_answer = dfs(child_node)\n        # if detects cycles in child_node\n        if child_answer == -1:\n            return -1\n        else:\n            max_length = max(max_length, child_answer)\n\n    set the state of node to max_length\n    return max_length\n```\n\n**Algorithm**\n\n_Step 1:_ Build a directed graph from `relations`.\n\n_Step 2:_ Implement a function `dfs` to check whether the graph has a cycle and calculate the length of the longest path in the graph.\n\n_Step 3:_ Call `dfs`; return `-1` if the graph has a cycle. Otherwise, return the length of the longest path in the graph.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/HBLPqXy4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"HBLPqXy4\"></iframe>\n\n**Complexity Analysis**\n\nLet $$E$$ be the length of `relations`.\n\n- Time Complexity: $$\\mathcal{O}(N+E)$$. For building the graph, we spend $$\\mathcal{O}(N)$$ to initialize the graph, and spend $$\\mathcal{O}(E)$$ to add egdes since we iterate `relations` once. For DFS, we spend $$\\mathcal{O}(N+E)$$ since we need to visit every node and edge once in DFS in the worst case.\n\n- Space Complexity: $$\\mathcal{O}(N+E)$$. For the graph, we spend $$\\mathcal{O}(N+E)$$ since we have $$\\mathcal{O}(N)$$ keys and $$\\mathcal{O}(E)$$ values. For DFS, we spend $$\\mathcal{O}(N)$$ since in the worst case, we need to add all nodes to the stack to recursively call DFS.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1065",
            "count": 48,
            "average": "5.000",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "parallel-courses",
    "playgroundData": {
        "atkA9rDS": {
            "playground": {
                "testcaseInput": "",
                "name": "parallel-courses-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "QAXAZZMo": {
            "playground": {
                "testcaseInput": "",
                "name": "parallel-courses-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "HBLPqXy4": {
            "playground": {
                "testcaseInput": "",
                "name": "parallel-courses-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}