{
    "id": "140",
    "question": {
        "questionId": "140",
        "questionFrontendId": "140",
        "boundTopicId": null,
        "title": "Word Break II",
        "titleSlug": "word-break-ii",
        "content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 5020,
        "dislikes": 481,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Word Break\", \"titleSlug\": \"word-break\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Concatenated Words\", \"titleSlug\": \"concatenated-words\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "\"catsanddog\"\n[\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\n\"pineapplepenapple\"\n[\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\n\"catsandog\"\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Trie",
                "slug": "trie",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Memoization",
                "slug": "memoization",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 3}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 19}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 16}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 12}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 9}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Walmart Global Tech\", \"slug\": \"walmart-labs\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Twitter\", \"slug\": \"twitter\", \"timesEncountered\": 0}, {\"taggedByAdmin\": true, \"name\": \"Dropbox\", \"slug\": \"dropbox\", \"timesEncountered\": 0}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** wordBreak(char * s, char ** wordDict, int wordDictSize, int* returnSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public IList<string> WordBreak(string s, IList<string> wordDict) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nvar wordBreak = function(s, wordDict) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String} s\n# @param {String[]} word_dict\n# @return {String[]}\ndef word_break(s, word_dict)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func wordBreak(s string, wordDict []string) []string {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def wordBreak(s: String, wordDict: List[String]): List[String] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn word_break(s: String, word_dict: Vec<String>) -> Vec<String> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[] $wordDict\n     * @return String[]\n     */\n    function wordBreak($s, $wordDict) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function wordBreak(s: string, wordDict: string[]): string[] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (word-break s wordDict)\n  (-> string? (listof string?) (listof string?))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec word_break(S :: unicode:unicode_binary(), WordDict :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nword_break(S, WordDict) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec word_break(s :: String.t, word_dict :: [String.t]) :: [String.t]\n  def word_break(s, word_dict) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"457.5K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 457480, \"totalSubmissionRaw\": 1063338, \"acRate\": \"43.0%\"}",
        "hints": [],
        "solution": {
            "id": "956",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "\"catsanddog\"\n[\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
        "metaData": "{\n  \"name\": \"wordBreak\",\n  \"params\": [\n    {\n      \"name\": \"s\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"wordDict\",\n      \"type\": \"list<string>\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"list<string>\",\n    \"dealloc\": true\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "956",
        "content": "[TOC]\n\n## Solution\n\n\n---\n#### Overview\n\nThe solutions for this problem go by many names, such as Dynamic Programming, recursion with memoization, DFS, and backtracking _etc._\nThey all capture certain traits of the solutions.\n\nIn essence, all these solutions can all be categorized as variants of **_Dynamic Programming_** (DP), as we will discuss in this article.\n\n>As a reminder, with DP, we break the original problem down to several sub-problems _recursively_ until the sub-problems are small enough to be solved directly.\nThen we combine the results of sub-problems to obtain the final solution for the original problem.\n\nAs one can see, the DP solutions are also the embodiment of the divide-and-conquer principle. \n\nTo come up a DP solution, the essential step is to **represent** the solution of the original problem with the results of its sub-problems.\nIn general, there are two approaches to implement a DP solution, namely **_Top-Down_** and **_Bottom-Up_**.\nWe would explain in detail how to apply these two approaches to this problem in the following sections. \n<br/>\n<br/>\n\n\n---\n#### Approach 1: Top-Down Dynamic Programming\n\n**Intuition**\n\nLet us start with the top-down approach, which is more efficient compared to bottom-up approach in this case.\n\nGiven an input string $$\\text{s} = \\text{`catsanddog'} $$, we define the results of breaking it into words with the function $$\\text{F(s)}$$.\n\nFor any word (denoted as $$\\text{w}$$) in the dictionary, if it matches with a prefix of the input string, we then can _divide_ the string into two parts: the word and the postfix, _i.e._ $$s = \\text{w} + \\text{postfix} $$.\n\nConsequently, the solution for the input string can be represented as follows:\n\n$$\n    \\forall \\text{w} \\in \\text{dict}, \\quad  s = \\text{w} + \\text{postfix} \\implies \\{ \\text{w} + \\text{F(postfix)} \\} \\subseteq \\text{F(s)} \n$$\n\n_i.e._ we add the matched word to the solutions from the postfix.\n\nFor example, the word `cat` matches with a prefix of the string. As a result, we can divide the string into $$s = \\text{`cat'} + \\text{`sanddog'}$$. \n\nFor the postfix of `sanddog`, we could obtain the results by recursively applying our function, _i.e._ $$\\text{F(`sanddog')} = \\{ \\text{`sand dog'} \\} $$.\nBy adding the prefix word to the solutions of the postfix, we then obtain one of the solutions for the original string, \n_i.e._ $$ \\text{`cat sand dog'} \\in \\text{F(s)}  $$.\n\n\n>The above approach can be considered as a **_top-down_** DP.\nThe reason lies in the part that we adopt the _laissez-faire_ strategy, _i.e._ we simply take a first step, while assuming the subsequent steps will figure out on their owns.\n\nIn our case, we first find a match to a prefix of the string, while assuming that we would eventually obtain the results for the corresponding postfix.\n\nIn the following graph, we illustrate how the top-down approach works with a concrete example, _i.e._ with the input string as `s=\"catsanddogo\"` and the word dictionary as `wordDict=[\"cat\", \"cats\", \"and\", \"sand\", \"dog\", \"do\", \"go\"]`.\n\n![DFS](../Figures/140/140_DFS.png)\n\nEach node in the graph represents a postfix of the input string.\nIn particular, we have some nodes with an empty string, which indicates the end of the input string.\nEach edge indicates the reduction from one postfix to another.\nThe label on top of each edge indicates the word that is used to trigger the reduction.\n\nAs one might notice, the above graph is a **tree** data structure.\nFrom **top** to **bottom**, we reduce the input string down to its postfixes recursively until the string becomes empty.\n\n>Each path that starts with the root node (input string) and ends with a leaf node of an empty string represents a sequence of words that the input string can be broke down into, as we highlighted in the graph.\n\n**Algorithm**\n\nFollowing the above intuition, it seems intuitive to implement the solution with recursion.\n\nWe define a recursive function called `_wordBreak_topdown(s)` which generates the results for the input string.\nHere are a few steps to implement our recursive function.\n\n- First of all, as the _**base case**_ of the recursion, when the input string is empty, the recursion would terminate. Note that we return a list of empty list as the result, rather than just an empty list.\n\n- As the main body of the function, we run an iteration over all the prefixes of the input string. If the corresponding prefix happens to match a word in the dictionary, we then invoke recursively the function on the postfix.\n\n- At the end of the iteration, we keep the results in the hashmap named `memo` with each valid postfix string as its key and the list of words that compose the prefix of as the value.\nFor instance, for the postfix `dogo`, its corresponding entry in the hashmap would be `memo[\"dogo\"] = [\"do\", \"go\"]`.\n\n- Finally, as the result, we return the entry of `memo` with the input string as the key. (The string itself is a postfix of the string itself.)\n\n<iframe src=\"https://leetcode.com/playground/4UqVvMtK/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4UqVvMtK\"></iframe>\n\n\n**Optimization**\n\nThe execution of the recursion would unfold as a tree as we shown before.\n\nAs one might notice, there are some duplicate nodes in the tree, _e.g._ the node with the postfix `dogo`, which is due to the fact that there are several ways to reduce the input string down to the same postfix.\n\nTherefore, it would be natural to reuse the results that we've calculated for certain postfix, rather than re-calculating them at each occasion. Together with recursion, this optimization technique is also called **_memoization_**.\n\nAnother essential characteristic about DP solutions is that we reuse the results of intermediate solutions.\nWithout this optimization, _i.e._ if we do not reuse the intermediate solutions, our top-down approach could not be fully qualified as the DP solution.\n\n![DP with memoization](../Figures/140/140_dp_memoization.png)\n\nOn the other hand, as revealed by the execution graph, we can consider our top-down approach as _backtracking_ or DFS (Depth-First Search) traversal over the tree / graph alike data structure.\nHere is how we formulate the approaches.\n\n- **Backtracking**: given an input string, we *explore* all the possibilities to break it down to words.\nAt certain step, if we cannot move forwards, we would _backtrack_ to the previous step and try another alternative.\n\n- **DFS traversal**: we can reformulate the problem as finding all the paths from the root to the leaf nodes in a tree consisting of postfixes.\nTherefore, by traversing the tree in the manner of DFS as we did, we could achieve the goal easily.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the input string and $$W$$ be the number of words in the dictionary.\n\n- Time Complexity: $$\\mathcal{O}(N ^ 2 + 2^N + W)$$ \n\n    - In the execution graph shown before, we might visit certain nodes multiple times, but we visit each edge once and only once.\n    Therefore, the time complexity of the algorithm is proportional to the number of **edges**, which depends on the construction of the input string and the word dictionary.\n\n    - In the worst case, there could be $$N$$ valid postfixes, _i.e._ each prefix of the input string is a valid word.\n    For example, it is one of the worst cases with the input string as `s=aaa` and the word dictionary as `wordDict=[\"a\", \"aa\", \"aaa\"]`.\n\n    ![worst case](../Figures/140/140_worst_case_example.png)\n\n    - For a postfix of length $$i$$, it could make at most $$i$$ invocation of the recursive function, _i.e._ a node with the prefix of length $$i$$ would have at most $$i$$ outgoing edges.\n    Since we have $$N$$ prefixes, in total, we could have $$\\sum_{i=1}^{N}{i} = \\frac{(1 + N)\\cdot N}{2}$$ edges in th execution graph.\n\n    - In addition, at each visit of the edge, we need to iterate through the number of solutions that bring back by the edge. In the above worst case, each postfix of length $$i$$ would have $$2^{i-1}$$ number of solutions, _i.e._ each edge brings back $$2^{i-1}$$ number of solution from the target postfix. Therefore, in total, we need $$\\mathcal{O}(\\sum_{i=1}^{N}{2^{i-1}}) = \\mathcal{O}(2^N)$$ iterations to construct the final solutions.\n\n    - At the beginning of the algorithm, we construct a set out of the dictionary, which takes $$\\mathcal{O}(W)$$ time.\n\n    - In total, the overall time complexity of the algorithm is $$\\mathcal{O}(N ^ 2 + 2^N + W)$$.\n\n\n- Space Complexity: $$\\mathcal{O}(2 ^ {N} \\cdot N + W)$$\n\n    - In the worst case, it could be possible to insert a break between every adjacent characters in the string.\n    Therefore, there could be $$2 ^ {N-1}$$ possible combinations to break the input string into words. Each combination would consist of $$N$$ characters from the input string.\n    As a result, in total we would need $$\\mathcal{O}(2 ^ {N-1} \\cdot N)$$ space to hold the values in the hashmap.\n    In addition, we would have $$N$$ entries for the keys, which could amount to $$\\mathcal{O}(N ^ 2)$$ space.\n\n    - We use a set to keep all the words from the dictionary, which we assume to be $$\\mathcal{O}(W)$$ space.\n\n    - It is worth mentioning that the recursion would incur additional space consumption on the function call stack.\n    But since they would not dominate the other space overhead, we can omit them here.\n\n    - In total, the overall space complexity of the algorithm is $$\\mathcal{O}(2 ^ {N-1} \\cdot N + N ^ 2 + W) = \\mathcal{O}(2 ^ {N} \\cdot N + W)$$.\n<br/>\n<br/>\n\n---\n#### Approach 2: Bottom-Up Dynamic Programming\n\n**Intuition**\n\n>As opposed to the top-down approach, the **_bottom-up_** dynamic programming _progressively_ builds up the solutions for the sub-problems upfront, rather than delaying them to the end.\n\nWe will demonstrate the difference between the two approaches with a concrete example later.\n\nFollowing the same definition in the top-down approach, given an input string $$\\text{s}$$, _e.g._ $$\\text{s} = \\text{`catsanddog'} $$, we define the results of breaking it into words with the function $$\\text{F(s)}$$.\n\nFor any word (denoted as $$\\text{w}$$) in the dictionary, if it matches with a postfix of the input string, we then can _divide_ the string into two parts: the prefix and the word, _i.e._ $$s = \\text{prefix} + \\text{w}$$.\n\nConsequently, the solution for the input string can be represented as follows:\n\n$$\n    \\forall \\text{w} \\in \\text{dict}, \\quad  s = \\text{prefix} + \\text{w} \\implies \\{ \\text{F(prefix)} + \\text{w} \\} \\subseteq \\text{F(s)} \n$$\n\n_i.e._ we add the matched word to the solutions from the prefix.\n\nWe start from an empty prefix (_i.e._ the bottom case), to progressively extend the solutions to a larger prefix.\nEventually, the extended prefix would grow to be the original string.\n\nIn the following graph, we demonstrate how the bottom-up approach works for the same example in the top-down approach,\n_i.e._ with the input string as `s=\"catsanddogo\"` and the word dictionary as `wordDict=[\"cat\", \"cats\", \"and\", \"sand\", \"dog\", \"do\", \"go\"]`.\n\n![DP table](../Figures/140/140_dp_value_table.png)\n\nAs one can see from the above graph, by appending words to the prefixes, we obtain the solutions for the larger strings.\nAt the end, we calculate the solutions for all possible prefixes, which includes the solutions for the original string, since the string itself is a prefix of the string.\n\n**Algorithm**\n\nTo implement the bottom-up DP approach, we often use an array to keep track of all the intermediate solutions.\nThe problem is no exception.\n\nWe define an array called `dp`.\nEach element in the array (`dp[i]`) would be used to hold the solutions for the corresponding prefix `s[0:i]`.\n\nFor example, for the prefix of `s[0:3] = \"cat\"`, the value for the element of `dp[3]` would be `[\"cat\"]`, as we indicated in the previous graph.\n\n>The goal of the algorithm boils down to calculating each element in the `dp` array.\nAnd the desired result would be the last element in the array, _i.e._ `dp[len(s)]`, which corresponds to the results for the entire string.\n\nHere are a few steps on how to calculate the values for the `dp` array:\n\n- First of all, we create an empty `dp` array to hold all the intermediate solutions.\n\n- We then iterate through all prefixes of the input string, from the bottom case (empty string) to the entire string.\n\n- For each prefix, we enumerate all possible combinations to see if we could reuse the solutions from the previous prefixes.\n\n<iframe src=\"https://leetcode.com/playground/mbusRNjc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mbusRNjc\"></iframe>\n\n**Note:** since this is not the most efficient algorithm, as we will see in the analysis later, we added an additional check at the beginning of the algorithm, to see if the input string contains some characters that do not appear in any of the words in the dictionary.\nIf this is the case, then we are sure that the input string cannot be broken down into words, which can save us from running the algorithm.\n\nWith this check, we could by pass some tricky test cases, not ending up with the TLE (Time Limit Exceeded) error.\n\nWe mentioned previously that we could consider the top-down DP approach as the DFS (Depth-First Traversal) over the structure of graph.\n\n>Similarly, we could consider the bottom-up DP approach as the BFS **_(Breadth-First Search)_** over the same graph structure, as shown in the following graph.\n\n![BFS with DP table](../Figures/140/140_BFS_with_table.png)\n\nRather than going in depth, the bottom-up DP approach explores the breadth first.\nIt is not the best strategy in the case, since not every branch would lead to a potential solution, yet with BFS we have to keep all the intermediate solutions regardless of whether they would lead to a final solution or not.\nWhile in DFS, no intermediate solution is kept until it leads to a final solution.\nThis is the main reason why DFS (top-down approach) is a much more efficient algorithm for this problem, compared to BFS (bottom-down approach).\n\n**Keep Breaks Not Words**\n\nOne of the drawbacks of the above bottom-up implementation is that we keep the intermediate solutions in the form of strings, _e.g._ `dp[7] = ['cat sand', 'cats and']`.\n\nIt is rather costly to do so. The rationale is twofold: 1). we have to keep many copies of string in the memory. 2). we have to iterate through the string to make a new copy, which is time-consuming.\n\nOne of the optimizations that we can do is that rather than keeping the words (strings), we simply keep the **positions** to insert the breaks into the original string.\nFor the same example of `dp[7]`, we can store the values as `dp[7] = [[3, 7], [4, 7]]`, which we could interpret as follows:\n\n- For the solution of `[3, 7]`, by inserting a break respectively at the indices of 3 and 7 in the original string, we could obtain a list of words, _i.e._ `\"cat sand\"`.\n\n- Similarly, the solution of `[4, 7]` corresponds to the list of words `\"cats and\"`.\n\nWith this optimization, we then can convert the previous dp array to the following:\n![BFS with breaks](../Figures/140/140_BFS_with_breaks.png)\nAs one can see, not only do we save the space to store the intermediate solutions, but also the time to calculate them.\n\n<iframe src=\"https://leetcode.com/playground/iKYiMxAT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"iKYiMxAT\"></iframe>\n\n\n**Recursive Encoding**\n\nAlthough we save quite some efforts by storing just the breaks rather than the words themselves, still we were **repeating** the solutions of small prefixes in the solutions for the larger prefixes.\n\n>To avoid this repetition, we could simply refer to the previous solutions with their indices in the dp array, rather than copying them.\n\nWith the above _recursive encoding_ schema, we could further reduce the dp array into the following:\n\n![BFS with recursive encoding](../Figures/140/140_BFS_recursive_encoding.png)\n\nAs shown in the above graph, each element in the encoding is a two-element tuple as `[previous_dp_index, word_end_index]`.\nFirst of all, the two indices define the scope of the word to be added.\nIn addition, the first index (_i.e._ `previous_dp_index`) indicates the previous dp entry that we should _recursively_ look into, in order to add the words that compose the prefix.\n\nWith this schema, we could further save some space and time to calculate the intermediate solutions.\n\nOne caveat though is that it is slightly more complex to decode the final solutions from the encoded results.\n\n<iframe src=\"https://leetcode.com/playground/iXCegxyT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"iXCegxyT\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the input string and $$W$$ be the number of words in the dictionary.\n\n- Time Complexity: $$\\mathcal{O}(N^2 + 2 ^ N + W)$$\n\n    - As we discussed before, in the worst case, it could be possible to insert a break between every adjacent characters in the input string, _i.e._ each prefix of length $$k$$ would have $$2 ^ {k-1}$$ number of solutions.\n\n    - While we iterate over all prefixes of the input string, starting from the empty prefix, the number of solutions for each prefix would double at each step.\n\n    - Assume that we adopt the most optimal recursive encoding for the solutions, we would need $$k$$ steps to build solutions for the prefix of length $$k$$. In total, we would need $$\\sum_{i=1}^{N}{i} = \\frac{(N+1) \\cdot N}{2}$$ steps to build all intermediate solutions.\n\n    - However, at the end, we need to reconstruct the solutions from the encoding.\n    In the worst case, we would have $$2 ^ {N-1}$$ number of solutions.\n    Thus it would take at least $$2 ^ {N-1}$$ steps to reconstruct the solutions.\n\n    - Similarly, it would take $$W$$ steps to build the word set from the dictionary.\n\n    - In total, the overall time complexity for the bottom-up DP approach with the recursive encoding is $$\\mathcal{O}(\\frac{(N+1) \\cdot N}{2} + 2 ^ {N-1} + W ) = \\mathcal{O}(N^2 + 2 ^ N + W)$$.\n\n\n- Space Complexity: $$\\mathcal{O}(2^N \\cdot N + N^2 + W)$$\n\n    - As stated above, in the worst case, each prefix of length $$k$$ would have $$2 ^ {k-1}$$ number of solutions.\n    Therefore, in total, we would have $$\\sum_{k=1}^{N}{2 ^ {k-1}} = 2^N$$\n    intermediate solutions.\n    If we keep the solutions as words or breaks, we would need $$N$$ space for each solution. Thus, it amounts to $$2^N \\cdot N$$ for the approaches that keep the intermediate solutions as words or breaks.\n\n    - On the other hand, if we use the recursive encoding, each prefix of length $$k$$ would only need $$k$$ entries at most to keep its solutions. With the encoding, we would only need $$\\sum_{k=1}^{N}{k} = \\frac{(1+N) \\cdot N}{2}$$ space to keep all intermediate solutions.\n\n    - As always, we would need an additional $$W$$ space to hold the words in the dictionary.\n\n    - In total, the space complexity of the algorithm is $$\\mathcal{O}(2^N \\cdot N + N^2 + W)$$, if we adopt the recursive encoding schema.\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "901",
            "count": 136,
            "average": "3.022",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "word-break-ii",
    "playgroundData": {
        "4UqVvMtK": {
            "playground": {
                "testcaseInput": "",
                "name": "word-break-ii-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "mbusRNjc": {
            "playground": {
                "testcaseInput": "",
                "name": "word-break-ii-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "iKYiMxAT": {
            "playground": {
                "testcaseInput": "",
                "name": "word-break-ii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "iXCegxyT": {
            "playground": {
                "testcaseInput": "",
                "name": "word-break-ii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}