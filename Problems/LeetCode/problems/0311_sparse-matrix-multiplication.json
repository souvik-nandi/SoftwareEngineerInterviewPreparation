{
    "id": "311",
    "question": {
        "questionId": "311",
        "questionFrontendId": "311",
        "boundTopicId": null,
        "title": "Sparse Matrix Multiplication",
        "titleSlug": "sparse-matrix-multiplication",
        "content": "<p>Given two <a href=\"https://en.wikipedia.org/wiki/Sparse_matrix\" target=\"_blank\">sparse matrices</a> <code>mat1</code> of size <code>m x k</code> and <code>mat2</code> of size <code>k x n</code>, return the result of <code>mat1 x mat2</code>. You may assume that multiplication is always possible.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/mult-grid.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]]\n<strong>Output:</strong> [[7,0,0],[-7,0,3]]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat1 = [[0]], mat2 = [[0]]\n<strong>Output:</strong> [[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat1.length</code></li>\n\t<li><code>k == mat1[i].length == mat2.length</code></li>\n\t<li><code>n == mat2[i].length</code></li>\n\t<li><code>1 &lt;= m, n, k &lt;= 100</code></li>\n\t<li><code>-100 &lt;= mat1[i][j], mat2[i][j] &lt;= 100</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 881,
        "dislikes": 307,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[[1,0,0],[-1,0,3]]\n[[7,0,0],[0,0,0],[0,0,1]]\n[[0]]\n[[0]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Wish\", \"slug\": \"wish\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Cruise Automation\", \"slug\": \"cruise-automation\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 9}, {\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Databricks\", \"slug\": \"databricks\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int[][] multiply(int[][] mat1, int[][] mat2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def multiply(self, mat1, mat2):\n        \"\"\"\n        :type mat1: List[List[int]]\n        :type mat2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** multiply(int** mat1, int mat1Size, int* mat1ColSize, int** mat2, int mat2Size, int* mat2ColSize, int* returnSize, int** returnColumnSizes){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int[][] Multiply(int[][] mat1, int[][] mat2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} mat1\n * @param {number[][]} mat2\n * @return {number[][]}\n */\nvar multiply = function(mat1, mat2) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} mat1\n# @param {Integer[][]} mat2\n# @return {Integer[][]}\ndef multiply(mat1, mat2)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func multiply(_ mat1: [[Int]], _ mat2: [[Int]]) -> [[Int]] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func multiply(mat1 [][]int, mat2 [][]int) [][]int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def multiply(mat1: Array[Array[Int]], mat2: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun multiply(mat1: Array<IntArray>, mat2: Array<IntArray>): Array<IntArray> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn multiply(mat1: Vec<Vec<i32>>, mat2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $mat1\n     * @param Integer[][] $mat2\n     * @return Integer[][]\n     */\n    function multiply($mat1, $mat2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function multiply(mat1: number[][], mat2: number[][]): number[][] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (multiply mat1 mat2)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec multiply(Mat1 :: [[integer()]], Mat2 :: [[integer()]]) -> [[integer()]].\nmultiply(Mat1, Mat2) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec multiply(mat1 :: [[integer]], mat2 :: [[integer]]) :: [[integer]]\n  def multiply(mat1, mat2) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"158K\", \"totalSubmission\": \"237.2K\", \"totalAcceptedRaw\": 158032, \"totalSubmissionRaw\": 237177, \"acRate\": \"66.6%\"}",
        "hints": [],
        "solution": {
            "id": "1309",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,0,0],[-1,0,3]]\n[[7,0,0],[0,0,0],[0,0,1]]",
        "metaData": "{\n  \"name\": \"multiply\",\n  \"params\": [\n    {\n      \"name\": \"mat1\",\n      \"type\": \"integer[][]\"\n    },\n    {\n      \"name\": \"mat2\",\n      \"type\": \"integer[][]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer[][]\",\n    \"rowsize\": \"size_1\",\n    \"colsize\": \"*col_size_2\",\n    \"dealloc\": true\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "863",
            "date": "2022-03-22",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1309",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nA matrix is a 2-dimensional array, and its size is denoted as `$$a \\times b$$`, where `$$a$$` and `$$b$$` are the numbers of rows and columns respectively.         \nWe have to multiply two matrices `$$A$$` and `$$B$$` of size `$$m \\times k$$` and `$$k \\times n$$` respectively. \n\n> **Matrix multiplication** is a binary operation whose output is another matrix when two matrices are multiplied. To multiply two matrices both **matrices must be compatible**, here compatibility means if we have two matrices `$$A$$` and `$$B$$`, then to calculate `$$A \\cdot B$$`, $$ \\text{the number of columns in A} $$ should be equal to $$ \\text{the number of rows in B} $$.  <br />\nAnd the resultant matrix will have a size equal to $$ \\text{(number of rows in A} \\times  \\text{number of columns in B)} $$.     \n\n**How to multiply?**       \nLet's define, matrices `$$A = [a_{ij}] $$` of size `$$m \\times k$$` and `$$B = [b_{ij}] $$` of size `$$k \\times n$$`.      \nThen, the product matrix `$$X = A \\cdot B$$` will be of size `$$m \\times n$$`.      \n`$$X = [x_{ij}]$$` where, `$$x_{ij} = a_{i1}b_{1j} + a_{i2}b_{2j} + ..... + a_{i(k-1)}b_{(k-1)j} + a_{ik}b_{kj} $$` `$$ = \\sum_{N=1}^{k} a_{iN}b_{Nj} $$`    \n\nEach element `$$x[i][j]$$` is the sum of product of elements of `$$i^{th}$$` row of matrix `$$A$$` and `$$j^{th}$$` column of matrix `$$B$$`.             \nThus, to multiply two matrices `$$A$$` and `$$B$$`, we multiply elements of each row of the matrix `$$A$$` with the respective element of each column of the matrix `$$B$$` and add them. \n\n<img src=\"../Figures/311/Slide1.PNG\" width=\"960\" alt=\"one cell multiply\">    <br />\n\nIf you are not familiar with matrix multiplication, this may seem unintuitive, but it is how matrix multiplication is done. We will not dive deep into the explanation of this method and will try to focus this article on implementation only.\n\n</br>\n\n---\n\n#### Approach 1: Naive Iteration\n\n**Intuition**\n\n> Given two matrices, `$$ mat1 = [a_{ij}] $$` of size `$$m \\times k$$` and `$$ mat2 = [b_{ij}] $$` of size `$$k \\times n$$`.       \n> `$$ans = mat1 \\cdot mat2$$`, a matrix of size `$$m \\times n$$`.         \n\nTo find each element `$$ans[i][j]$$` of matrix `$$ans$$`, we need to multiply `$$i^{th}$$` row elements of the matrix `$$mat1$$` with `$$j^{th}$$` column elements of the matrix `$$mat2$$` and add them.     \n\nA simple way to implement this will be using some for loops to iterate over all rows and columns of matrices and multiply them.       \n\nWe keep one pointer to point to each row of the matrix `$$mat1$$`, another pointer to point to each column of the matrix `$$mat2$$`, and a third pointer to point to each element in the row of the matrix `$$mat1$$` (there are the same number of elements ($$k$$) in one row of $$mat1$$ as there are in one column of $$mat2$$).\n\n```\nfor (row = 0 to n) {\n    for (col = 0 to m) {\n        for (elementPos = 0 to k) {\n            ans[row][col] += mat1[row][elementPos] * mat2[elementPos][col];\n        }\n    }\n}\n```\n\n!?!../Documents/311/slideshow1.json:960,540!?!\n\n<br />\n\nHere, we can implement one optimization. Let's say the `$$elementPos^{th}$$` element of `$$i^{th}$$` row is `$$0$$`. Then there is no need to iterate over all columns of the second matrix for this element because after multiplication, it is guaranteed that `$$0$$` will be added in the `$$ans$$` matrix.\n\n\nIf we first check whether this element of `$$mat1$$` is zero or not. Then we can save one iteration over `$$m$$` columns of `$$mat2$$`. Thus, when there are many zeros in `$$mat1$$`, this optimization will reduce the number of computations we need to do.\nTo accomplish this, we will iterate over `$$row$$` and `$$elementPos$$` in the outer for loops so that we can check if `$$mat1[row][elementPos]$$` equals zero before iterating over all columns of `$$mat2$$` \n\n```\nfor (row = 0 to n) {\n    for (elementPos = 0 to k) {\n        // If current element of mat1 is non-zero then iterate over 'm' columns of mat2.\n        if (mat1[row][elementPos] != 0)  {\n            for (col = 0 to m) {\n                ans[row][col] += mat1[row][elementPos] * mat2[elementPos][col];\n            }\n        }\n    }\n}\n```\n\n!?!../Documents/311/slideshow2.json:960,540!?!\n\n<br />\n\n**Algorithm**\n\n1. Initialize some variables:\n    - `$$m$$`, number of rows in `$$mat1$$`\n    - `$$k$$`, number of columns in `$$mat1$$`\n    - `$$n$$`, number of columns in `$$mat2$$`\n    - `$$ans$$`, matrix of size `$$m \\times n$$` to store multiplication result.\n\n2. Iterate over each row of the matrix `$$mat1$$`. \n\n3. For each element in the current row of matrix `$$mat1$$`, if the element is non-zero:\n    - Iterative over each column of `$$mat2$$` multiply the elements and add them in the `$$ans$$` matrix at their respective place.\n\n4. Return the `$$ans$$` matrix.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/G4eRrE3L/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"G4eRrE3L\"></iframe>\n\n\n**Complexity Analysis**\n\nLet `$$m$$` and `$$k$$` represent the number of rows and columns in `$$mat1$$`, respectively. Likewise, let `$$k$$` and `$$n$$` represent the number of rows and columns in `$$mat2$$`, respectively.\n\n\n* Time complexity: $$O(m \\cdot k \\cdot n)$$.\n\n  - We iterate over all `$$m \\cdot k$$` elements of the matrix `$$mat1$$`. \n  - For each element of matrix `$$mat1$$`, we iterate over all `$$n$$` columns of the matrix `$$mat2$$`. \n  - Thus, it leads to a time complexity of `$$m \\cdot k \\cdot n$$`.\n\n\n* Space complexity: $$O(1)$$.\n\n  We use a matrix `$$ans$$` of size `$$m \\times n$$` to output the multiplication result which is not included in auxiliary space.\n    \n<br/>\n\n---\n\n#### Approach 2: List of Lists\n\n**Intuition**\n\nIn the previous approach, we were checking for the non-zero elements in the matrix `$$mat1$$`, but what if the matrix `$$mat2$$` is sparse and `$$mat1$$` is dense?           \nWe could handle that condition by counting non-zero elements in both matrices and using some checks before multiplying. However, the purpose of this problem is more than just converting a mathematical formula to a code.       \n\nThe **interviewer's follow-up** could be, what if the matrix is too big to store in the memory, but there are only a few non-zero elements. Here, he wants to see how we handle huge space waste. He expects us to store the matrix efficiency and do multiplication using that.\n  \n> Naturally, some of you may wonder how we are passing `$$mat1$$` and `$$mat2$$` to the function if the matrices can't be stored in memory. For this approach, let's assume that we will read those matrices from an external source and then store them in an efficient way. But for convenience, right now, we will read them from function arguments because our main focus will be on **efficient storage**, not on how to read from a file. \n\nThus, we have to use some data structure to only store the non-zero elements of both matrices.     \n \nWe will create some buckets where each bucket denotes one `$$row$$` and that bucket contains an array of pairs of `$$(value, \\space column)$$`. Zero valued elements will be missing from our data structure. Since the matrices are sparse, we will only store a few elements in our data structure.\n\n<img src=\"../Figures/311/Slide31.PNG\" width=\"960\" alt=\"data str\">    <br />\n\nIn the slideshow, in the previous approach, we saw that any element with index `$$(row1, \\space col1)$$` of `$$mat1$$` is multiplied with all the elements of `$$col1^{th}$$` row of `$$mat2$$`. Thus, we can use this method to multiply only the non-zero elements of `$$mat1$$` with the non-zero elements of a particular row of `$$mat2$$`. \n\n!?!../Documents/311/slideshow3.json:960,540!?!\n\n<br />\n\n**Algorithm**\n\n1. Create a function `$$compressMatrix(matrix)$$`, which inputs `$$matrix$$` and returns `$$compressedMatrix$$` with only non-zero elements. To build `$$compressedMatrix$$` we iterate over each element of `$$matrix$$` and if the element is non-zero push the `$$(value, \\space col)$$` pair in the respective `$$row$$` of `$$compressedMatrix$$`. \n\n2. Initialize some variables:\n    - `$$m$$`, number of rows in `$$mat1$$`.\n    - `$$k$$`, number of columns in `$$mat1$$`.\n    - `$$n$$`, number of columns in `$$mat2$$`.\n    - `$$A$$` and `$$B$$`, data structure to store matrices `$$mat1$$` and `$$mat2$$` in compressed form.\n    - `$$ans$$`, matrix of size `$$m \\times n$$` to store multiplication result.\n\n3. For each row in `$$A$$`, iterate over all its elements. These represent the non-zero elements from `$$mat1$$`.\n    - For each element, we get `$$(value, \\space col)$$` pair and iterate over all the elements of `$$col^{th}$$` row in `$$B$$`. For each pair of elements, we add their product to the `$$ans$$` matrix.\n\n4. Return the `$$ans$$` matrix.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/SPg5TPqg/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"SPg5TPqg\"></iframe>\n\n\n**Complexity Analysis**\n\nLet `$$m$$` and `$$k$$` represent the number of rows and columns in `$$mat1$$`, respectively. Likewise, let `$$k$$` and `$$n$$` represent the number of rows and columns in `$$mat2$$`, respectively.\n\n\n* Time complexity: $$O(m \\cdot k \\cdot n)$$.\n\n  - We iterate over all non-zero elements of the matrix `$$mat1$$`. And for each non-zero element, we iterate over one row of the matrix `$$mat2$$`. \n  - In the worst-case, `$$mat1$$` can have `$$m \\cdot k$$` elements and `$$mat2$$` can have `$$n$$` elements in each row.\n  - Thus, it leads to the time complexity of `$$m \\cdot k \\cdot n$$`.\n\n\n* Space complexity: $$O(m \\cdot k + k \\cdot n)$$.\n\n  - We use a data structure (an array of arrays) to efficiently store elements of both matrices.         \n    In the worst-case, we will store all `$$m \\cdot k$$` elements of `$$mat1$$` and `$$k \\cdot n$$` elements of `$$mat2$$` in our data structures.\n  - We use a matrix `$$ans$$` of size `$$m \\times n$$` to output the multiplication result which is not included in auxiliary space.\n    \n<br/>\n\n---\n\n#### Approach 3: Yale Format\n\n**Intuition**\n\nAnother way to efficiently store a matrix is using [Yale format](https://en.wikipedia.org/wiki/Sparse_matrix#:~:text=matrix%20construction.%5B6%5D-,Compressed%20sparse%20row%20(CSR%2C%20CRS%20or%20Yale%20format),-%5Bedit%5D).                    \nYale format or **Compressed Sparse Row (CSR)** represents a matrix using $$3$$ (one dimensional) arrays: `$$values$$`, `$$rowIndex$$`, and `$$colIndex$$`.\n- `$$values$$` array contains all the non-zero elements of the matrix.\n- `$$colIndex$$` array contains the column index of all the non-zero elements in `$$values$$` array.\n- `$$rowIndex$$` array stores the start index of each row's elements in the `$$values$$` array.\n\nLength of `$$values$$` and `$$colIndex$$` arrays will be equal to the number of non-zero elements in the matrix.         \nLength of `$$rowIndex$$` array will be, $$\\text{number of rows + 1}$$, where `$$rowIndex[i]^{th}$$` to `$$rowIndex[i+1]^{th}$$` index (exclusive) will give us the index range where the `$$i^{th}$$` row elements of the matrix are stored in `$$values$$` and `$$colIndex$$` arrays.\n\nWe can better understand this with the following slideshow.\n\n!?!../Documents/311/slideshow4.json:960,540!?!\n\n<br />\n\nThus, we are compressing our matrix row-wise, and all of the necessary information for each row can be stored in these three arrays.          \nSo, for a `$$n \\times m$$` size matrix, memory used for storage will be `$$O(\\max(NZ, \\space n+1))$$` where `$$NZ$$` is the number of non-zero elements and for sparse matrices `$$NZ \\ll n \\cdot m$$`.\n\n\nSimilarly, we have **Compressed Sparse Column (CSC)** format, here we compress the matrix column-wise.\n- `$$values$$` array contains all the non-zero elements of the matrix.\n- `$$rowIndex$$` array contains the row index of all the non-zero elements in `$$values$$` array.\n- `$$colIndex$$` array stores the start index of each column's elements in the `$$values$$` array.\n\nNow while multiplying two matrices we know to find one element of the product matrix we multiply one row of `$$mat1$$` and one column of `$$mat2$$`.\n\n> `$$mat1 = [a_{ij}] $$` of size `$$m * k$$` and `$$mat2 = [b_{ij}] $$` of size `$$k * n$$`.          \n> `$$X = mat1 \\cdot mat2 = [x_{ij}]$$`         \n> where, `$$x_{ij} = a_{i1}b_{1j} + a_{i2}b_{2j} + ..... + a_{i(k-1)}b_{(k-1)j} + a_{ik}b_{kj} = \\sum_{N=1}^{k} a_{iN}b_{Nj} $$`    \n\nThus, we can compress matrices `$$mat1$$` using **CSR** and `$$mat2$$` using **CSC** format so that we can easily fetch any row from the compressed form of `$$mat1$$` and any column from the compressed form of `$$mat2$$`.       \n\nAnd, while multiplying one row of `$$mat1$$` with one column of `$$mat2$$`, we can only multiply and add any two elements if, $$ \\text{column index of mat1 element} $$ is equal to $$ \\text{row index of mat2 element} $$.      \n\nNow, what if these indices don't match?        \nThis can be a bit tricky to understand but we will approach this problem with a 2-pointer approach where two pointers point to both arrays and the smaller element pointer is incremented until both pointer's elements are equal. We can visualize how we find similar indices using this slideshow.    \n\n!?!../Documents/311/slideshow5.json:960,540!?!\n\n<br />\n\n**Algorithm**\n\n1. Create a class `SparseMatrix` which stores a matrix in Yale format:\n   - `$$cols, \\space rows $$`: variables to store dimensions of the original matrix.\n   - `$$values, \\space rowIndex, \\space colIndex$$`: three arrays as discussed previously and represent the compressed form of a sparse matrix.\n   - Compress the matrix into CSR or CSC format (as shown in the first slideshow in this approach) and store the compressed matrix in the `$$values$$`, `$$rowIndex$$`, and `$$colIndex$$` arrays.\n \n2. Initialize some variables:\n    - `$$A$$`, which is a `SparseMatrix` object that stores `$$mat1$$` in compressed sparse row format.\n    - `$$B$$`, which is a `SparseMatrix` object that stores `$$mat2$$` in compressed sparse column format.\n    - `$$ans$$`, which is a matrix of size `$$m \\times n$$` that stores the multiplication result.\n\n3. Iterate over each element `$$(row, \\space col)$$` of the matrix `$$ans$$`.\n    - Get current `$$row's$$` element's range from `$$A$$` and current `$$col's$$` element's range from `$$B$$`.\n    - Multiply and add all the same index elements from the `$$mat1's$$` row and `$$mat2's$$` column at the current position in `$$ans$$` using the 2-pointer approach as discussed above.\n\n4. Return the `$$ans$$` matrix.\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/S3DtHx3Y/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"S3DtHx3Y\"></iframe>\n\n\n**Complexity Analysis**\n\nLet `$$m$$` and `$$k$$` represent the number of rows and columns in `$$mat1$$`, respectively. Likewise, let `$$k$$` and `$$n$$` represent the number of rows and columns in `$$mat2$$`, respectively.\n\n* Time complexity: $$O(m \\cdot n \\cdot k)$$.\n\n  - We iterate over all `$$m \\cdot n$$` elements of `$$ans$$` matrix. \n  - For each element we iterate over `$$k$$` row elements in `$$mat1$$`, and `$$k$$` column elements in `$$mat2$$`. In the worst-case scenario, none of the elements in either matrix is zero.\n  - Thus, the time complexity is O($$m \\cdot n \\cdot k$$).\n\n\n* Space complexity: $$O(m \\cdot k + k \\cdot n)$$.\n\n  - We use a data structure to efficiently store the non-zero elements of both matrices.         \n    In the worst-case scenario we will store all `$$m \\cdot k$$` elements of `$$mat1$$` and all `$$k \\cdot n$$` elements of `$$mat2$$` in one dimensional arrays.\n  - We use a matrix `$$ans$$` of size `$$m \\times n$$` to output the multiplication result which is not included in auxiliary space.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1314",
            "count": 19,
            "average": "4.737",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "sparse-matrix-multiplication",
    "playgroundData": {
        "G4eRrE3L": {
            "playground": {
                "testcaseInput": "",
                "name": "sparse-matrix-multiplication-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "SPg5TPqg": {
            "playground": {
                "testcaseInput": "",
                "name": "sparse-matrix-multiplication-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "S3DtHx3Y": {
            "playground": {
                "testcaseInput": "",
                "name": "sparse-matrix-multiplication-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}