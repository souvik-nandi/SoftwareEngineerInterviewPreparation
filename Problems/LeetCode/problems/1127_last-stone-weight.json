{
    "id": "1127",
    "question": {
        "questionId": "1127",
        "questionFrontendId": "1046",
        "boundTopicId": null,
        "title": "Last Stone Weight",
        "titleSlug": "last-stone-weight",
        "content": "<p>You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>i<sup>th</sup></code> stone.</p>\n\n<p>We are playing a game with the stones. On each turn, we choose the <strong>heaviest two stones</strong> and smash them together. Suppose the heaviest two stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p>\n\n<ul>\n\t<li>If <code>x == y</code>, both stones are destroyed, and</li>\n\t<li>If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.</li>\n</ul>\n\n<p>At the end of the game, there is <strong>at most one</strong> stone left.</p>\n\n<p>Return <em>the weight of the last remaining stone</em>. If there are no stones left, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> stones = [2,7,4,1,8,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of the last stone.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> stones = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stones.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Easy",
        "likes": 3383,
        "dislikes": 68,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[2,7,4,1,8,1]\n[1]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Nvidia\", \"slug\": \"nvidia\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Visa\", \"slug\": \"visa\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Citrix\", \"slug\": \"citrix\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int lastStoneWeight(int[] stones) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def lastStoneWeight(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint lastStoneWeight(int* stones, int stonesSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int LastStoneWeight(int[] stones) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} stones\n * @return {number}\n */\nvar lastStoneWeight = function(stones) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} stones\n# @return {Integer}\ndef last_stone_weight(stones)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func lastStoneWeight(_ stones: [Int]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func lastStoneWeight(stones []int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def lastStoneWeight(stones: Array[Int]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun lastStoneWeight(stones: IntArray): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $stones\n     * @return Integer\n     */\n    function lastStoneWeight($stones) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function lastStoneWeight(stones: number[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (last-stone-weight stones)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec last_stone_weight(Stones :: [integer()]) -> integer().\nlast_stone_weight(Stones) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec last_stone_weight(stones :: [integer]) :: integer\n  def last_stone_weight(stones) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"306.5K\", \"totalSubmission\": \"475.2K\", \"totalAcceptedRaw\": 306467, \"totalSubmissionRaw\": 475154, \"acRate\": \"64.5%\"}",
        "hints": [
            "Simulate the process.  We can do it with a heap, or by sorting some list of stones every time we take a turn."
        ],
        "solution": {
            "id": "930",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[2,7,4,1,8,1]",
        "metaData": "{\r\n  \"name\": \"lastStoneWeight\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"stones\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "871",
            "date": "2022-04-07",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "930",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Approach 1: Array-Based Simulation\n\n**Intuition**\n\nConceptually, the simplest way we could solve this problem is to repeatedly search for the 2 largest stones in the array, delete them, and then if they are not the same size, add the new stone size back in. We can repeat this process until there is only one stone left.\n\n**Algorithm**\n\nBecause the array is not sorted, there is no need to preserve the original order. Removals should be done by swapping with the last value, not by shuffling all values along.\n\n<iframe src=\"https://leetcode.com/playground/NDbPRc5g/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"NDbPRc5g\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the **length of stones**. Here on LeetCode, we're only testing your code with cases where $$N \u2264 30$$. In an interview though, be very careful about such assumptions. It is very likely your interviewer expects you to come up with the best possible algorithm you could (thus handling the highest possible value of $$N$$ you can).\n\n- Time complexity : $$O(N^2)$$.\n\n    The only non-$$O(1)$$ method of `StoneArray` is `findAndRemoveMax()`. This method does a single pass over the array, to find the index of the maximum value. This pass has a cost of $$O(N)$$. Once we find the maximum value, we delete it, although this only has a cost of $$O(1)$$ because instead of shuffling along, we're simply swapping with the end. \n\n    Each time around the main loop, there is a net loss of either 1 or 2 stones. Starting with $$N$$ stones and needing to get to $$1$$ stone, this is up to $$N - 1$$ iterations. On each of these iterations, it finds the maximum twice. In total, we get $$O(N^2)$$.\n\n    Note that even if we'd shuffled instead of swapped with the end, the `findAndRemoveMax()` method still would have been $$O(N)$$, as the pass and then deletion are done one-after-the-other. However, it's often best to avoid needlessly large constants.\n\n- Space complexity : $$O(N)$$ or $$O(1)$$.\n\n    For the Python: We are not allocating any new space for data structures, and instead are modifying the input list. Note that this *modifies the input*. This has its pros and cons; it saves space, but it means that other functions can't use the same array.\n\n    For the Java: We need to convert the input to an ArrayList, and therefore the `int`s to `Integer`s. It is possible to write a $$O(1)$$ space solution for Java, however it is long-winded and a lot of work for what is a poor overall approach anyway.\n\n<br/>\n\n---\n\n#### Approach 2: Sorted Array-Based Simulation\n\n**Intuition**\n\n*Note: This approach is no better than Approach 1. We're only including so that we can look at *why* it doesn't work as well as one might initially assume. See Approach 3 for the optimal approach.*\n\nTo simplify the search-for-maximum process, we could instead maintain a sorted array. We'd need to sort the array at the start, and then ensure that each time we need to add a stone back, that we're maintaining the sorted order.\n\nUnfortunately, inserting a stone into a *sorted* array is an $$O(N)$$ operation. While we can use binary search to determine where we should put it, inserting it still ultimately requires shifting all of the stones after it down by one place. This makes the approach no better than the previous one from a complexity point-of-view (in fact, it's actually worse because the space complexity is now unlikely to be $$O(1)$$).\n\n**Algorithm**\n\n<iframe src=\"https://leetcode.com/playground/Y6MfiCQt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Y6MfiCQt\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the **length of stones**.\n\n- Time complexity : $$O(N^2)$$.\n\n    The first part of the algorithm is sorting the list. This has a cost of $$O(N \\, \\log \\, N)$$.\n\n    Like before, we're repeating the main loop up to $$N - 1$$ times. And again, we're doing an $$O(N)$$ operation each time; adding the new stone back into the array, maintaining sorted order by shuffling existing stones along to make space for it. Identifying the two largest stones was $$O(1)$$ in this approach, but unfortunately this was subsumed by the inefficient adds. This gives us a total of $$O(N^2)$$.\n\n    Because $$O(N^2)$$ is strictly larger than $$O(N \\, \\log \\, N)$$, we're left with a final time complexity of $$O(N^2)$$.\n\n- Space complexity : Varies from $$O(N)$$ to $$O(1)$$.\n\n    Like in Approach 1, we can choose whether or not to modify the input list. If we do modify the input list, this will cost anywhere from $$O(N)$$ to $$O(1)$$ space, depending on the sorting algorithm used. However, if we don't, it will always cost at least $$O(N)$$ to make a copy. Modifying the input has its pros and cons; it saves space, but it means that other functions can't use the same array.\n\nAn alternative to this approach is to simply sort inside the loop every time. This will be even worse, with a time complexity of $$O(N^2 \\, \\log \\, N)$$.\n\n<br/>\n\n---\n\n#### Approach 3: Heap-Based Simulation\n\n**Intuition**\n\nApproach 1 found and removed the maximum stones in $$O(N)$$ time, and added the new stone in $$O(1)$$ time. Approach 2 inverted this, as finding and removing the maximum stones took $$O(1)$$ time, but adding the new stone took $$O(N)$$ time. In both cases, we're left with an overall time complexity of $$O(N)$$ per stone-smash turn.\n\nWe want to find a solution that makes both removing the maximums, and adding a new stone, *less than* $$O(N)$$.\n\nFor this kind of maximum-maintenance, we use a **Max-Heap**, also known as a **Max-Priority Queue**. A Max-Heap is a data structure that can take items, and can remove and return the maximum, with both operations taking $$O(\\log \\, N)$$ time. It does this by maintaining the items in a special order (within the array), or as a balanced binary tree. We don't need to know these details though, almost all programming languages have a Heap data structure!\n\nHere is the pseudocode using a Heap.\n\n```text\ndefine function last_stone_weight(stones):\n    heap = a new Max-Heap\n    add all stones to heap\n    while heap contains more than 1 stone:\n        heavy_stone_1 = remove max from heap\n        heavy_stone_2 = remove max from heap\n        if heavy_stone_1 is heavier than heavy_stone_2:\n            new_stone = heavy_stone_1 - heavy_stone_2\n            add new_stone to heap\n    if heap is empty:\n        return 0\n    return last stone on heap\n```\n\n**Algorithm**\n\nWhile most programming languages have a **Heap/ Priority Queue** data structure, some, such as Python and Java, only have **Min-Heap**. Just as the name suggests, this is a Heap that instead of always returning the maximum item, it returns the minimum. There are two solutions to this problem:\n\n1. Multiply all numbers going into the heap by `-1`, and then multiply them by `-1` to restore them when they come out.\n2. Pass a comparator in (language-dependent).\n\nIn Python, we'll use the first solution, and in Java we'll use the second.\n\n<iframe src=\"https://leetcode.com/playground/HmX4vu3j/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"HmX4vu3j\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the **length of stones**.\n\n- Time complexity : $$O(N \\, \\log \\, N)$$.\n\n    Converting an array into a Heap takes $$O(N)$$ time (it isn't actually sorting; it's putting them into an order that allows us to get the maximums, each in $$O(\\log \\, N)$$ time).\n\n    Like before, the main loop iterates up to $$N - 1$$ times. This time however, it's doing up to three $$O(\\log \\, N)$$ operation each time; two removes, and an optional add. Like always, the three is an ignored constant. This means that we're doing $$N \\cdot O(\\log \\, N) = O(N \\, \\log \\, N)$$ operations.\n\n- Space complexity : $$O(N)$$ or $$O(\\log \\, N)$$.\n\n    In Python, converting a list to a heap is done in-place, requiring $$O(1)$$ auxillary space, giving a total space complexity of $$O(1)$$. Modifying the input has its pros and cons; it saves space, but it means that other functions can't use the same array.\n\n    In Java though, it's $$O(N)$$ to create the `PriorityQueue`.\n\n    We could reduce the space complexity to $$O(1)$$ by implementing our own iterative heapfiy, if needed.\n\n<br/>\n\n---\n\n#### Approach 4: Bucket Sort\n\n**Intuition**\n\n*This approach is only viable when the maximum stone weight is small, or is at least smaller than the number of stones.*\n\nLet $$W$$ be the maximum stone weight in the input array. We can create a bucket array of size $$W + 1$$, where each index of the bucket array represents a stone weight. Then, we can bucket \"sort\" the stones in $$O(N)$$ time by iterating over them and incrementing the relevant bucket array index by 1. \n\n![The buckets for the input array.](../Figures/1046/buckets.png)\n\nWe can then process the buckets as shown in the following animation.\n\n!?!../Documents/1046_bucket_approach.json:960,250!?!\n\n**Algorithm**\n\n<iframe src=\"https://leetcode.com/playground/XrkMtyCr/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XrkMtyCr\"></iframe>\n\n**Complexity Analysis**\n\n- Time complexity : $$O(N + W)$$.\n\n    Putting the $$N$$ stones of the input array into the bucket array is $$O(N)$$, because inserting each stone is an $$O(1)$$ operation.\n\n    In the worst case, the main loop iterates through all of the $$W$$ indexes of the bucket array. Processing each bucket is an $$O(1)$$ operation. This, therefore, is $$O(W)$$.\n\n    Seeing as we don't know which is larger out of $$N$$ and $$W$$, we get a total of $$O(N + W)$$.\n\n    Technically, this algorithm is *pseudo-polynomial*, as its time complexity is dependent on the *numeric value of the input*. Pseudo-polynomial algorithms are useful when there is no \"true\" polynomial alternative, but in situations such as this one where we have an $$O(N \\, \\log \\, N)$$ alternative (Approach 3), they are only useful for very specific inputs.\n\n    With the small values of $$W$$ that your code is tested against for this question here on LeetCode, this approach turns out to be faster than Approach 3. But that does *not* make it the better approach.\n\n- Space complexity : $$O(W)$$.\n    \n    We allocated a new array of size $$W$$.\n\nWhen I looked through the discussion forum for this question, I was surprised to see a number of people arguing that this approach is $$O(N)$$, on the basis that we could say $$W$$ is a constant, due to the problem description stating it has a maximum value of $$1000$$. The trouble with this argument is that $$N$$ also has a maximum specified (of $$30$$, in fact), and so it is arbitrary to argue that $$W$$ is a constant, yet $$N$$ is not. These constraints on LeetCode problems are intended to help you determine whether or not your algorithm will be fast enough. They are not supposed to imply some variables can be treated as \"constants\". A correct time/ space complexity should treat them as *unbounded*.\n\n<br/>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "875",
            "count": 47,
            "average": "4.766",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "last-stone-weight",
    "playgroundData": {
        "NDbPRc5g": {
            "playground": {
                "testcaseInput": "",
                "name": "last-stone-weight-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "Y6MfiCQt": {
            "playground": {
                "testcaseInput": "",
                "name": "last-stone-weight-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "HmX4vu3j": {
            "playground": {
                "testcaseInput": "",
                "name": "last-stone-weight-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "XrkMtyCr": {
            "playground": {
                "testcaseInput": "",
                "name": "last-stone-weight-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}