{
    "id": "336",
    "question": {
        "questionId": "336",
        "questionFrontendId": "336",
        "boundTopicId": null,
        "title": "Palindrome Pairs",
        "titleSlug": "palindrome-pairs",
        "content": "<p>Given a list of <b>unique</b> words, return all the pairs of the&nbsp;<b><i>distinct</i></b> indices <code>(i, j)</code> in the given list, so that the concatenation of the two words&nbsp;<code>words[i] + words[j]</code> is a palindrome.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]\n<strong>Output:</strong> [[0,1],[1,0],[3,2],[2,4]]\n<strong>Explanation:</strong> The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n<strong>Explanation:</strong> The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= words[i].length &lt;= 300</code></li>\n\t<li><code>words[i]</code> consists of lower-case English letters.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 2773,
        "dislikes": 267,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Longest Palindromic Substring\", \"titleSlug\": \"longest-palindromic-substring\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Palindrome by Concatenating Two Letter Words\", \"titleSlug\": \"longest-palindrome-by-concatenating-two-letter-words\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n[\"bat\",\"tab\",\"cat\"]\n[\"a\",\"\"]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Trie",
                "slug": "trie",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Square\", \"slug\": \"square\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Nutanix\", \"slug\": \"nutanix\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Wix\", \"slug\": \"wix\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": true, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 16}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Shopee\", \"slug\": \"shopee\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> PalindromePairs(string[] words) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string[]} words\n * @return {number[][]}\n */\nvar palindromePairs = function(words) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String[]} words\n# @return {Integer[][]}\ndef palindrome_pairs(words)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func palindromePairs(_ words: [String]) -> [[Int]] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func palindromePairs(words []string) [][]int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def palindromePairs(words: Array[String]): List[List[Int]] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun palindromePairs(words: Array<String>): List<List<Int>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn palindrome_pairs(words: Vec<String>) -> Vec<Vec<i32>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return Integer[][]\n     */\n    function palindromePairs($words) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function palindromePairs(words: string[]): number[][] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (palindrome-pairs words)\n  (-> (listof string?) (listof (listof exact-integer?)))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec palindrome_pairs(Words :: [unicode:unicode_binary()]) -> [[integer()]].\npalindrome_pairs(Words) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec palindrome_pairs(words :: [String.t]) :: [[integer]]\n  def palindrome_pairs(words) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"150.8K\", \"totalSubmission\": \"425.4K\", \"totalAcceptedRaw\": 150792, \"totalSubmissionRaw\": 425369, \"acRate\": \"35.4%\"}",
        "hints": [],
        "solution": {
            "id": "851",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
        "metaData": "{\n  \"name\": \"palindromePairs\",\n  \"params\": [\n    {\n      \"name\": \"words\",\n      \"type\": \"string[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"list<list<integer>>\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "851",
        "content": "[TOC]\n\n## Solution\n\n*Here's a few words of advice before we get started.*\n\nThis is a very popular interview question. A concern I've seen brought up on the forums is that this question is too big to do in an interview.\n\nKeep in mind though, that you're being compared to other candidates. They too will struggle with this, unless they've seen it before and memorized it. This however will be obvious to an experienced interviewer. It is the candidate who has clearly never seen it before yet makes great progress (probably not writing a *complete* implementation) who will be considered the most impressive. The secret would be to prioritize your time so that you are focusing on the core of the problem and not implementations of straightforward helper methods.\n\nFor this question, great progress would probably be deriving the intuition discussed in approach 2 and then writing code for the *core* algorithm of Approach 2 or Approach 3.\n\nRemember that you don't necessarily have to \"implement\" every helper method. For example, some implementations rely on checking if a part of a string is a palindrome. This detail is easy-level by Leetcode standards, and in particular if you're using a whiteboard, it's a waste of time and space to write it unless you have finished the core algorithm. Simply state how you'd do it and leave it as a method signature unless asked to do otherwise. Also (for Approach 3), keep the TrieNode class simple. Don't waste half the whiteboard writing getters and setters for it.\n\n---\n\n#### Approach 1: Brute force\n\n**Intuition**\n\nThe brute force solution is a good place to start. For this question, it is straightforward. Iterate over every possible pair of strings and check whether or not they form a palindrome.\n\nYou probably won't be writing this code, there simply won't be time. But make sure you know what it would be, and that you could describe the algorithm line-by-line if needed.\n\n**Algorithm**\n\nWe can do this using 2 nested loops, each loop going over each index in the array. For each pair we need to check whether or not it forms a palindrome. There are many ways of doing this step, here I recommend the simplest way: creating the combined word and the reversed combined word and checking if they're equal. Doing the check in a more efficient way at this stage is not worth it \u2014 we want to focus our efforts on optimizing the main inefficiencies in this algorithm, which are discussed further in the complexity analysis section.\n\n**An important edge case to be careful of** is where `i = j`. The problem states that `i` and `j` must be distinct (in other words, not the same). Identifying this edge case now is important, because we'll also need to be careful of it when we are optimizing our algorithm.\n\n<iframe src=\"https://leetcode.com/playground/UvDYGDCu/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"UvDYGDCu\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the number of words, and $$k$$ be the length of the longest word.\n\n- Time Complexity : $$O(n^2 \\cdot k)$$.\n\n    There are $$n^2$$ pairs of words. Then appending 2 words requires time $$2k$$, as does reversing it and then comparing it for equality. The constants are dropped, leaving $$k$$. So in total, we get $$O(n^2 \\cdot k)$$. We can't do better than this with the brute-force approach.\n\n- Auxiliary Space Complexity : $$O(n^2 + k)$$.\n\n    Auxiliary space is where we do *not* consider the size of the input.\n\n    Let's start by working out the size of the output. In the worst case, there'll be $$n \\cdot (n - 1)$$ pairs of integers in the output list, as each of the $$n$$ words could pair with any of the other $$n - 1$$ words. Each pair will add 2 integers to the input list, giving a total of $$2 \\cdot n \\cdot (n - 1) = 2 \\cdot n ^ 2 - 2 \\cdot n$$. Dropping the constant and insignificant terms, we are left with an output size of $$O(n^2)$$.\n\n    Now, how much space do we use to find all the pairs? Each time around the loop, we are combining 2 words and creating an additional (reversed) copy of the combined words. This is $$4 \\cdot k$$, which gives us $$O(k)$$. We ***don't*** need to multiply this by $$n^2$$ because we aren't keeping the combined/ reversed words.\n\n    In total, this gives us $$O(n^2 + k)$$. It might initially seem like the $$k$$ should be dropped, as it's less significant than the $$n^2$$. This isn't *always* the case though. If the words were really long, and the list very short, then it's possible for $$k$$ to be bigger than $$n^2$$.\n\n    It's possible to optimize this slightly to $$O(n^2)$$. By using an in-place algorithm to determine whether or not 2 given words form a palindrome, the $$k$$ would become a $$1$$ and therefore be dropped. Like I said above though, it'd be wasted effort to do so. Especially given that in practice it's likely that $$k$$ is smaller than $$n^2$$ anyway.\n\n- Space Complexity : $$O(n \\cdot k + n ^ 2)$$.\n\n    For this, we also need to take into account the size of the input. There are $$n$$ words, with a length of up to $$k$$ each. This gives us $$O(n \\cdot k)$$.\n\n    Like above, we can't assume anything about whether $$k > n $$ or $$k < n$$. Therefore, we don't know whether $$O(n ^ 2 + k)$$ or $$O(n \\cdot k)$$ is bigger.\n\n<br />\n\n---\n\n#### Approach 2: Hashing\n\n**Intuition**\n\nTesting every pair is too expensive. Is there a way we can avoid checking pairs that will definitely not form a palindrome? Inorder to answer this question, we'll need to explore the properties of pairs that *do* form a palindrome.\n\nThis type of exploration and reasoning can be a bit challenging if you're not used to it, so we'll tackle it with some examples and then we'll try and prove our discoveries more formally. After that, we'll take a look at how it could be implemented efficiently in code.\n\n*What are the ways we could form a palindrome with 2 words?*\n\nThe simplest way to make a palindrome is to take 2 words that are the reverse of each other and put them together. In this case, we get 2 different palindromes, as we can put either word first.\n\n![A diagram showing that if word 1 is the reverse of word 2, we can make 2 different palindromes.](../Figures/336/case_1.png)\n\nWe know that there are always 2 unique palindromes that can be formed by 2 words that are the reverse of each other, because the words *must be different*. The problem statement is clear that there are no duplicates in the word list.\n\nLet's now think about all the words that could pair with a word 1 of `\"CAT\"` to make a palindrome. We'll assume that all the possibilities for word 2 we're looking at are 8 letters long. While this assumption might seem too specific, remember that we're just using it as a starting point to identify possible cases. We'll do a more general proof later.\n\n![A diagram setting up the problem of considering possibilities for word 2 to pair with a word 1 of cat](../Figures/336/walkthrough_1.png)\n\nTo start with, we know that the last letter of word 2 has to be `\"C\"`. Otherwise, it would be impossible to form a palindrome.\n\n![A diagram showing that word 2 must end in C because word 1 starts with C.](../Figures/336/walkthrough_2.png)\n\nBy that same logic, we also know the 2nd to last and 3rd to last characters must be `\"A\"` and `\"T\"` respectively.\n\n![A diagram showing that word 2 must end in \"TAC\"](../Figures/336/walkthrough_3.png)\n\nHere's where things start to get a bit interesting. We know that the 2 letters highlighted in the next diagram must be the same for the combined word to be a palindrome. We'll use numbers to show where letters must be the same.\n\n![A diagram showing that the first and fifth letters of word 2 must be the same.](../Figures/336/walkthrough_4.png)\n\nThe same argument applies for the next pair of highlighted letters.\n\n![A diagram showing that the second and fourth letters of word 2 must be the same.](../Figures/336/walkthrough_5.png)\n\nAnd that last letter in the center can be anything.\n\n![A diagram showing that the middle letter can be anything.](../Figures/336/walkthrough_6.png)\n\nLet's now take a step back and see what we have. Our experimenting has shown us that if word 2 is the concatenation of a 5-letter palindrome and then the reverse of word 1, that the combined pair of word 1 and word 2 is a palindrome.\n\n![A diagram showing that word 2 is a palindrome and then the reverse of word 1](../Figures/336/walkthrough_7.png)\n\nAnother case can also be seen here. If instead word 1 was the concatenation of the reverse of word 2 and then a 5-letter palindrome, the combined pair of word 1 and word 2 would also be a palindrome.\n\n![A diagram showing that word 1 is the reverse of word 2, and then a palindrome.](../Figures/336/walkthrough_8.png)\n\nWe have now identified 3 cases.\n\n![A diagram showing examples of the 3 non-trivial cases](../Figures/336/cases.png)\n\nDon't forget that the *empty string* is also a valid word. How could we form a palindrome with it? This is an important edge case we'll now think about.\n\nAppending an empty string with another word will simply give *the non-empty string* word. If this word was a palindrome by itself, we will have a valid palindrome pair. If it wasn't, we won't. So any words that by themselves are a palindrome will form a palindrome pair with the empty string.\n\nDepending on the implementation you use, you might not need to treat this as a special case, as it is really just a sub case of **case 2** and **case 3**. It's just that the bit that is reversed is of length-0. Make sure to test your implementation on this case though!\n\n*How can we prove that we have identified all the cases?*\n\nBy experimenting, we've discovered a few cases. But for these kinds of questions, it's very important to convince ourselves that we haven't overlooked any cases. One way we can do this is by considering the relative length of each pair of words. There are 2 cases for the relative lengths within each pair.\n\n1. The words are both of the same length.\n2. The words are of different lengths.\n\nWe then need to show how each of these 2 cases fully map onto the palindrome pair cases we've already discovered. We'll do this by considering where the middle of the combined word (word we get by appending the second word to the first word) is.\n\nFor the first possibility, the center of the combined word is *between the two words*.\n\n![A diagram showing where the center of the combined word 1 and word 2 is.](../Figures/336/proof1.png)\n\nFor the pair to form a palindrome, the letters before the center must be the *reverse* of the letters after the center. The following diagram uses numbers to show where 2 letters must be the same.\n\n![A diagram showing where the letters must be the same.](../Figures/336/proof2.png)\n\nWe can also see that this means word 1 must be the reverse of word 2.\n\n![A diagram showing where the letters must be the same.](../Figures/336/proof3.png)\n\nTherefore, when 2 words of the *same length* form a palindrome, it must be because word 1 is the reverse of word 2 (which also means word 2 is the reverse of word 1). This is equivalent to palindrome pair **case 1**.\n\nFor the second relative word-length case, we know that *one of the words must be shorter than the other*. We'll assume for now that *word 1 is shorter*. The exact same argument will make will also apply for when word 2 is shorter.\n\nLike before, there must be a middle of the combined word. We know that because word 1 is shorter, word 2 will overlap this center point.\n\n![A diagram showing the combined center when word 1 is shorter than word 2.](../Figures/336/proof4.png)\n\nWe know that a palindrome must mirror around that center point. Therefore, we know that the end of word 2 must be the reverse of word 1.\n\n![A diagram showing that the end of word 2 must be the reverse of word 1.](../Figures/336/proof5.png)\n\nWe are now left with the region *between* word 1 and the reverse of word 1. We know that this middle region is divided equally in 2 by the middle line because we took the same number of characters off each end of the combined word. Therefore, for the overall combined word to be a palindrome, the piece in the middle must be a palindrome.\n\n![A diagram showing that the center must be a palindrome](../Figures/336/proof6.png)\n\nWhich is equivalent to palindrome-pair **case 2**.\n\nUsing this same line of reasoning, you can easily show that when word 2 is shorter, it is equivalent to palindrome pair **case 3**.\n\nTherefore, we have proven that the only possible ways of forming a palindrome pair out of 2 words are covered by the 3 palindrome-pair cases we discovered during our exploration.\n\n*How can we put all this into code?*\n\nThe simplest way to put all of this into code is to iterate over the list of words and do the following for each **word**.\n\nIf these initial explanations are confusing, don't panic. There's further examples just below the list.\n\n1. Check if the reverse of **word** is present. If it is, then we have a **case 1** pair by appending the reverse onto the end of **word**.\n2. For each **suffix** of **word**, check if the **suffix** is a palindrome. **if it is a palindrome**, then reverse the remaining **prefix** and check if it's in the list. If it is, then this is an example of **case 2**.\n3. For each **prefix** of **word**, check if the **prefix** is a palindrome. **if it is a palindrome**, then reverse the remaining **suffix** and check if it's in the list. If it is, then this is an example of **case 3**.\n\nFor example, imagine we have the word `\"banana\"`. Start by checking whether or not `\"ananab\"` is in the list.\n\nNow identify all palindrome suffixes of `\"banana\"`. For each one, we take the remaining prefix, reverse it, and check if we have that word in the list.\n\n![A diagram showing words we need to look up for each palindrome suffix of \"banana\".](../Figures/336/banana_suffixes.png)\n\nDo the same for all palindrome prefixes of `\"banana\"`. There is only one of these.\n\n![A diagram showing words we need to look up for each palindrome prefix of \"banana\".](../Figures/336/banana_prefixes.png)\n\nIf we do this for each word, we will get all palindrome pairs exactly once. The most challenging idea here is that we are treating our current word as *word 2* for case 2. The reason we do this is because treating it as *word 1* would mean we had to guess possible prefixes for *word 2*, which would be very, very inefficient.\n\nTo ensure the implementation is efficient, we can put all the words into a hash table with the word as the key and the original index as the value (as the output must be the original indexes of the words).\n\n**Algorithm**\n\nWe'll call a *suffix* a \"valid suffix\" of a word if the remainder (prefix) of the word forms a palindrome. The function `allValidSuffixes` finds all such suffixes. For example, the \"valid suffixes\" of the word `\"exempt\"` are `\"xempt\"` (remove `\"e\"`) and `\"mpt\"` (remove `'exe'`).\n\nWe'll call a *prefix* a \"valid prefix\" of a word if the remainder (suffix) of the word forms a palindrome. The function `allValidPrefixes` finds all such prefixes in a similar way to how the `allValidSuffixes` function does. It is possible to combine more of the code for these functions here, but after going back and forth on the issue, I decided against it for this explanation because while it decreases the length of the code and some repetition, the cognitive load to understand it is higher. In your own code, it would be fine to combine it.\n\nExamples of case 1 can be found by reversing the current word and looking it up. One edge case to be careful of is that if a word is a palindrome by itself, then we don't want to add a pair that includes that same word twice. This case only comes up in case 1, because case 1 is the only case that deals with pairs where the words are of equal length.\n\nExamples of case 2 can be found by calling `allValidSuffixes` and then reversing each of the suffixes found and looking them up.\n\nExamples of case 3 can be found by calling `allValidPrefixes` and then reversing each of the prefixes found and looking them up.\n\nIt would be possible to simplify further (not done here) by recognizing that **case 1** is really just a special case of **case 2** and **case 3**. This is because the empty string is a palindrome prefix/ suffix of any word.\n\n<iframe src=\"https://leetcode.com/playground/LEGL9QqR/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"LEGL9QqR\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the number of words, and $$k$$ be the length of the longest word.\n\n- Time Complexity : $$O(k^2 \\cdot n)$$.\n\n    Building the hash table takes $$O(n \\cdot k)$$ time. Each word takes $$O(k)$$ time to insert and there are $$n$$ words.\n\n    Then, for each of the $$n$$ words we are searching for 3 different cases. First is the word's own reverse. This takes $$O(k)$$ time. Second is words that are a palindrome followed by the reverse of another word. Third is words that are the reverse of another word followed by a palindrome. These second 2 cases have the same cost, so we'll just focus on the first one. We need to find all the prefixes of the given word, that are palindromes. Finding all palindrome prefixes of a word can be done in $$O(k^2)$$ time, as there are $$k$$ possible prefixes, and checking each one takes $$O(k)$$ time. So, for each word we are doing $$k^2 + k^2 + k$$ processing, which in big-oh notation is $$O(k^2)$$. Because are doing this with $$n$$ words, we get a final result of $$O(k^2 \\cdot n)$$.\n\n    It's worth noting that the previous approach had a cost of $$O(n^2 \\cdot k)$$. Therefore, this approach isn't better in *every* case. It is only better where $$n > k$$. In the test cases your solution is tested on, this is indeed the case.\n\n\n- Space Complexity : $$O((k + n)^2)$$.\n\n    Like before, there are several components we need to consider. This time however, the space complexity is the same regardless of whether or not we include the input in the calculations. This is because the algorithm immediately creates a hash table the same size as the input.\n\n    In the input, there are $$n$$ words, with a length of up to $$k$$ each. This gives us $$O(n \\cdot k)$$. We are then building a hash table with $$n$$ keys of size $$k$$. The hash table is the same size as the original input, so it too is $$O(n \\cdot k)$$.\n\n    For each word, we're making a list of all possible pair words that need to be looked up in the hash table. In the worst case, there'll be $$k$$ words to look up, with lengths of up to $$k$$. This means that at each cycle of the loop, we're using up to $$k^2$$ memory for the lookup list. This could be optimized down to $$O(k)$$ by only creating one of the words at a time. In practice though, it's unlikely to make much difference due to the way strings are handled under the hood. So, we'll say that we're using an additional $$O(k^2)$$ memory.\n\n    Determining the size of the output is the same as the other approaches. In the worst case, there'll be $$n \\cdot (n - 1)$$ pairs of integers in the output list, as each of the $$n$$ words could pair with any of the other $$n - 1$$ words. Each pair will add 2 integers to the input list, giving a total of $$2 \\cdot n \\cdot (n - 1) = 2 \\cdot n ^ 2 - 2 \\cdot n$$. Dropping the constant and insignificant terms, we are left with an output size of $$O(n^2)$$.\n\n    Putting this all together, we get $$2 \\cdot n \\cdot k + k ^ 2 + n ^ 2 = (k + n)^2$$, which is $$O((k + n)^2)$$.\n\n<br />\n\n---\n\n#### Approach 3: Using a Trie\n\n**Intuition**\n\n*This section assumes you've previously been introduced to the Trie data structure. If you are not familiar with the Trie, work through [Leetcode's module on them first](https://leetcode.com/explore/learn/card/trie/) You'll also need to have read the previous section's intuition, as this section further builds on those ideas.*\n\nFrom the previous section, you probably noticed that the prefixes and suffixes of each word were important. If you're familiar with the *Trie* data structure, you may be wondering if there's a way we could use one to solve this problem. It turns out there is, so let's investigate!\n\nWe'll start by reminding ourselves of the palindrome pair cases we discovered in the previous section's intuition.\n\n![A diagram showing the 3 palindrome pair cases](../Figures/336/cases.png)\n\nNow, we want to build some kind of Trie with the words. Then, we want to go down the list of words and identify all words from the Trie that our current word from the list would form a palindrome pair with. In words, we are looking for:\n\n1. Words in the Trie that are the reverse of our current word.\n2. Words in the Trie that start with the reverse of our current word and then finish in a palindrome.\n3. Words in the Trie that are the reverse of the first part of our current word, and then what's left of our current word forms a palindrome.\n\nBecause we are interested in the reverse of words, it makes sense to put all the words into the Trie in reverse. You could also put the words forward into the Trie, and then reversed each word in the list. Both approaches are equally valid, and have their own pros and cons in terms of clarity.\n\nAnyway, let's jump to an example now. Our word list is as follows:\n\n```\nwords = [ \"A\", \"B\", \"BAN\", \"BANANA\", \"BAT\", \"LOLCAT\", \"MANA\", \"NAB\", \"NANA\", \"NOON\", \"ON\", \"TA\", \"TAC\"]\n```\n\nWe'll start by inserting the reverse of each word into a Trie, as shown in the following animation.\n\n!?!../Documents/336_build_trie.json:960,540!?!\n\nFor ease of reference, here's the final Trie we got after inserting all the words.\n\n![A diagram showing the final Trie with all the reversed words inserted.](../Figures/336/final_trie.png)\n\nGreat! We have a Trie. So, how do we use it? We'll look at each of the 3 cases, one-by-one.\n\n*Case 1 with the Trie*\n\nCase 1 is where a palindrome pair is formed by 2 words that are the reverse of each other. We'll use the word `\"BAN\"` as our example. The reverse of `\"BAN\"` is `\"NAB\"`. Therefore, we need to use our Trie to see if the word `\"NAB\"` exists.\n\nHow will `\"NAB\"` appear in the Trie? Well, remember how all words were inserted into the Trie ***backwards***? This means that `\"NAB\"` will appear as `\"BAN\"` in the Trie. Therefore, we are simply searching for the word itself, in this case `\"BAN\"`. If we can find the word in the Trie, **and** be on a blue (end of word) node when we're done, we know the reverse exists.\n\nHere's an animation showing how we determine that the reverse of `\"BAN\"` is in the Trie.\n\n!?!../Documents/336_trie_case_1.json:960,540!?!\n\nRemember that for the output, we need to give the *indexes* of each pair. Currently, finding this information would be annoying. To fix it, we'll add an index field onto *each end of word node*. If we do that, this is our resulting Trie.\n\n![A diagram showing the final Trie with end of word indexes.](../Figures/336/added_end_indexes.png)\n\nSo, we knew that `\"BAN\"` had an index of `2`. When we get to the end of the word it matches with, we see that it is word `7`. The first word of the pair was `\"BAN\"`, and `\"NAB\"` was the second. Therefore, we can add the pair `[2, 7]` to our output list.\n\n*Case 2 with the Trie*\n\nCase 2 is the one where the first word is shorter than the second word. The second word starts with a palindrome, and ends with the reverse of the first word. So, how will this look in our Trie?\n\nWell, let's just have a look. The example we'll work with this time is `\"TAC\"`. Like before, we know that the last 3 letters of the second word must start with \"`CAT`\". Now, remembering that these would have been inserted in reverse, we will start by looking for `\"TAC\"`. Once we have found those letters, we would expect to *not yet be at the end of a word*, but for there to be a word that only has a palindrome left.\n\nHere's an animation showing this search.\n\n!?!../Documents/336_trie_case_2.json:960,540!?!\n\nIn this particular example, there was only one word left, and it did indeed form a palindrome.\n\n*A quick understanding check*\n\nBefore we continue on with case 3, it's time to make sure you're following okay. Here's a different Trie, (closely) related to the one above. Like before, the word we're looking at is the word `\"TAC\"`. We want to find all second words that it forms a palindrome pair with. Answer the following questions before scrolling down to the explanation.\n\n1. What are *ALL* the words that end in \"CAT\"?\n2. What are all the words that form a palindrome pair with `\"TAC\"`?\n3. How do we know the word `\"CAT\"` itself is not in the Trie?\n\n![The Trie to use for the quick questions.](../Figures/336/another_example.png)\n\n1. We know that any blue circles \"below\" the letters we have found so far represent the end of a word. Remember that they should be read backwards! The answer is, therefore: `\"LILCAT\"`. `\"OLCAT\"`, `\"LOLCAT\"`, `\"BIGCAT\"`, `\"MACAT\"` and `\"ACAT\"`.\n\n2. To do this, you need to look for palindromes hanging below the highlighted `\"C\"`. ALL of the words below the C are: `\"LIL\"`, `\"OL\"`, `\"LOL\"`, `\"BIG\"`, `\"MA\"`, and `\"A\"`. Of these, the palindromes are `\"LIL\"`, `\"LOL\"`, and `\"A\"`, which correspond to the words `\"LOLCAT\"`, `\"LILCAT\"`, and `\"ACAT\"`. Therefore, we know each of these 3 words will form a palindrome pair with `\"TAC\"`.\n\n3. If `\"CAT\"` were in the Trie, we'd expect to see the `\"C\"` at the end of the highlighted letters be blue and have an index field. It doesn't. Therefore, we know the word `\"CAT\"` is not in the Trie.\n\nIt might have been a little annoying having to carefully read each branch below the word `\"TAC\"`, that ended in a blue circle. Luckily, there's an easy way we can improve the Trie structure to simplify this process.\n\nWhen we insert a word, we can start by determining all of its palindrome *prefixes*. Now, on each node we'll attach a list of all words that have a palindrome remaining on them. For the example you worked through, this is the words you identified in part 2. The new Trie for that example would be as follows. The indexes are shown in yellow.\n\n![A Trie with additional indexes added.](../Figures/336/another_example_with_all_indexes.png)\n\nHave a think about our original example. What would these new lists be for it?\n\n*Case 3 with the Trie*\n\nCase 3 is the one where the first word is longer than the second word. In terms of our Trie, it would come up where we get to a blue node and still have some letters left from our current word. If those letters that are left form a palindrome, then we have a case 3 palindrome pair. Again, let's look at an example. This time, we are searching for the word `\"BANANA\"`. Both times we reach a blue node, there is a palindrome remaining. Therefore, we find 2 pairs in this example.\n\n!?!../Documents/336_trie_case_3.json:960,540!?!\n\nThis case is conceptually simpler than case 2. The key thing to remember is that we *only* do this palindrome check if we are *on a blue node*. If there is a palindrome remaining on our word, then a single pair is formed with the word that ended at that blue node (remember, blue nodes can only represent the end of a single word. There were no duplicates in the input list). Also, don't look at the \"palindrome remaining\" lists that we added for case 2, as this would lead to invalid pairs.\n\n**Algorithm**\n\nWe start by building the Trie. For each word, reverse it and identify its palindrome prefixes (suffixes of the reversed word). Insert the word into the Trie, and mark the final letter as an ending node, and include the word's index. Also, while inserting, note any points where the remainder of the word is a palindrome suffix by including the index in an additional list (used for case 2).\n\nThen, we go back through the list of words, looking each up in the Trie. Any of the following situations give us palindrome pairs.\n\n1. We have no letters left on the word and are at a word end node (case 1).\n2. We have no letters left on the word and there are indexes in the list attached to the node (case 2).\n3. We have a palindrome left on the word and are on a word end node (case 3).\n\n<iframe src=\"https://leetcode.com/playground/DyE2sUTd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"DyE2sUTd\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the number of words, and $$k$$ be the length of the longest word.\n\n- Time Complexity : $$O(k^2 \\cdot n)$$.\n\n    There were 2 major steps to the algorithm. Firstly, we needed to build the Trie. Secondly, we needed to look up each word in the Trie.\n\n    Inserting each word into the Trie takes $$O(k)$$ time. As well as inserting the word, we also checked at each letter whether or not the remaining part of the word was a palindrome. These checks had a cost of $$O(k)$$, and with $$k$$ of them, gave a total cost of $$O(k^2)$$. With $$n$$ words to insert, the total cost of building the Trie was therefore $$O(k^2 \\cdot n)$$.\n\n    Checking for each word in the Trie had a similar cost. Each time we encountered a node with a word ending index, we needed to check whether or not the current word we were looking up had a palindrome remaining. In the worst case, we'd have to do this $$k$$ times at a cost of $$k$$ for each time. So like before, there is a cost of $$k^2$$ for looking up a word, and an overall cost of $$k^2 \\cdot n$$ for all the checks.\n\n    This is the same as for the hash table approach.\n\n- Space Complexity : $$O((k + n)^2)$$.\n\n    The Trie is the main space usage. In the worst case, each of the $$O(n \\cdot k)$$ letters in the input would be on separate nodes, and each node would have up to $$n$$ indexes in its list. This gives us a worst case of $$O(n^2 \\cdot k)$$, which is strictly larger than the input or the output.\n\n    Inserting and looking up words only takes $$k$$ space though, because we're not generating a list of prefixes like we were in approach 2. This is insignificant compared to the size of the Trie itself.\n\n    So in total, the size of the Trie has a worst case of $$O(k \\cdot n^2)$$. In practice however, it'll use a lot less, as we based this on the worst case. Tries are difficult to analyze in the general case, because their performance is so dependent on the type of data going into them. As $$n$$ gets really, really, big, the Trie approach will eventually beat the hash table approach on both time and space. For the values of $$n$$ that we're dealing with in this question though, you'll probably notice that the hash table approach performs better.\n\n#### Additional Discussion: Online Algorithms\n\n*This section is beyond what is needed for an interview, and is included only for interest.*\n\nWhen developing algorithms for the real world, an often desirable property is that the algorithm works **online**. This does ***not mean on the internet***, instead it means that the algorithm can still work if the input data is provided bit-by-bit. In this case, it'd be that we want to feed the algorithm the words one at a time, and each time, we want to update the list of all pairs without doing too much extra work.\n\nSo, let's think through how this would work for approach 2. We'd simply be maintaining a hash table of words to indexes. Each time a new word arrives, we'd need to add it to the hash table and also check which existing words it'd form a palindrome pair with. It's a little bit different to before, because we need to find *all* pairs with previous words that form a palindrome. Let's discuss three cases we have seen above.\n\nFor case 1, this is straightforward. We simply check if its reverse is already in the hash table. If it is, then we have 2 new pairs (the new word can be either first or second).\n\nBut it breaks for case 2 and case 3. It's straightforward to find pairs where our new word is the *longer* word of the pair (i.e. second in case 2 and first in case 3), however not where the new word is *shorter*. The problem is that the additional letters of the longer word could be anything, and therefore we have no way of knowing what to look up in the index. Approach 2 worked as an offline algorithm because pairs were always identified by starting with their longer word, and then looking up their shorter word. Going the other way is intractable.\n\nApproach 3, however, works differently. If we build up a Trie as we go, we can always identify words from the *Trie* that will form the *second* half of the pair. It doesn't matter whether it is the current word, or the word from the Trie, that is longer. This solves half the problem\u2014each time we get a new word, we can *efficiently* find all \"second\" words for it.\n\nWe aren't done yet though\u2014the algorithm wouldn't find pairs where our current word was *second*. We still need to find a way of identifying all \"first\" words for the current word. It turns out that if we *hadn't* reversed words when putting them into the Trie, but instead had reversed the word we are looking up, that we'd be looking up \"first\" words in the Trie.\n\nTherefore, we can make an online algorithm by maintaining 2 Tries\u2014one with the words forward, and one with the words in reverse. The reverse Trie tells us where the new word will be the first word of a pair, and the forward Trie tells us where the new word will be the second of a pair.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "809",
            "count": 325,
            "average": "4.923",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "palindrome-pairs",
    "playgroundData": {
        "UvDYGDCu": {
            "playground": {
                "testcaseInput": "",
                "name": "palindrome-pairs-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "LEGL9QqR": {
            "playground": {
                "testcaseInput": "",
                "name": "palindrome-pairs-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "DyE2sUTd": {
            "playground": {
                "testcaseInput": "",
                "name": "palindrome-pairs-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}