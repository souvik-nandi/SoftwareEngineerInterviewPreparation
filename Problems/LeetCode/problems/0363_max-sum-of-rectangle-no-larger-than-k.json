{
    "id": "363",
    "question": {
        "questionId": "363",
        "questionFrontendId": "363",
        "boundTopicId": null,
        "title": "Max Sum of Rectangle No Larger Than K",
        "titleSlug": "max-sum-of-rectangle-no-larger-than-k",
        "content": "<p>Given an <code>m x n</code> matrix <code>matrix</code> and an integer <code>k</code>, return <em>the max sum of a rectangle in the matrix such that its sum is no larger than</em> <code>k</code>.</p>\n\n<p>It is <strong>guaranteed</strong> that there will be a rectangle with a sum no larger than <code>k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg\" style=\"width: 255px; height: 176px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,0,1],[0,-2,3]], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[2,2,-1]], k = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the number of rows is much larger than the number of columns?</p>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 1995,
        "dislikes": 109,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[[1,0,1],[0,-2,3]]\n2\n[[2,2,-1]]\n3",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Ordered Set",
                "slug": "ordered-set",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Roblox\", \"slug\": \"roblox\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Dunzo\", \"slug\": \"dunzo\", \"timesEncountered\": 4}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\nvar maxSumSubmatrix = function(matrix, k) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @param {Integer} k\n# @return {Integer}\ndef max_sum_submatrix(matrix, k)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func maxSumSubmatrix(matrix [][]int, k int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def maxSumSubmatrix(matrix: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun maxSumSubmatrix(matrix: Array<IntArray>, k: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxSumSubmatrix($matrix, $k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function maxSumSubmatrix(matrix: number[][], k: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (max-sum-submatrix matrix k)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec max_sum_submatrix(Matrix :: [[integer()]], K :: integer()) -> integer().\nmax_sum_submatrix(Matrix, K) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec max_sum_submatrix(matrix :: [[integer]], k :: integer) :: integer\n  def max_sum_submatrix(matrix, k) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"80.7K\", \"totalSubmission\": \"200.9K\", \"totalAcceptedRaw\": 80725, \"totalSubmissionRaw\": 200898, \"acRate\": \"40.2%\"}",
        "hints": [],
        "solution": {
            "id": "1143",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[1,0,1],[0,-2,3]]\n2",
        "metaData": "{\r\n  \"name\": \"maxSumSubmatrix\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"matrix\",\r\n      \"type\": \"integer[][]\"\r\n    },\r\n    {\r\n      \"name\": \"k\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1143",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n#### Overview\r\n\r\nThe first thing one might think of is a brute force solution. Since the numbers may be negative, there is no clever way to know if we should add more cells to get the best solution or not, hence we would need to enumerate all possible rectangles and get the best result. One might add a [prefix sum for a 2D array](https://leetcode.com/problems/range-sum-query-2d-immutable/solution/) to get the sum of a rectangle in $$O(1)$$, however this still has a time complexity of $$O(m^2n^2)$$ due to enumeration of all rectangles. Thus a brute force solution with prefix sums won't suffice and we need to figure out a more clever way to approach this.\r\n\r\n#### Approach 1: Prefix Sum on 1D Array using Sorted Container\r\n\r\n**Intuition**\r\n\r\nTo understand this approach let's first try to simplify the question and instead of a matrix let's find the maximum sum of a sub-array for a 1D array with `sum <= k`.\r\nHow can we achieve this? Let's use the concept of prefix sums, at every index `i` we want to find the maximum possible sum of sub-array which ends at `i`.\r\n\r\nLet's also understand what a sorted container is, which is used below. A sorted container maintains an order specified by the comparison function at all times and all operations on a sorted containers are of $$O(\\log n)$$. Some examples are, [set](http://www.cplusplus.com/reference/set/set/) in c++, [SortedSet](https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html) in Java and [SortedSet](http://www.grantjenks.com/docs/sortedcontainers/sortedset.html) in python.\r\n\r\n\r\nAt every index `i` we store the prefix sums in a sorted container, now let's say at index `i` current sum from `0..i-1` is `S`, to find the maximum possible `sum <= k` we would want to find if there is a possible sub-array with sum `k` that ends at `i`, and if not then try to find a sub-array with possible sum `k-1` and so on.\r\n\r\nNow to find a sub-array with sum `k` we have the equation $$\\text{S} - \\text{X} = \\text{k}$$, where we know `S` and we know `k` and `X` is some sub-array sum that when subtracted from `S` gives us `k` which means the sum of sub-array from the occurrence of sum `X` to the occurrence of sum `S` is `k`. Since we know the values of the two variable we can rearrange the equation to find `X` as $$\\text{S} - \\text{k} = \\text{X}$$. However, this only tells us if the sub-array with the sum exactly equal to `k` exists. What about the sub-array with sum $$\\text{k}-1..\\text{k}-2$$ and so on?\r\n\r\n![diff](../Figures/363/QueryOnSorted.png)\r\n{:align=\"center\"}\r\n\r\n*Figure 1.*\r\n{:align=\"center\"}\r\n\r\nRemember that we are storing the prefix sums in a sorted manner, which means that instead of searching for `X` we can search for the closest prefix sum that is `>= X` in $$\\log n$$ using binary search. This will always give us the minimum possible value `>= X` so that the sub-array sum is as close to `k`, if $$\\text{S} - \\text{X} = \\text{k}$$ then $$\\text{S} - (\\text{X}+1) = \\text{k}-1$$ and so on.\r\n\r\nThe following visualization will help you understand how to get the result for a 1D array.\r\n\r\n!?!../Documents/363/1D.json:1000,500!?!\r\n{:align=\"center\"}\r\n\r\n*Visualization 1. Finding Max Sub-array `sum <= k` for 1D Array*\r\n{:align=\"center\"}\r\n\r\n<br />\r\n\r\nUnderstanding the previous section is the hard part, now all we need to do is extend the procedure to work for a 2D array. This can be accomplished by converting each 2D matrix to a 1D array and then running the previous algorithm.  Each time the algorithm is run, we update the global maximum result.\r\n\r\nHow do we do this? Imagine we have a $$3 \\text{x} 5$$ matrix. We will start by finding the maximum result for all $$1 \\text{x} 5$$ arrays (each row of the matrix).  Next, we want to find the maximum possible result for all rectangles of height 2.   So, we first convert each $$2 \\text{x} 5$$ sub-matrix into a $$1 \\text{x} 5$$ array by summing each column, then we run the algorithm, and update the global maximum result. Finally, we will repeat this process for the entire $$3 \\text{x} 5$$ matrix.\r\n\r\nThe picture below depicts how a $$2 \\text{x} 3$$ matrix can be converted to a $$1 \\text{x} 3$$ 1D array.\r\n\r\n![diff](../Figures/363/1DRep.png)\r\n{:align=\"center\"}\r\n\r\n*Figure 2. Converting a 2D matrix to 1D Sum Array*\r\n{:align=\"center\"}\r\n\r\nNow let's combine the two algorithms to get the required result for a matrix.\r\n\r\n!?!../Documents/363/2D.json:1000,500!?!\r\n{:align=\"center\"}\r\n\r\n*Visualization 2. Finding Max `sum <= K` of a rectangle for a Matrix*\r\n{:align=\"center\"}\r\n\r\n<br />\r\n\r\n**Algorithm**\r\n\r\n<style type=\"text/css\">\r\n    ol ol { list-style-type: lower-alpha; }\r\n</style>\r\n1. Let's define a function that gets us the result of the maximum possible sum of a sub-array with `sum <= k` for a given 1D array.\r\n   1. Let's initialize a variable for running sum with `0`. Let's call it `sum`.\r\n   2. Initialize a sorted container to store prefix sums and add `0` to it.\r\n   3. Iterate each number in the 1D array.\r\n   4. Add current number to the running sum.\r\n   5. Find the closest value of `sum - k` greater than or equal to `sum - k` in the sorted prefix sums using binary search. Let's call it `X`.\r\n   6. If such a number is found store the maximum value of `sum - X` until now in a global variable.\r\n   7. Add the current running sum in the container for prefix sums.\r\n   8. Repeat steps d to g for all numbers in the 1D array.\r\n2. Initialize an array with length equal to the number of columns in the matrix. This will store 1D representation of the matrix, let's call it `rowSum`.\r\n3. Run a loop from `0` to rows in the matrix. This represents the starting row of the matrix that we are aiming to find a result for.\r\n4. At the beginning of this loop fill `rowSum` with `0`.\r\n5. Run a nested loop that would again run from `0` to number of rows in the matrix. This represents the ending row of the matrix that we are aiming to find the result for.\r\n6. Perform a column-wise sum of the ending row with the 1D representation `rowSum`. This will be the 1D representation of the matrix between `i..j`.\r\n7. Run the algorithm to find the maximum possible sum of sub-array with `sum <= k` for this row.\r\n8. We repeat the steps 3 to 7 for all combinations of `i` and `j` where $$\\text{i} \\le \\text{j}$$.\r\n\r\n<iframe src=\"https://leetcode.com/playground/gQb3pDii/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gQb3pDii\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$m$$ be the number of rows and $$n$$ be the number of columns.\r\n\r\n* Time complexity: $$O(m^2n\\log n)$$. We iterate over each `i` and `j` where $$0 \\le i \\le j <m$$, within this we iterate over each `i` where $$0 \\le i<n$$ and perform a binary search on the same number of elements.\r\n\r\n* Space complexity: $$O(n)$$. We create a separate array of size `n` representing the 2D matrix and also store prefix sums for all indices.\r\n\r\n\r\n<br />\r\n\r\n---\r\n\r\n#### Approach 2: Follow-up - Larger Number of Rows than Columns\r\n\r\n**Intuition**\r\n\r\nThe follow-up question asks if the number of rows is significantly larger, can we improve upon our solution? The answer is Yes!\r\n\r\nYou will notice that in the previous approach we take the most time $$O(m^2)$$ to iterate over each consecutive combination of rows and convert them to 1D array. It is obvious that if the number of rows increases the time will significantly increase as well. To get around this one may notice that there is no specific reason in the previous approach to perform a row-wise combination and converting them to a 1D array of size `n`, we can perform a column-wise combination and convert them to 1D array of size `m` and it would give us the same result.\r\n\r\nThus we can switch between the two based on the size of rows and columns. Let's try this approach.\r\n\r\nWe can also simply transpose the matrix when `m > n` and then solve it using approach 1.\r\n\r\n**Algorithm**\r\n\r\nWe use the same idea as the previous approach but create the 1D vector column-wise if the number of rows is greater than the number of columns or do it row-wise otherwise, same as the previous approach. We can also reuse the function that gets the result for 1D vector.\r\n<iframe src=\"https://leetcode.com/playground/hCjxwTCp/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"hCjxwTCp\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$m$$ be the number of rows and $$n$$ be the number of columns.\r\n\r\n* Time complexity: $$O(\\min(m,n)^2\\max(m,n)\\log \\max(m,n))$$. Using the same thought process as approach 1.\r\n\r\n* Space complexity: $$O(\\max(m, n))$$. Using the same thought process as approach 1.\r\n\r\n---\r\n\r\n#### Approach 3: Combining it with Kadane's Algorithm\r\n\r\n**Intuition**\r\n\r\n[Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm) gets the max possible sum of a sub-array in $$O(n)$$ time. [This](https://leetcode.com/problems/maximum-subarray/solution/) LeetCode article explains the algorithm beautifully.\r\nLet's understand how this algorithm can be used to our advantage for this problem.\r\n\r\nFor each 1D array that we try to find the result for, we can first run Kadane's algorithm on it and get the maximum possible sum of any sub-array with it. If this result is `<= k` we can simply skip running our initial $$O(n\\log n)$$ algorithm as we already have the maximum possible result the 1D array can give. This will help us in significantly reducing the runtime of the algorithm as 1D arrays with max sub-array `sum <= k` would take $$O(n)$$ time only.\r\n\r\n**Algorithm**\r\n\r\nWe use the same idea as the previous approach but add an extra Kadane's algorithm in `updateResult` function before running the algorithm mentioned in previous approaches, if its result is `<= k` we skip running the previous algorithm and return the same result, else we do the same thing as the previous approach.\r\n\r\n<iframe src=\"https://leetcode.com/playground/YWEev7HZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"YWEev7HZ\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$m$$ be the number of rows and $$n$$ be the number of columns.\r\n\r\n* Time complexity: $$O(\\min(m,n)^2\\max(m,n)\\log \\max(m,n))$$. Using the same thought process as approach 1 as in the worst case we end up running the algorithm from approach 1 for all 1D arrays.\r\n\r\n* Space complexity: $$O(\\max(m, n))$$. Using the same thought process as approach 1.\r\n\r\n</br>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1148",
            "count": 47,
            "average": "4.574",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "max-sum-of-rectangle-no-larger-than-k",
    "playgroundData": {
        "gQb3pDii": {
            "playground": {
                "testcaseInput": "",
                "name": "max-sum-of-rectangle-no-larger-than-k-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "hCjxwTCp": {
            "playground": {
                "testcaseInput": "",
                "name": "max-sum-of-rectangle-no-larger-than-k-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "YWEev7HZ": {
            "playground": {
                "testcaseInput": "",
                "name": "max-sum-of-rectangle-no-larger-than-k-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}