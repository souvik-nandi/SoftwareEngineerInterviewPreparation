{
    "id": "1352",
    "question": {
        "questionId": "1352",
        "questionFrontendId": "1235",
        "boundTopicId": null,
        "title": "Maximum Profit in Job Scheduling",
        "titleSlug": "maximum-profit-in-job-scheduling",
        "content": "<p>We have <code>n</code> jobs, where every job is scheduled to be done from <code>startTime[i]</code> to <code>endTime[i]</code>, obtaining a profit of <code>profit[i]</code>.</p>\n\n<p>You&#39;re given the <code>startTime</code>, <code>endTime</code> and <code>profit</code> arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.</p>\n\n<p>If you choose a job that ends at time <code>X</code> you will be able to start another job that starts at time <code>X</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png\" style=\"width: 380px; height: 154px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n<strong>Output:</strong> 120\n<strong>Explanation:</strong> The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png\" style=\"width: 600px; height: 112px;\" /> </strong></p>\n\n<pre>\n<strong>Input:</strong> startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n<strong>Output:</strong> 150\n<strong>Explanation:</strong> The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png\" style=\"width: 400px; height: 112px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= profit[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 3442,
        "dislikes": 37,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Maximum Earnings From Taxi\", \"titleSlug\": \"maximum-earnings-from-taxi\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Best Non-Overlapping Events\", \"titleSlug\": \"two-best-non-overlapping-events\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[1,2,3,3]\n[3,4,5,6]\n[50,10,40,70]\n[1,2,3,4,6]\n[3,5,10,6,9]\n[20,20,100,70,60]\n[1,1,1]\n[2,3,4]\n[5,6,4]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Sorting",
                "slug": "sorting",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Arista Networks\", \"slug\": \"arista-networks\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Dunzo\", \"slug\": \"dunzo\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Pony.ai\", \"slug\": \"ponyai\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"DoorDash\", \"slug\": \"doordash\", \"timesEncountered\": 32}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Databricks\", \"slug\": \"databricks\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Swiggy\", \"slug\": \"swiggy\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Atlassian\", \"slug\": \"atlassian\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Cisco\", \"slug\": \"cisco\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Indeed\", \"slug\": \"indeed\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"tiktok\", \"slug\": \"tiktok\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int JobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} startTime\n * @param {number[]} endTime\n * @param {number[]} profit\n * @return {number}\n */\nvar jobScheduling = function(startTime, endTime, profit) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} start_time\n# @param {Integer[]} end_time\n# @param {Integer[]} profit\n# @return {Integer}\ndef job_scheduling(start_time, end_time, profit)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func jobScheduling(_ startTime: [Int], _ endTime: [Int], _ profit: [Int]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func jobScheduling(startTime []int, endTime []int, profit []int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def jobScheduling(startTime: Array[Int], endTime: Array[Int], profit: Array[Int]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun jobScheduling(startTime: IntArray, endTime: IntArray, profit: IntArray): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn job_scheduling(start_time: Vec<i32>, end_time: Vec<i32>, profit: Vec<i32>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $startTime\n     * @param Integer[] $endTime\n     * @param Integer[] $profit\n     * @return Integer\n     */\n    function jobScheduling($startTime, $endTime, $profit) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function jobScheduling(startTime: number[], endTime: number[], profit: number[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (job-scheduling startTime endTime profit)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec job_scheduling(StartTime :: [integer()], EndTime :: [integer()], Profit :: [integer()]) -> integer().\njob_scheduling(StartTime, EndTime, Profit) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec job_scheduling(start_time :: [integer], end_time :: [integer], profit :: [integer]) :: integer\n  def job_scheduling(start_time, end_time, profit) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"122.9K\", \"totalSubmission\": \"241.2K\", \"totalAcceptedRaw\": 122933, \"totalSubmissionRaw\": 241224, \"acRate\": \"51.0%\"}",
        "hints": [
            "Think on DP.",
            "Sort the elements by starting time, then define the dp[i] as the maximum profit taking elements from the suffix starting at i.",
            "Use binarySearch (lower_bound/upper_bound on C++) to get the next index for the DP transition."
        ],
        "solution": {
            "id": "1155",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,2,3,3]\n[3,4,5,6]\n[50,10,40,70]",
        "metaData": "{\n  \"name\": \"jobScheduling\",\n  \"params\": [\n    {\n      \"name\": \"startTime\",\n      \"type\": \"integer[]\"\n    },\n    {\n      \"type\": \"integer[]\",\n      \"name\": \"endTime\"\n    },\n    {\n      \"type\": \"integer[]\",\n      \"name\": \"profit\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1155",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n--- \r\n\r\n#### Overview\r\n\r\nWe have N jobs each having some profit associated with it, and we want to gain maximum profit by selecting some non-conflicting jobs. Two jobs A and B represented as `(startTime, endTime)` by `(startA, endA)` and `(startB, endB)` are **_non-conflicting_** if either job A starts after job B ends which can be represented by condition `startA >= endB`, or if job B starts after job A ends which can be represented by `startB >= endA`.\r\n\r\nWe can observe that for each job, there are two options, either to schedule it or not. The total number of possible combinations with N jobs is $$2^N$$. The brute force approach is to enumerate every possible combination. However, we want a better-optimized approach. We can achieve this by applying our definition for **_non-conflicting_** jobs. If we schedule the job at index `i` that ends at `endTime[i]`, then all the jobs which have a `startTime` before `endTime[i]` can be discarded. The next job to schedule at index `j` should have a start time, `startTime[j]`, such that `startTime[j] >= endTime[i]`.\r\n\r\nThere are two key characteristics of this problem that we should take note of at this time.  First, a job cannot be scheduled if a conflicting job has already been scheduled. In other words, each decision we make is affected by the previous decisions we have made.  Second, the problem asks us to **maximize** the profit by scheduling non-conflicting jobs.  These are two common characteristics of dynamic programming problems, and as such we will approach this problem using dynamic programming.\r\n\r\n</br>\r\n\r\n---\r\n\r\n#### Approach 1: Top-Down Dynamic Programming + Binary Search\r\n\r\n**Intuition**\r\n\r\nLet's start at time zero, before the `startTime` of any job, at this point we can choose any job to schedule first. Once the first job has ended, we can iterate over all of the jobs and only consider scheduling those that start after the current time.  The process of repeatedly iterating over the jobs array is very time-consuming and we can do better: if we sort our jobs according to start time, then we can apply binary search to find the next job. After sorting jobs according to `startTime`, to find the index of the first non-conflicting job, binary search for the `endTime` of the current job in the list of start times for all jobs.\r\n\r\nFor each job, we will try two options:\r\n- Schedule this job and move on to the next non-conflicting job using binary search.\r\n- Skip this job and move on to the next available job. \r\n\r\nThen we can make an informed decision about whether we should schedule the job based on which of the above two options results in the greater profit.\r\n\r\nThis recursive approach will have repeated subproblems; this can be observed in the figure below. Notice, the subtree with root $$2$$ is repeated signifying that we must solve this subproblem more than once. \r\n![fig](../Figures/1235/1235A.png)\r\n\r\nTo address this issue, the first time we calculate `maxProfit` for a certain `position`, we will store the value in an array; this value represents the maximum profit we can get from the jobs at indices from `position` to the end of the array.  The next time we need to calculate `maxProfit` for this `position`, we can look up the result in constant time. This technique is known as memoization and it helps us avoid recalculating repeated subproblems.\r\n\r\n**Algorithm**\r\n\r\n1. Store the `startTime`, `endTime` and `profit` of each job in `jobs`.\r\n2. Sort the `jobs` according to their starting time.\r\n3. Iterate over jobs from left to right, where `position` is the index of the current job.  For each job, we must compare two options:\r\n   - i. Skip the current job (earn 0 profit) and move on to consider the job at the index `position + 1`.\r\n    - ii. Schedule the current job (earn profit for the current job) and move on to the next non-conflicting job whose index is `nextIndex`. `nextIndex` is determined by using binary search in the `startTime` array.\r\n4. Return the maximum profit of the two choices and record this profit in the array `memo` (memoization).\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/iqfHEL2f/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"iqfHEL2f\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\nLet $$N$$ be the length of the `jobs` array.\r\n\r\n* Time complexity: $$O(N\\log N)$$\r\n                   \r\n  Sorting jobs according to their starting time will take $$O(N\\log N)$$.\r\n                   \r\n  The time complexity for the recursion (with memoization) is equal to the number of times `findMaxProfit` is called times the average time of `findMaxProfit`. The number of calls to `findMaxProfit` is $$2*N$$ because each non-memoized call will call `findMaxProfit` twice. \r\n Each memoized call will take $$O(1)$$ time while for the non-memoized call, we will perform a binary search that takes $$O(log N)$$ time, hence the time complexity will be $$O(N\\log N + N)$$.\r\n                   \r\n  The total time complexity is therefore equal to $$O(N\\log N)$$.\r\n\r\n* Space complexity: $$O(N)$$\r\n\r\n  Storing the starting time, ending time, and profit of each job will take $$3\\cdot N$$ space. \r\n  Hence the complexity is $$O(N)$$.\r\n\r\n  The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, the Arrays.sort() for primitives is implemented as a variant of quicksort algorithm whose space complexity is $$O(\\log \r\n  N)$$. In C++ sort() function provided by STL is a hybrid of Quick Sort, Heap Sort and \r\n  Insertion Sort with the worst-case space complexity of $$O(\\log N)$$. Thus the use of \r\n  inbuilt sort() function adds $$O(\\log N)$$ to space complexity.\r\n                    \r\n  The result for each `position` will be stored in `memo` and `position` can have the values from $0$ to $N$, thus the space required is $$O(N)$$. Also, stack space in recursion is equal to the maximum number of active functions.  In the scenario where every job is not scheduled, the function call stack will be of size $$N$$.\r\n                    \r\n  The total space complexity is therefore equal to $$O(N)$$.\r\n    \r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 2: Bottom-Up Dynamic Programming + Binary Search\r\n\r\n**Intuition**\r\n\r\nIn the previous approach, the recursive calls incurred stack space. This can be avoided by applying the same approach in an iterative manner which is generally faster than the top-down approach. In this approach, we start from `position = n` which is our base case because when there are no more jobs to schedule the maximum profit must be 0.  We will traverse the `jobs` array from right to left and build up `memo` with the previously calculated maximum profits. In order to build up `memo`, for each index, we will check the profit that can be obtained by scheduling and not scheduling the job at that index. \r\n\r\n1. If we schedule the job at index `i`, we will apply binary search to find the index (`nextIndex`) of the first non-conflicting job. The total profit by scheduling the job at index `i` is the sum of the profit of the current job and the value of `memo[nextIndex]`.\r\n2. If we skip the job at index `i`, the maximum profit will be the same as `memo[i+1]` which is the maximum profit that can be obtained by starting at the next job. \r\n\r\nThe maximum profit obtained from the above two options will be stored at `memo[i]` which represents the maximum profit we can achieve by scheduling non-conflicting jobs between index `i` and the end of the array.\r\n\r\n**Algorithm**\r\n\r\n1. Store the `startTime`, `endTime` and `profit` of each job in `jobs`.\r\n2. Sort the jobs according to their starting time.\r\n3. Iterate over the jobs from right to left find the `currProfit` for each job. `currProfit` is the sum of the current job's profit and the maximum profit obtained by scheduling jobs between `nextIndex` and the end of the jobs array(`memo[nextIndex]`).\r\n4. For each index `i`, set `memo[i]` equal to the maximum between `currProfit` and `memo[i+1]`. If `currProfit` is greater, then it's more profitable to schedule the job at index `i`, otherwise, it's better not to schedule this job.\r\n5. Return the value `memo[0]`.\r\n\r\n\r\n**Implementation**\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/27ZXUaaT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"27ZXUaaT\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n Let $$N$$ be the length of the `jobs` array.\r\n\r\n* Time complexity: $$O(N\\log N)$$\r\n\r\n  Sorting jobs according to their starting time will take $$O(N\\log N)$$ time.\r\n  \r\n  We iterate over all $$N$$ jobs from right to left and for each job we perform a \r\n  binary search which takes $$O(\\log N)$$, so this step also requires $$O(N\\log N)$$ time.\r\n  \r\n  The total time complexity is therefore equal to $$O(N\\log N)$$.\r\n  \r\n* Space complexity: $$O(N)$$\r\n\r\n  Storing the start time, end time, and profit of each job takes $$3\\cdot N$$ space. \r\n  Hence the complexity is $$O(N)$$.\r\n    \r\n\r\n<br/>\r\n\r\n---\r\n#### Approach 3: Sorting + Priority Queue\r\n\r\n**Intuition**\r\n\r\nThis problem can be correlated to [Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/) where each job can be thought of as a pair of startTime and endTime (a link in the chain). Now consider that each link in the chain has a profit associated with it, and rather than making the longest chain, our goal is to make the most profitable chain. \r\n\r\nConsidering the problem this way, it becomes similar to [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) with the goal of maximizing the profit instead of length. As such, we can approach this problem in a similar way, by first sorting the jobs according to their start time and then for each job, choose the most profitable chain of jobs to add the current job to. \r\n\r\nLet's walk through an example to see how this will work:\r\n\r\n!?!../Documents/1235_maximum_profit_in_job_scheduling.json:960,720!?! <br>\r\n\r\nNotice that for every new job, we iterate over all of the previous job chains to find the most profitable chain that ends at or before the current job starts.  This results in $$O(N^2)$$ time complexity. Can we do better?\r\n\r\nLet's take a moment and think about how we can optimize this approach.\r\n\r\nThere are two key observations to make: \r\n1. For each job we want to find all chains that end before the current job's start time.  \r\n2. Since the jobs are sorted according to start time if a chain does not conflict with the current job, then it will also not conflict with any future job. \r\n\r\nThe first observation tells us that we want to store the existing chains so that those with the earliest end time can be accessed efficiently.  The second observation tells us that we do not need to remember chains that have ended, we only need to remember the maximum profit from any chain that has ended.  These observations (accessing chains that have earlier end times and removing them from the data structure) hint that a heap is an efficient data structure to store the chains.  \r\n\r\n**Algorithm**\r\n\r\nWe will iterate over the jobs from left to right and for each job, we will check if this job can be appended to any previous chain of jobs by popping out the chains from the heap. Among all chains that do not conflict with the current job, we will append the current job to the chain with the highest profit. When we append the current job to the highest profit chain, we form a new chain. This job chain will then be pushed into the heap as a pair of the end time and the total profit (the current job's profit plus maximum profit from non-conflicting chains).\r\n\r\nHowever, there is a tricky part here. When we pop a job chain from the heap we don't push it back into the heap, although this job chain can still be combined with other jobs in the future. To handle this case we introduce a variable `maxProfit` whenever we pop a job chain from heap we compare its profit with the `maxProfit` and update it accordingly. The reason is that the jobs are sorted and hence if we pop out a chain from the heap for the `ith` job then it implies that this chain can be combined with any other job that comes after index `i`. Therefore we only need to store the chain's profit. Furthermore, since it is always optimal to use the most profitable chain, we only need to keep track of the maximum profit seen so far. Formally at the time of `ith` iteration, the value of `maxProfit` will be the maximum profit of a set of job chains to which the `ith` job can be appended.\r\n\r\n1. Store the `startTime`, `endTime`, and `profit` of each job in `jobs`.\r\n2. Sort the `jobs` according to their starting time.\r\n3. Iterate over jobs from left to right, where `i` is the index of the current job. For each job\r\n    - While the job chain at the top of the priority queue does not conflict with the current job, pop from the priority queue.\r\n    - For each popped job chain compare its total profit with the `maxProfit` and update `maxProfit` accordingly.\r\n4. Push the pair of ending time and the combined profit (`maxProfit` + profit of this job) into the heap. This item represents the chain created by adding the current job to the most profitable job chain.\r\n5. After iterating over all the jobs, compare the profit of the remaining chains in the priority queue with the `maxProfit`. Return the value of `maxProfit`.\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/M9FFgqo4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"M9FFgqo4\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n Let $$N$$ be the length of the `jobs` array.\r\n\r\n* Time complexity: $$O(N\\log N)$$\r\n\r\n  Sorting jobs according to their starting time will take $$O(N\\log N)$$ time.\r\n  \r\n  We iterate over all $$N$$ jobs. For each job, we push the maximum profit job chain into the heap once which takes $$O(\\log N)$$ time.\r\n\r\n  The total time complexity is therefore equal to $$O(N\\log N)$$.\r\n\r\n* Space complexity: $$O(N)$$\r\n\r\n  Storing the start time, end time, and profit of each job takes $$3\\cdot N$$ space. \r\n  Hence the complexity is $$O(N)$$.\r\n\r\n  The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, the Arrays.sort() for primitives is implemented as a variant of quicksort algorithm whose space complexity is $$O(\\log \r\n  N)$$. In C++ sort() function provided by STL is a hybrid of Quick Sort, Heap Sort and \r\n  Insertion Sort with the worst-case space complexity of $$O(\\log N)$$. Thus the use of \r\n  inbuilt sort() function adds $$O(\\log N)$$ to space complexity.\r\n                    \r\n  Each of the $$N$$ jobs will be pushed into the heap.  In the worst-case scenario, when all $$N$$ jobs end later than the last job starts, the heap will reach size $$N$$.\r\n                    \r\n  The total space complexity is therefore equal to $$O(N)$$.\r\n\r\n    \r\n\r\n<br/>\r\n\r\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1160",
            "count": 53,
            "average": "4.774",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "maximum-profit-in-job-scheduling",
    "playgroundData": {
        "iqfHEL2f": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-profit-in-job-scheduling-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "27ZXUaaT": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-profit-in-job-scheduling-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "M9FFgqo4": {
            "playground": {
                "testcaseInput": "",
                "name": "maximum-profit-in-job-scheduling-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}