{
    "id": "698",
    "question": {
        "questionId": "698",
        "questionFrontendId": "698",
        "boundTopicId": null,
        "title": "Partition to K Equal Sum Subsets",
        "titleSlug": "partition-to-k-equal-sum-subsets",
        "content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if it is possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,3,2,3,5,2,1], k = 4\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], k = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>The frequency of each element is in the range <code>[1, 4]</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 5257,
        "dislikes": 351,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Partition Equal Subset Sum\", \"titleSlug\": \"partition-equal-subset-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Fair Distribution of Cookies\", \"titleSlug\": \"fair-distribution-of-cookies\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Ways to Partition an Array\", \"titleSlug\": \"maximum-number-of-ways-to-partition-an-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[4,3,2,3,5,2,1]\n4\n[1,2,3,4]\n3",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Memoization",
                "slug": "memoization",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Bitmask",
                "slug": "bitmask",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 17}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Zomato\", \"slug\": \"zomato\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def canPartitionKSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nbool canPartitionKSubsets(int* nums, int numsSize, int k){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public bool CanPartitionKSubsets(int[] nums, int k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nvar canPartitionKSubsets = function(nums, k) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Boolean}\ndef can_partition_k_subsets(nums, k)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func canPartitionKSubsets(_ nums: [Int], _ k: Int) -> Bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func canPartitionKSubsets(nums []int, k int) bool {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def canPartitionKSubsets(nums: Array[Int], k: Int): Boolean = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun canPartitionKSubsets(nums: IntArray, k: Int): Boolean {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn can_partition_k_subsets(nums: Vec<i32>, k: i32) -> bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Boolean\n     */\n    function canPartitionKSubsets($nums, $k) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function canPartitionKSubsets(nums: number[], k: number): boolean {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (can-partition-k-subsets nums k)\n  (-> (listof exact-integer?) exact-integer? boolean?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec can_partition_k_subsets(Nums :: [integer()], K :: integer()) -> boolean().\ncan_partition_k_subsets(Nums, K) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec can_partition_k_subsets(nums :: [integer], k :: integer) :: boolean\n  def can_partition_k_subsets(nums, k) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"208.3K\", \"totalSubmission\": \"490.6K\", \"totalAcceptedRaw\": 208296, \"totalSubmissionRaw\": 490592, \"acRate\": \"42.5%\"}",
        "hints": [
            "We can figure out what target each subset must sum to.  Then, let's recursively search, where at each call to our function, we choose which of k subsets the next value will join."
        ],
        "solution": {
            "id": "1198",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[4,3,2,3,5,2,1]\n4",
        "metaData": "{\r\n  \"name\": \"canPartitionKSubsets\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    },\r\n    {\r\n      \"name\": \"k\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1198",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nWe have the task of breaking the given array into `k` different parts such that all parts have the same sum. \nThis implies that each part will have a sum of `totalArraySum / k`.\nWhile breaking the given array into `k` subsets, we can pick elements from any position.\n\nLet's start from the most naive approach and gradually progress towards the optimal approach.\n\nAn intuitive way to approach this problem is to build each subset by randomly selecting one element at a time.  Since the whole array has a sum of `totalArraySum`, then as long as the current subset's sum `currentSubsetSum` is less than `totalArraySum / k`, we can randomly select elements to add to the current subset.\nIf the `currentSubsetSum` becomes equal to `totalSum / k`, then we have found one subset of the desired sum and we can proceed to make another subset. However, if the `currentSubsetSum` is greater than `totalSum / k`, we need to go back and try to build this subset differently.\nThis can be done using a backtracking algorithm.      \n\n<br />\n\nWhat is backtracking?\n> Let's consider a situation. Suppose a thief is standing in front of three houses, one of which has a bag of gold, but he doesn't know which one. \nThe thief will try all three houses. First, he will go into House 1, if the gold isn't there, then he will leave, and go into House 2, and again if that is not the right house, then he will leave and go into House 3. \n\n!?!../Documents/698/slideshow_1.json:960,540!?!\n\n<br />\n\n> While solving a problem using recursion, we break the given problem into smaller subproblems.    \nSo basically, in backtracking, we attempt to solve a subproblem, and if we don't reach the desired solution, then we **undo** whatever we did when trying to solve that subproblem and then try to solve the subproblem again by making a different choice.      \n\n\nSo in this problem, we will pick one element and try including it in our subset, if after including this element in the current subset we can't make a valid combination of all subsets, then we will discard the last picked element, _hence we will backtrack_ and try another element.\n\n\n<br />     \n\n---\n\n#### Approach 1: Naive Backtracking\n\n\n**Intuition**\n\nOur goal is to break the given array into `k` subsets of equal sums.     \nFirstly, we will check if the array sum can be evenly divided into `k` parts by ensuring that `totalArraySum % k` is equal to `0`.\n\nNow, if the array sum can be evenly divided into `k` parts, as previously mentioned, we will try to build those k subsets using backtracking.    \n\nWe will keep a `currentSum` variable denoting the sum of the current subset. One by one, try to include each element from the array that has not already been picked and then make a recursive call to pick the next element.    \nTo keep track of already picked elements we will use a vector (`taken`) to denote if the element at the `ith` index has already been picked or not.     \nWhen we pick the `ith` element, we will set `taken[i]` equal to `true`. Then after we try all combinations, we will backtrack and discard the picked element by setting `taken[i]` equal to `false` so that it can be picked in a future recursive call.      \n\nIf we reach the condition `currentSum` is greater than `targetSum`, then we cannot reach the target by adding more elements to the subset, so there is no need to proceed further; we can just backtrack from here.     \nIf we reach the condition, `currentSum` equals `targetSum`, that means we made one subset with the target sum. So now we can increment a `count` variable that counts how many subsets with a sum equal to the target we have made from our array.    \nWhen `count` becomes `k`, that means we have made `k` equal sum subsets of our array; hence we can return `true`.      \nFinally, when `count` becomes `k - 1`, that means we have `k` equal sum subsets in our array because the `totalArraySum` is divisible by `k` and the sum of `k - 1` subsets will be `(k - 1) * targetSum`, hence the last subset-sum must also equal `targetSum`. So we can stop at condition `count == k - 1` to save some time by skipping a few redundant recursive calls.\n\n\n!?!../Documents/698/slideshow_2.json:960,540!?!\n\n<br />\n\n**Algorithm**\n\n1. Calculate `totalArraySum`, and check if the sum is evenly divisible by `k`.  If so, we can break the array into `k` subsets and the sum of each subset must be equal `targetSum = totalArraySum / k`.\n2. For each element that has not been picked yet, i.e. `taken[j]` is `false`:\n    * We include it in our subset, `currSum = currSum + arr[j]` and mark it as taken, by setting `taken[j]` equal to `true`.\n    * Then we make a recursive call to find the next element to include.\n        * If this recursive call returns `true`, it means we have found a valid combination to break the array into `k` subsets. Thus, we can return `true` from here.\n        * Otherwise, we will discard the current element (backtrack) i.e. set `taken[j]` to `false` and subtract the current element from `currSum`, and then try the next element that is not taken.\n3. When `currSum` equals `targetSum`, we have made one subset. So reset `currSum` to `0` to start a new subset, and increment `count` by `1`.\n4. When `count` equals `k - 1`, we have made `k - 1` subsets, each with a sum equal to `targetSum`.  Therefore, the last subset must also have the sum equal to `targetSum`, so we can return `true` from here.\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/BNuaoXZd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"BNuaoXZd\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ denote the number of elements in the array.\n\n* Time complexity: $$O(N \\cdot N!)$$. \n\n    The idea is that for each recursive call, we will iterate over $$N$$ elements and make another recursive call. Assume we picked one element, then we iterate over the array and make recursive calls for the next $$N-1$$ elements and so on.    \n    Therefore, in the worst-case scenario, the total number of recursive calls will be $$N \\cdot (N-1) \\cdot (N-2) \\cdot ... \\cdot 2 \\cdot 1 = N!$$ and in each recursive call we perform an $$O(N)$$ time operation.    \n\n    Another way is to visualize all possible states by drawing a recursion tree. From root node we have $$N$$ recursive calls. The first level, therefore, has $$N$$ nodes. For each of the nodes in the first level, we have $$(N-1)$$ similar choices. As a result, the second level has $$N*(N-1)$$ nodes, and so on. The last level must have $$N \\cdot (N-1) \\cdot (N-2) \\cdot (N-3) \\cdot ... \\cdot 2 \\cdot 1$$ nodes.\n\n![recursion tree](../Figures/698/Slide56.JPG)\n\n<br />\n\n* Space complexity: $$O(N)$$.\n    \n    We have used an extra array of size $$N$$ to mark the picked elements.    \n    And the maximum depth of the recursive tree is at most $$N$$, so the recursive stack also takes $$O(N)$$ space.\n\n<br/>\n\n---\n\n#### Approach 2: Optimized Backtracking\n\n**Intuition**\n\nIn the previous approach in each function call, we will start iterating over the given array from the 0th index, even if the previous elements were already taken.    \nInstead of starting our search for each element to include from the 0th index, again and again, we can continue the search from the last picked element. When a subset is completed, only then will we start the search from the 0th index, as we can now include the previously skipped elements in new subsets.        \nWe are doing this because it allows us to skip checking the elements that are already picked. Also, if there is an element that was skipped earlier, then that element will be skipped again because now the subset-sum has increased; if it did not fit in the subset earlier, it would not fit now.\n\nThe runtime can be further improved by initially sorting the given array in decreasing order.\n> If we had sorted the array in ascending order (smaller values on the left side), then there would be more recursion branches (recursive calls). This is because when the change in subset-sum is small, more branches will be repeatedly created during the backtracking process.\n\n\n!?!../Documents/698/slideshow_3.json:960,540!?!\n\n<br />\n\n**Algorithm**\n\n1. Calculate `totalArraySum`, and check if the sum is evenly divisible by `k`.  If so, we can break the array into `k` subsets and the sum of each subset must be equal `targetSum = totalArraySum / k`.\n2. Sort the array.\n3. For each element that has not been picked yet, i.e. `taken[j]` is `false`:\n    * We include it in our subset, `currSum = currSum + arr[j]` and mark it as taken, by setting `taken[j]` equal to `true`.\n    * Then we make a recursive call to find the next element to include. Note that we start looking from the next element in the array after the element we have already included, not from the beginning of the array as we did in the previous approach.\n        * If this recursive call returns `true`, it means we have found a valid combination to break the array into `k` subsets. Thus, we can return `true` from here.\n        * Otherwise, we will discard the current element (backtrack) i.e. set `taken[j]` to `false` and subtract the current element from `currSum`, and then try the next element that is not taken.\n4. When `currSum` equals `targetSum`, we have made one subset. So reset `currSum` to `0` to start a new subset, and increment `count` by `1`.\n5. When `count` equals `k - 1`, we have made `k - 1` subsets, each with a sum equal to `targetSum`.  Therefore, the last subset must also have the sum equal to `targetSum`, so we can return `true` from here.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/LPMMFS6V/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"LPMMFS6V\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the number of elements in the array and $$k$$ be the number of subsets.\n\n* Time complexity: $$O(k \\cdot 2^N)$$. \n\n    We are traversing the entire array for each subset (once we are done with one subset, for the next subset we are starting again with index 0). So for each subset, we are choosing the suitable elements from the array (basically iterate over nums and for each element either use it or skip it, which is $$O(2^N)$$ operation).     \n    Once the first subset is found, we go on to find the second, which would take 2^N operations roughly (because some numbers have been marked as visited). So $$T = 2^N + 2^N + 2^N + ... = k \\cdot 2^N$$.     \n    \n    > Also, one point to note that some might think if we take $$2^N$$ time in finding one subset and we find $$k$$ such subsets, then it will lead to $$2^N \\cdot 2^N \\cdot ...(k times).. \\cdot 2^N = 2^(N \\cdot k)$$ time complexity. However, this is a misconception, as we iterate over array $$k$$ times to get $$k$$ subsets, hence total time is $$k \\cdot (time to get one subset) = k \\cdot 2^N$$.     \n\n    <br />\n\n    _Why do the recursive calls for including and not including elements have $$O(2^N)$$ time complexity?_\n\n    >    The idea is that we have two choices for each element: include it in the subset OR not include it in the subset. We have N such elements. Therefore, the number of cases for events of including/excluding all numbers is: $$2 \\cdot 2 \\cdot 2 \\cdot ...(N times).. \\cdot 2 = 2^N$$.     \n\n\n    >    Another way is to visualize all possible states by drawing a recursion tree. In the first level, we have 2 choices for the first number, including the first number in the current subset or not. The second level, therefore, has 2 nodes. For each of the nodes in the second level, we have 2 similar choices. As a result, the third level has 2^2 nodes, and so on. The last level must have $$2^N$$ nodes.\n\n    <br />\n\n* Space complexity: $$O(N)$$.\n    \n    We have used an extra array of size $$N$$ to mark the already used elements.    \n    And the recursive tree makes at most $$N$$ calls at one time, so the recursive stack also takes $$O(N)$$ space.\n\n<br/>\n\n---\n\n\n#### Approach 3: Backtracking plus Memoization\n\n\n**Intuition**\n\nIn the previous approach, in some scenarios, like the one illustrated below, we would make recursive calls that are identical to previous recursive calls that returned false. As in the previous approach, here, we will also try out each possible combination. However, this time, we will avoid redundant computations by adding memoization.\n\n_What is Memoization?_\n> Memoization is an optimization technique that speeds up algorithms by storing the results of function calls and returning the cached result when the same inputs are supplied again.\n\nWe can memoize the answer based on elements included in any of the subsets.\n\n> For example, consider a scenario in which we have picked the 0th and 1st elements in set 1 and the 2nd and 3rd elements in set 2, but now we can't make set 3 using the remaining elements. We can store that if we have picked 0th, 1st, 2nd, and 3rd elements, we will never be able to make k valid subsets.    \nIf in some other recursive calls we picked the 0th and 3rd elements in set 1, and the 1st and 2nd elements in set 2, then instead of checking if we can make a set 3 or not, we have already stored the answer that we can't make a valid subset using only the remaining elements. Hence we can return the stored answer (false) from this configuration.    \n\n\n!?!../Documents/698/slideshow_4.json:960,540!?!\n\n\nNow, we need to store the `taken` array so an easy way will be to use a string instead of a `taken` array.\nThe string will denote `'0'` if the element is not picked and `'1'` if the element is picked.\nAnd we can use a map of string as a key and boolean as value to memoize the result. \n\n<br />\n\n**Algorithm**\n\n1. Calculate `totalArraySum`, and check if the sum is evenly divisible by `k`.  If so, we can break the array into `k` subsets and the sum of each subset must be equal `targetSum = totalArraySum / k`.\n2. Check if the result for the current configuration of picked elements is already stored.\n    * If it is already stored, then return the cached answer.\n3. For each element that has not been picked yet, i.e. `taken[j]` is `'0'`:\n    * We include it in our subset, `currSum = currSum + arr[j]` and mark it as taken, by setting `taken[j]` equal to `'1'`.\n    * Then, we make a recursive call to find the next element to include.\n        * If this recursive call returns `true`, it means we have found a valid combination to break the array into `k` subsets. Thus, we can return `true` from here.\n        * Otherwise, we will discard the current element (backtrack) i.e. set `taken[j]` to `'0'` and subtract the current element from `currSum`, and then try the next element that is not taken.\n4. When `currSum` equals `targetSum`, we have made one subset. So reset `currSum` to `0` to start a new subset, and increment `count` by `1`.\n5. When `count` equals `k - 1`, we have made `k - 1` subsets, each with a sum equal to `targetSum`.  Therefore, the last subset must also have the sum equal to `targetSum`, so we can return `true` from here.\n6. Memoize the answer for this configuration of picked elements.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/b9caVgBb/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"b9caVgBb\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ denote the number of elements in the array.\n\n* Time complexity: $$O(N \\cdot 2^N)$$. \n    \n    There will be $$2^N$$ unique combinations of the `taken` string, in which every combination of the given array will be linearly iterated. And if a combination occurs again then we just return the stored answer for it.      \n\n<br />\n\n* Space complexity: $$O(N \\cdot 2^N)$$.\n    \n    There will be $$2^N$$ unique combinations of the `taken` string, and each string of size $$N$$ will be stored in the map. Also, the recursive stack will use at most $$O(N)$$ space at any time.\n\n<br/>\n\n---\n\n\n#### Approach 4: Backtracking plus Memoization with Bitmasking\n\n\n**Intuition**\n\nIn the previous approach, we saw that the answer could be memoized using the state of picked elements from our array. And for that, we used a string. Similarly, we can use an integer (called a mask) to represent which indices have been picked and not picked in the array. The benefit of using an integer as a mask to represent the `taken` array is that it only uses constant space instead of the linear space required by an array. Furthermore, updating an integer mask and checking if it is present in `memo` only requires constant time; this process required linear time in the previous approach.\n\n_How can we use an integer mask instead of a boolean array?_\n> An integer has 32 bits, where each bit can be 0 or 1, we can denote the picked/not-picked state of the ith index of the array as an ith bit of the integer. If the ith index is picked from the array, we set the ith bit to 1, otherwise, we set the ith bit to 0 indicating that the element at the ith index has not been used.\n\n\n!?!../Documents/698/slideshow_5.json:960,540!?!\n\n_Some BitMask Operations:_\n*   To check if the `ith` bit is set in the mask, we can perform, `(mask >> i) & 1`. \n    `(mask >> i)` operation will shift the `ith` bit to the `0th` position, and then we can check if the right-most bit is `0` or `1` by taking its bitwise AND with `1`.  \n\n*   To set the `ith` bit in the mask we can do, `mask | (1 << i)`.    \n    `(1 << i)` operation will shift the `0th` bit of `1` to the `ith` position, and after taking its bitwise OR with the mask, the mask's `ith` bit will also become `1`.    \n\n*   To unset the `ith` bit in the mask we can do, `mask ^ (1 << i)`.\n    `(1 << i)` operation will shift the `0th` bit of `1` to the `ith` position, then taking its bitwise-XOR with mask will unset the `ith` bit and rest bits remain same.       \n\n<br />\n\n**Algorithm**\n\n1. Calculate `totalArraySum`, and check if the sum is evenly divisible by `k`.  If so, we can break the array into `k` subsets and the sum of each subset must be equal `targetSum = totalArraySum / k`.\n2. Check if the result for the current configuration of picked elements is already stored.\n    * If it is already stored, then return the cached result.\n3. For each element that has not been picked, i.e. `jth` bit of mask is `0`.\n    * We include it in our subset, `currSum = currSum + arr[j]` and mark it as taken, by setting the `jth` bit of the mask to `1`. \n    * Then, we make a recursive call to find the next element to include.\n        * If this recursive call returns `true`, it means we have found a valid combination to break the array into `k` subsets. Thus, we can return `true` from here.\n        * Otherwise, we will discard the current element (backtrack) i.e. set the `jth` bit of mask to `0` and subtract the current element from `currSum`, and then try the next element that is not taken.\n4. When `currSum` equals `targetSum`, we have made one subset. So reset `currSum` to `0` to start a new subset, and increment `count` by `1`.\n5. When `count` equals `k - 1`, we have made `k - 1` subsets, each with a sum equal to `targetSum`.  Therefore, the last subset must also have the sum equal to `targetSum`, so we can return `true` from here.\n6. Memoize the result of this configuration of picked elements using the integer mask.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/dov97u22/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"dov97u22\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ denote the number of elements in the array.\n\n* Time complexity: $$O(N \\cdot 2^N)$$. \n    \n    There will be $$2^N$$ unique combinations of building a subset from the array of length `N`, in every combination the given array will be linearly iterated. And if a combination occurs again, then we just return the stored answer for it.      \n\n<br />\n\n* Space complexity: $$O(2^N)$$.\n    \n    There will be $$2^N$$ unique combinations of the integer `mask` which will be stored in the map. And recursive stack will require at most $$O(N)$$ space.\n\n<br/>\n\n---\n\n\n#### Approach 5: Tabulation plus Bitmasking\n\n**Intuition**\n\nBy converting the DFS + Memo approach (which is an optimized top-down dynamic programming approach) to an iterative DP approach, we can eliminate the recursive stack space usage and the time usage to call functions. However, keep in mind that iterative DP approaches will typically iterate over every subproblem.  This includes subproblems that we would have skipped in the previous approach.  So while the average time and space required to solve each subproblem are better, we may need to visit more subproblems overall.\nThe DP state will be the mask that denotes which elements have been picked from the array.     \n\nIn each DP state we will pick a non-picked element, then set the corresponding bit in the mask (and the new mask will be greater than the current mask, because we set some unset bit hence we increased the value) and also add the value of that picked element to current DP state value. This indicates that in a previous subset we picked a non-picked element from the array and added it to the subset sum, and we set the same bit in the mask as the position of that element in the array.     \n\nNext time when this new DP state will occur we will try the same thing, pick a non-picked element and add it to the current subset sum, set the corresponding bit and store it again.     \n\n\nAlso, we will take the DP value's mod with `targetSum`. Doing so will reset the value to `0` whenever we make one complete subset (meaning we will start a new subset) or will keep the value as it was earlier when the subset was not complete.\nIn the end, after picking all of the elements, the `subsetSum[111.....1111]` should have the remainder `0` in it.\n\nHence,    \n- We will only start a new subset when the sum of the previous subset is equal to `targetSum`.\n- We are not allowing any state where the sum becomes more than the `targetSum` (`subsetSum[mask] + arr[i] <= targetSum`). So the sum of the (`current subset + current element`) is either less than `targetSum` or equal to `targetSum`. If it is equal to `targetSum` then we can start the next subset.      \n- For the solution to return true there should be exactly `k` subsets and this can only happen when `subsetSum[111.....1111]` is changed from -1 to 0.\n\n!?!../Documents/698/slideshow_6.json:960,540!?!\n\n<br />\n\n**Algorithm**\n\n1. Calculate `totalArraySum`, and check if the sum is evenly divisible by `k`.  If so, we can break the array into `k` subsets and the sum of each subset must be equal `targetSum = totalArraySum / k`.\n2. For each valid `mask` state:\n    - Iterate over each element in the array, and pick a not picked element if the sum will not exceed `targetSum`.\n    - Mark the element as picked in the mask and store the subset's sum at `subsetSum[new_mask]`.\n    - `new_mask` will be the previous mask ORed with the current picked index, i.e. `mask | (1<<i)`.\n    - It will make a new state valid and this state can be used in the future to add more elements to it.\n3. If we reached the last dp state, i.e. 1111....111, then it means we can partition all the elements in `k` subsets of the equal sum.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/Eqdoby5d/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Eqdoby5d\"></iframe>\n\n\n**Complexity Analysis**\n\nAssume $$N$$ denotes the number of elements in the array.\n\n* Time complexity: $$O(N \\cdot 2^N)$$. \n    \n    There will be $$2^N$$ unique states of the `mask` and in each state, we iterate over the whole array.\n\n<br />\n\n* Space complexity: $$O(2^N)$$.\n    \n    There will be $$2^N$$ unique states of the `mask` which will be stored in the `subsetSum` array.\n\n<br/>\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1203",
            "count": 66,
            "average": "4.742",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "partition-to-k-equal-sum-subsets",
    "playgroundData": {
        "BNuaoXZd": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-to-k-equal-sum-subsets-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "LPMMFS6V": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-to-k-equal-sum-subsets-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "b9caVgBb": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-to-k-equal-sum-subsets-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "dov97u22": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-to-k-equal-sum-subsets-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "Eqdoby5d": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-to-k-equal-sum-subsets-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}