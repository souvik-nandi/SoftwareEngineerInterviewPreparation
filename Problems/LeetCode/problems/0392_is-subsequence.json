{
    "id": "392",
    "question": {
        "questionId": "392",
        "questionFrontendId": "392",
        "boundTopicId": null,
        "title": "Is Subsequence",
        "titleSlug": "is-subsequence",
        "content": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>subsequence</strong> of </em><code>t</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"abc\", t = \"ahbgdc\"\n<strong>Output:</strong> true\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"axc\", t = \"ahbgdc\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= t.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Suppose there are lots of incoming <code>s</code>, say <code>s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub></code> where <code>k &gt;= 10<sup>9</sup></code>, and you want to check one by one to see if <code>t</code> has its subsequence. In this scenario, how would you change your code?",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Easy",
        "likes": 5152,
        "dislikes": 304,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Number of Matching Subsequences\", \"titleSlug\": \"number-of-matching-subsequences\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Way to Form String\", \"titleSlug\": \"shortest-way-to-form-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "\"abc\"\n\"ahbgdc\"\n\"axc\"\n\"ahbgdc\"",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Two Pointers",
                "slug": "two-pointers",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Pinterest\", \"slug\": \"pinterest\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Wix\", \"slug\": \"wix\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Yandex\", \"slug\": \"yandex\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nbool isSubsequence(char * s, char * t){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public bool IsSubsequence(string s, string t) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function(s, t) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String} s\n# @param {String} t\n# @return {Boolean}\ndef is_subsequence(s, t)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func isSubsequence(_ s: String, _ t: String) -> Bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func isSubsequence(s string, t string) bool {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def isSubsequence(s: String, t: String): Boolean = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun isSubsequence(s: String, t: String): Boolean {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn is_subsequence(s: String, t: String) -> bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Boolean\n     */\n    function isSubsequence($s, $t) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function isSubsequence(s: string, t: string): boolean {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (is-subsequence s t)\n  (-> string? string? boolean?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec is_subsequence(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> boolean().\nis_subsequence(S, T) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec is_subsequence(s :: String.t, t :: String.t) :: boolean\n  def is_subsequence(s, t) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"515.3K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 515344, \"totalSubmissionRaw\": 1018432, \"acRate\": \"50.6%\"}",
        "hints": [],
        "solution": {
            "id": "950",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "\"abc\"\n\"ahbgdc\"",
        "metaData": "{ \r\n  \"name\": \"isSubsequence\",\r\n  \"params\": [\r\n    { \r\n      \"name\": \"s\",\r\n      \"type\": \"string\"\r\n    },\r\n    { \r\n      \"name\": \"t\",\r\n      \"type\": \"string\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "830",
            "date": "2022-03-02",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "950",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Overview\n\nFirst of all, one might be deceived by the **Easy** tag of the problem.\nThe solution might be simple (_i.e._ judging by the number of code lines), yet the problem itself is much more intriguing, especially when one is asked to prove the correctness of the solution,\nnot to mention that we have an interesting and legitimate follow-up question.\n\nAlso, one might be puzzled with the hints from the problem description, which says _\"Binary Search\"_, _\"Dynamic Programing\"_ and _\"Greedy\"_.\nThere is no doubt that each of them does characterize some trait of the solutions, although the order of these keywords might be misleading.\nArguably, the keyword __**Greedy**__ is more important than the other two.\n\nOne will see in the following sections, how each of the above __*techniques*__ plays out in the solutions.\nWe will also cover the follow-up question in one of the solutions.\n\n<br/>\n\n---\n#### Approach 1: Divide and Conquer with Greedy\n\n**Intuition**\n\nThe problem concerns the string matching issues, for which often one can apply a technique called _**divide and conquer**_.\n\n>The general idea of the divide and conquer technique is to reduce the problem down into subproblems with smaller scales *recursively* until the problem becomes small enough to tackle with.\nWe then use the results of subproblems to construct the solution for the original problem.\n\nFor more details, one can refer to the chapter of [divide and conquer](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/) in our Explore card.\n\nHere we show how to break down our problem step by step.\nGiven two strings $$\\text{source}$$ and $$\\text{target}$$, we are asked to determine if the $$\\text{source}$$ string is a subsequence of the $$\\text{target}$$ string, _i.e._ $$\\text{isSubsequence(source, target)}$$\n\nLet us start from the first characters of each string, _i.e._ $$\\text{source[0]}$$, $$\\text{target[0]}$$. By comparing them, there could be two cases as follows:\n\n> Case 1): they are identical, _i.e._ $$\\text{source[0]} = \\text{target[0]}$$\n\nIn this case, the best strategy would be to **cross out** the first characters in both strings, and then continue with the matching job.\n\n![match](../Figures/392/392_match.png)\n\nBy the above action, we reduce the input into a smaller scale.\nIt boils down to determine if the rest source string (_i.e._ $$\\text{source[1:]}$$) is a subsequence of the rest of target string (_i.e._ $$\\text{target[1:]}$$), which we could summarize in the following recursive formula:\n\n$$\n    \\text{isSubsequence(source, target)} = \\text{isSubsequence(source[1:], target[1:])}\n$$\n\n> Case 2): they are not identical, _i.e._ $$\\text{source[0]} \\neq \\text{target[0]}$$\n\n![non-match](../Figures/392/392_non_match.png)\n\nIn this case, the only thing we can do is to **skip** (cross out) the first character in the target string, and keep on searching in the target string in the hope that we would find a letter that could match the first character in the source string.\n\nNow, it boils down to determine if the source string could be a subsequence for the rest of the target string, which we summarize as follows:\n\n$$\n    \\text{isSubsequence(source, target)} = \\text{isSubsequence(source, target[1:])}\n$$\n\nLet us combine the above two cases as follows, which consists of our baby steps of _divide and conquer_, by looking at the first characters of each string.\n\n$$\n\\text{isSubsequence(source, target)} =\n  \\left\\{\n    \\begin{array}{l}\n      \\text{isSubsequence(source[1:], target[1:])} \\\\\n      \\text{isSubsequence(source, target[1:])}\n    \\end{array}\n  \\right.\n$$\n\nIt should be intuitive to implement a recursive solution with the above formulas.\n\nTo make the recursion complete, we should also define the _**base cases**_ properly. In this problem, we have two particular base cases:\n\n- The $$\\text{source}$$ becomes empty, _i.e._ we found matches for all the letters in the source string. Hence, the source string is a subsequence of the target string.\n\n- The $$\\text{target}$$ becomes empty, _i.e._ we exhaust the target string, yet there are still some letters left unmatched in the source string. Hence, the source string is not a subsequence of the target string.\n\n**Greedy**\n\nBefore jumping into the implementation, we would like to discuss an important strategy that we adopted here, other than the _divide and conquer_ technique.\n\nThat is right. It is the _**Greedy**_ strategy, which we did not mention in the intuition section.\n\nAs one might recall, when the first characters of the source and target strings match, we mentioned that the _**best strategy**_ is to _cross out_ the matched characters from both strings and then continue with the matching.\n\nThe other possible action could be that we **dismiss** this match and continue the search in the target string.\n\n![dismiss match](../Figures/392/392_match_dismissed.png)\n\n> By adopting the best strategy, we were _**greedily**_ crossing out the matched character from the source string, rather than deferring the match.\n\nOne might question if the result is correct with the _greedy_ strategy, since it does seem that we were missing out some other alternatives.\n\nTo prove the __correctness__ of greedy algorithms, often we apply the contradiction technique, _i.e._ deriving a contradicted fact while assuming the alternative argument is correct.\n\nIt could be tedious to give a rigid mathematical proof on why the greedy algorithm is correct here. Here we would like to present simply two arguments without detailed proofs:\n\n- If the source is **not** a subsequence of the target string, in no case will our greedy algorithm return a positive result.\n\n- If the source is indeed a subsequence of the target string (there could exist multiple solutions), then our greedy algorithm will return a positive result as well. For an obvious reason, our greedy algorithm does not exhaust all possible matches. However, one match suffices.\n\n**Algorithm**\n\nFollowing the recursive formulas that we presented before, it should be intuitive to implement a solution with recursion.\n\nAs a reminder, here is the formulas:\n\n$$\n\\text{isSubsequence(source, target)} =\n  \\left\\{\n    \\begin{array}{l}\n      \\text{isSubsequence(source[1:], target[1:])} \\\\\n      \\text{isSubsequence(source, target[1:])}\n    \\end{array}\n  \\right.\n$$\n\n<iframe src=\"https://leetcode.com/playground/5o3nCzxu/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"5o3nCzxu\"></iframe>\n\nNote, the above implementations happen to comply with a particular form of recursion, called **tail recursion**, which is a runtime optimization technique that is supported in some programming languages such as C and C++.\n\nFor more details, one can refer to the article of [tail recursion](https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/2374/) in our Explore card.\n\n\n**Complexity Analysis**\n\nLet $$|S|$$ be the length of the source string, and $$|T|$$ be the length of the target string.\n\n- Time Complexity: $$\\mathcal{O}(|T|)$$.\n\n    - At each invocation of the `rec_isSubsequence()` function, we would consume one character from the target string and optionally one character from the source string.\n\n    - The recursion ends when either of the strings becomes empty. In the worst case, we would have to scan the entire target string. As a result, the overall time complexity of the algorithm is $$\\mathcal{O}(|T|)$$.\n\n    - Note, even when the source string is longer than the target string, the recursion would end anyway when we exhaust the target string. Hence, the number of recursions is not bounded by the length of the source string.\n\n- Space Complexity: $$\\mathcal{O}(|T|)$$\n\n    - The recursion incurs some additional memory consumption in the function call stack. As we discussed previously, in the worst case, the recursion would happen $$|T|$$ times. Therefore, the overall space complexity is $$\\mathcal{O}(|T|)$$.\n \n    - With the optimization of tail recursion, this extra space overhead could be exempted, due to the fact that the call stack is reused for all consecutive recursions. However, Python and Java do not support tail recursion. Hence, this overhead cannot be waived.\n\n<br/>\n\n---\n#### Approach 2: Two-Pointers\n\n**Intuition**\n\nFollowing the same intuition above, we could further optimize the space complexity of the previous solutions, by replacing the recursion with the iteration.\n\n>More specifically, we iterate through the source and target strings, respectively with a **pointer**.\n\nEach pointer marks a position that we progress on the matching of the characters.\n\n**Algorithm**\n\nWe designate two pointers for iteration, with the `left` pointer referring to the source string and the `right` pointer to the target string.\n\n![two-pointers](../Figures/392/392_two_pointers.png)\n\nWe move the pointers accordingly on the following two cases:\n\n- If `source[left] == target[right]`: we found a match. Hence, we move both pointers one step forward.\n\n- If `source[left] != target[right]`: no match is found. We then move only the right pointer on the target string.\n\nThe iteration would terminate, when either of the pointers exceeds its boundary.\n\nAt the end of the iteration, the result **solely** depends on the fact that whether we have consumed all the characters in the source string.\nIf so, we have found a suitable match for each character in the source string. Therefore, the source string is a subsequence of the target string.\n\n<iframe src=\"https://leetcode.com/playground/ipBoPABP/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"ipBoPABP\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$|S|$$ be the length of the source string, and $$|T|$$ be the length of the target string.\n\n- Time Complexity: $$\\mathcal{O}(|T|)$$\n\n    - The analysis is the same as the previous approach.\n\n- Space Complexity: $$\\mathcal{O}(1)$$\n\n    - We replace the recursion with iteration. In the iteration, a constant memory is consumed regardless of the input.\n\n<br/>\n\n---\n#### Approach 3: Greedy Match with Character Indices Hashmap\n\n**Intuition**\n\nWith the above two approaches under the belt, let us now look at the follow-up question raised in the problem description, which we cite as follows:\n\n>If there are lots of incoming $$S$$, say $$S_1$$, $$S_2$$, ..., and you want to check one by one to see if $$T$$ has its subsequence. In this scenario, how would you change your code?\n\nIn the above scenario, we would expect several incoming source strings, but a constant target string. We are asked to match each of the source strings against the target string.\n\nIf we apply our previous algorithms, for each match, the overall time complexity would be $$\\mathcal{O}(|T|)$$.\n\nIn other words, regardless of the source strings, in the worst case, we have to scan the target string repeatedly, even though the target string remains the same.\n\nNow with the _bottleneck_ identified, we could ask ourselves if we could do something about it.\n\nThe reason why we scan the target string is to **look for** the next character that matches a given character in the source string. In essence, this is a **_lookup_** operation in the array data structure.\n\n>To speed up the lookup operation, the data structure of **_hashmap_** could come in handy, since it has a $$\\mathcal{O}(1)$$ time complexity for its lookup operation.\n\nIndeed, we could build a hashmap out of the target string, with each unique character as key and the indices of its appearance as value.\n\n![hashmap](../Figures/392/392_hashmap.png)\n\nMoreover, we should pre-compute this hashmap once and then reuse it for all the following matches.\n\nWith this hashmap, rather than scanning through the entire target string, we could instantly retrieve all the relevant positions in the target string to look at, given a character from the source string.\n\n**Algorithm**\n\nEssentially, the algorithm with hashmap remains rather similar with our previous approaches, _i.e._ we still need to iterate through the source string to find the matches, and more importantly, we still do the match in the _greedy_ manner.\n\n- First, we build a hashmap out of the target string. Each key is a unique character in the target string, _e.g._ `a`. Its corresponding value would be a list of indices where the character appears in the target string, _e.g._ `[0, 3]`.\n\n- We then iterate through the source string.\n\n- This time, rather than keeping two pointers, we need only one pointer on the _target_ string. The pointer marks our progress on the target string.\n\n- As we've seen from all the previous approaches, the pointer on the target string should move _**monotonically**_, _i.e._ in no case, we would move the pointer to an earlier position.\n\n- We use the pointer to check if an index is suitable or not.\nFor instance, for the character `a` whose corresponding indices are `[0, 3]`, we need to pick an index out of all the appearances as a match.\nSuppose at certain moment, the pointer is located at the index `1`. \nThen, the suitable _greedy_ match would be the index of `3`, which is the first index that is larger than the current position of the target pointer.\n\n\n<iframe src=\"https://leetcode.com/playground/XcBpwvut/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XcBpwvut\"></iframe>\n\n**Optimization**\n\nAs one might notice, we added a last touch to the above algorithm to make it faster.\n\nGiven a list of indices for a matched character, in order to find the suitable index, we could simply do the **_linear search_** as we did in the above Java implementation. \n\nSince the list of indices is ordered, due to the process of construction, we could also apply the **_binary search_** on the list to locate the desired index faster.\nAs a comparison, we implemented this in the Python implementation. \n\nNow hopefully, no one is puzzled with the keyword of _binary search_ from the hints of the problem.\n\n**Complexity Analysis**\n\nLet $$|T|$$ be the length of the target string, and $$|S|$$ be the length of the source string.\n\n- Time Complexity: $$\\mathcal{O}(|T| + |S| \\cdot \\log{|T|})$$.\n\n    - First of all, we build a hashmap out of the target string, which would take $$\\mathcal{O}(|T|)$$ time complexity. But if we redesign the API to better fit the scenario of the follow-up question, we should put the construction of the hashmap in the constructor of the class, which should be done only once. The cost of this construction would be amortized by the following calls of string matches.\n\n    - As the second part of the algorithm, we scan through the source string, and lookup the corresponding indices in the hashmap. The lookup operation in hashmap is constant.\n    However, to find the suitable index would take either $$\\mathcal{O}(|T|)$$ with the linear search or $$\\mathcal{O}(\\log{|T|})$$ with the binary search. To summarize, this part would be bounded by $$\\mathcal{O}(|S| \\cdot \\log{|T|})$$.\n\n    - As one can see, the second part heavily depends on the distribution of the characters in the target string. If the characters are distributed evenly, the entries in the hashmap would have a shorter list of indices, which in return would shorten the search time.\n    But in general, one could consider the approach with hashmap should be faster than the two-pointers approach, although their time complexities say otherwise.\n\n- Space Complexity: $$\\mathcal{O}(|T|)$$\n\n    - We built a hashmap that consists of the indices for each character in the target string. Hence, the size of values (indices) in hashmap would be $$|T|$$. In the worst case, we might have as many keys as the values, _i.e._ each character corresponds to a unique index. In total, the space complexity of the hashmap would be $$\\mathcal{O}(|T|)$$.\n<br/>\n\n---\n#### Approach 4: Dynamic Programming\n\n**Intuition**\n\nBased on the description of the problem, it reminds us of a well-known problem called [Edit Distance](https://leetcode.com/problems/edit-distance/) on LeetCode, which is also known as [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance).\n\nThe problem of _edit distance_ is to find the _minimal_ number of edit operations to convert one string to another string.\nThe permitted operations are _deletion_, _insertion_ and _replacement_.\n\n>Intuitively, one can consider our subsequence problem as a simplified _edit distance_ with only the _deletion_ operation.\n\nThe classic solution to solve the edit distance problem is to apply the __*dynamic programming*__ technique.\nSimilarly, we should be able to solve our problem here with dynamic programming as well.\n\n**Algorithm**\n\nWith dynamic programming, essentially we build a matrix (`dp[row][col]`) where each element in the matrix represents the maximal number of deletions that we can have between a prefix of `source` string and a prefix of the target string, namely `source[0:col]` and `target[0:row]`. \n\n![dp table](../Figures/392/392_dp_table.png)\n\nIn the above graph, we show an example of the `dp` matrix. For instance, for the element of `dp[2][3]` as we highlighted, it indicates that the maximal number of deletions (_i.e._ matches) that we can have between the source prefix `ac` and the target prefix `abc` is 2.\n\nSuppose that we can obtain this dp matrix, the problem becomes simple.\n\n>Once we have the dp matrix, it boils down to see if we can have as many deletions as the number of characters in the source string, _i.e._ if we could consume the entire source string with the matches from the target string.\n\nIn other words, it suffices to examine the last row of the dp matrix (`dp[len(source)]`), to see if there is any number that is equal to the length of the source string.\n\nIn the following animation, we show how to calculate each element in the dp matrix.\n\n!?!../Documents/392_LIS.json:1000,361!?!\n\nSince the problem of _edit distance_ is a hard one and so with its solution, we invite you to check out our article of [edit distance](https://leetcode.com/articles/edit-distance/), which explains the solution in details.\n\nHere we present a modified version of the edit distance solution, based on the above idea.\n\n<iframe src=\"https://leetcode.com/playground/eJZvtPun/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"eJZvtPun\"></iframe>\n\n\n\n**Complexity Analysis**\n\nLet $$|T|$$ be the length of the target string, and $$|S|$$ be the length of the source string.\n\n- Time Complexity: $$\\mathcal{O}(|S| \\cdot |T|)$$\n\n    - We build a matrix of size $$|S| \\cdot |T|$$. In the worst case, we would need to iterate through each element in the matrix. Therefore, the overall time complexity of the algorithm is $$\\mathcal{O}(|S| \\cdot |T|)$$.\n\n    - It is not necessarily the case that we have to iterate through the entire matrix. As one notices, we do have an early exit condition while we fill the values in the matrix.\n\n    - Generally speaking, the dynamic programming algorithms tend to be faster than other solutions, since it reuses the intermediate solutions rather than recalculating them. However, it is not the case here.\n\n    - The DP solution here tries to calculate the solutions for all combinations of prefixes between the source and target strings. \n    As a result, it is less efficient than the _Greedy_ approach which has the time complexity of $$\\mathcal{O}(|T|)$$.\n\n\n- Space Complexity: $$\\mathcal{O}(|S| \\cdot |T|)$$, since we build a matrix of size $$|S| \\cdot |T|$$.\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "895",
            "count": 93,
            "average": "4.796",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "is-subsequence",
    "playgroundData": {
        "5o3nCzxu": {
            "playground": {
                "testcaseInput": "",
                "name": "is-subsequence-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "ipBoPABP": {
            "playground": {
                "testcaseInput": "",
                "name": "is-subsequence-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "XcBpwvut": {
            "playground": {
                "testcaseInput": "",
                "name": "is-subsequence-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "eJZvtPun": {
            "playground": {
                "testcaseInput": "",
                "name": "is-subsequence-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}