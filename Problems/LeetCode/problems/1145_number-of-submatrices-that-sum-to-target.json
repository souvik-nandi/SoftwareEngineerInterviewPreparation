{
    "id": "1145",
    "question": {
        "questionId": "1145",
        "questionFrontendId": "1074",
        "boundTopicId": null,
        "title": "Number of Submatrices That Sum to Target",
        "titleSlug": "number-of-submatrices-that-sum-to-target",
        "content": "<p>Given a <code>matrix</code>&nbsp;and a <code>target</code>, return the number of non-empty submatrices that sum to <font face=\"monospace\">target</font>.</p>\n\n<p>A submatrix <code>x1, y1, x2, y2</code> is the set of all cells <code>matrix[x][y]</code> with <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.</p>\n\n<p>Two submatrices <code>(x1, y1, x2, y2)</code> and <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> are different if they have some coordinate&nbsp;that is different: for example, if <code>x1 != x1&#39;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The four 1x1 submatrices that only contain 0.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1,-1],[-1,1]], target = 0\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[904]], target = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matrix.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>\n\t<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 1614,
        "dislikes": 38,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[[0,1,0],[1,1,1],[0,1,0]]\n0\n[[1,-1],[-1,1]]\n0\n[[904]]\n0",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Matrix",
                "slug": "matrix",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Prefix Sum",
                "slug": "prefix-sum",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Quora\", \"slug\": \"quora\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def numSubmatrixSumTarget(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {number}\n */\nvar numSubmatrixSumTarget = function(matrix, target) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @param {Integer} target\n# @return {Integer}\ndef num_submatrix_sum_target(matrix, target)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func numSubmatrixSumTarget(_ matrix: [[Int]], _ target: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func numSubmatrixSumTarget(matrix [][]int, target int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def numSubmatrixSumTarget(matrix: Array[Array[Int]], target: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun numSubmatrixSumTarget(matrix: Array<IntArray>, target: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @param Integer $target\n     * @return Integer\n     */\n    function numSubmatrixSumTarget($matrix, $target) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function numSubmatrixSumTarget(matrix: number[][], target: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (num-submatrix-sum-target matrix target)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec num_submatrix_sum_target(Matrix :: [[integer()]], Target :: integer()) -> integer().\nnum_submatrix_sum_target(Matrix, Target) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec num_submatrix_sum_target(matrix :: [[integer]], target :: integer) :: integer\n  def num_submatrix_sum_target(matrix, target) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"49.9K\", \"totalSubmission\": \"75.2K\", \"totalAcceptedRaw\": 49895, \"totalSubmissionRaw\": 75167, \"acRate\": \"66.4%\"}",
        "hints": [
            "Using a 2D prefix sum, we can query the sum of any submatrix in O(1) time.\r\nNow for each (r1, r2), we can find the largest sum of a submatrix that uses every row in [r1, r2] in linear time using a sliding window."
        ],
        "solution": {
            "id": "926",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[0,1,0],[1,1,1],[0,1,0]]\n0",
        "metaData": "{\n  \"name\": \"numSubmatrixSumTarget\",\n  \"params\": [\n    {\n      \"name\": \"matrix\",\n      \"type\": \"integer[][]\"\n    },\n    {\n      \"name\": \"target\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  },\n  \"manual\": false\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "988",
            "date": "2022-07-18",
            "incompleteChallengeCount": 14,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "926",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Prerequisites\n\nIn this section, we list some problems and concepts that could help with \nthe resolution of this particular problem.\n\n**[Optional] Number of Subarrays that Sum to Target**\n\nIn this solution we're going to reduce this 2D problem to a 1D one\n[Subarray Sum Equals k](https://leetcode.com/problems/subarray-sum-equals-k/).\n\nOne of the best solutions for this 1D problem is to use a hashmap \nwith key as prefix sum and value as number of subarrays starting from index zero and\nhaving this particular sum value.\n\nIf you don't remember this idea well, you may want to check \nApproach 4 in the above article to make reading this article easier.\n\n**[Required] 2D Prefix Sum**\n\nMany problems could be solved using so-called [prefix sum](https://en.wikipedia.org/wiki/Prefix_sum).\n\nIn one dimension it's simple: there is an array of numbers \n$$x_0, x_1, x_2, ..., x_n$$ and we're building a second array which is a sum\nof prefixes of the input array:\n\n$$\nP_0 = x_0 \\\\\nP_1 = x_0 + x_1 \\\\\n... \\\\\nP_n = x_0 + x_1 + x_2 + ... + x_n\n$$\n\nHere is how it looks like, we sum up the current value with all values \non the left:\n\n![append](../Figures/1074/1d_prefix3.png)\n\n> In 2D the idea is basically the same: prefix sum $$P_{mn}$$ is a sum \nof the current value with the integers above or on the left. \n\n$$\nP_{mn} = \\sum\\limits_{i = 0}^{i = m}\\sum\\limits_{j = 0}^{j = n}{x_{ij}}\n$$\n\n![append](../Figures/1074/2d_prefix.png)\n\nPrefix sum could be computed in $$\\mathcal{O}(R \\times C)$$ time,\nwhere $$R$$ is the number of rows and $$C$$ is the number of columns.\n\n<iframe src=\"https://leetcode.com/playground/xmpEesyz/shared\" frameBorder=\"0\" width=\"100%\" height=\"157\" name=\"xmpEesyz\"></iframe>\n\nUsing a 2D prefix sum, we can now query the sum of any submatrix in $$\\mathcal{O}(1)$$ time.\n<br /> \n<br />\n\n\n---\n#### Overview: Reduce 2D Problem to 1D\n\nLet's fix two rows: $$r_1$$ and $$r_2$$, and consider all \"prefix\" matrices which are using \nall rows from $$r_1$$ to $$r_2$$.\n\n![append](../Figures/1074/all_matrices3.png)\n\nUsing 2D prefix sum `ps`, one could easily get the sum of each prefix matrix:\n`curr_sum = ps[r2][col] - ps[r1 - 1][col]`. \n\nThis sum itself could be considered as a 1D prefix sum because when rows are fixed,\nthere is just one parameter to play with: the column `col`.\n\nThe job is done! The problem is reduced to the 1D problem \n[Number of Subarrays that Sum to Target](https://leetcode.com/problems/subarray-sum-equals-k/),\nand to underline the similarity, let's reuse the code from Approach 4 of this 1D problem.\n\n<iframe src=\"https://leetcode.com/playground/5AprNfeV/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"5AprNfeV\"></iframe>\n\nWe've got pretty nice combination here:\n\n- Use 2D prefix sum to reduce the problem to lots of smaller 1D problems.\n\n- Use 1D prefix sum to solve these 1D problems. \n<br /> \n<br />\n\n\n---\n#### Approach 1: Number of Subarrays that Sum to Target: Horizontal 1D Prefix Sum \n\n![append](../Figures/1074/all_matrices3.png)\n\n**Algorithm**\n\n- Initialize the result: `count = 0`.\n\n- Compute the number of rows: `r = len(matrix)` and number of columns:\n`c = len(matrix[0])`.\n\n- Compute 2D prefix sum `ps`. To simplify the code, \nwe allocate one more row and one more column, reserving row 0 and column 0 \nfor zero values. This way, we avoid computing the first row and the first column\nseparately.\n\n- Iterate over the rows: r1 from 1 to r, and r2 from r1 to r:\n    \n    - Inside this double loop, the left and right row boundaries are fixed. \n    Now it's time to initialize a hashmap: 1D prefix sum -> number of matrices which\n    use `[r1, r2]` rows and sum to this prefix sum. \n    Sum of empty matrix is equal to zero: `h[0] = 1`.\n    \n    - Iterate over the columns from 1 to c + 1. At each step:\n    \n        - Compute current 1D prefix sum `curr_sum` using \n        previously computed 2D prefix sum `ps`: `curr_sum = ps[r2][col] - ps[r1 - 1][col]`.\n        \n        - The number of times the sum `curr_sum - target` occurred,\n        defines the number of matrices which use `r1 ... r2` rows and sum to target.\n        Increment the count: `count += h[curr_sum - target]`.\n        \n        - Add the current 1D prefix sum into hashmap.\n        \n- Return `count`.\n\n**Implementation**\n\n!?!../Documents/1074_LIS_test.json:1000,408!?!\n\n<iframe src=\"https://leetcode.com/playground/8DpFS3RT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"8DpFS3RT\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(R^2 C)$$,\nwhere $$R$$ is the number of rows and $$C$$ is the number of columns.\n\n* Space complexity: $$\\mathcal{O}(RC)$$ to store 2D prefix sum.  \n<br /> \n<br />\n\n\n---\n#### Approach 2: Number of Subarrays that Sum to Target: Vertical 1D Prefix Sum \n\nIn Approach 1, we were fixing two rows, and computing the \"horizontal\" 1D prefix sum.\nOne could follow the same logic by fixing two **_columns_**, and computing the \"vertical\"\n1D prefix sum.\n\n![append](../Figures/1074/vertical_matrices2.png)\n\n**Algorithm**\n\n- Initialize the result: `count = 0`.\n\n- Compute the number of rows: `r = len(matrix)` and the number of columns:\n`c = len(matrix[0])`.\n\n- Compute 2D prefix sum `ps`. To simplify the code, \nwe allocate one more row and one more column, reserving row 0 and column 0 \nfor zero values.\n\n- Iterate over the columns: c1 from 1 to c, and c2 from c1 to c:\n    \n    - Inside this double loop, the upper and lower column boundaries are fixed. \n    Now it's time to initialize a hashmap: 1D prefix sum -> number of matrices which\n    use `[c1, c2]` columns and sum to this prefix sum. \n    Sum of empty matrix is equal to zero: `h[0] = 1`.\n    \n    - Iterate over the rows from 1 to r + 1. At each step:\n    \n        - Compute current 1D prefix sum `curr_sum` using \n        previously computed 2D prefix sum `ps`: `curr_sum = ps[row][c2] - ps[row][c1 - 1]`.\n        \n        - The number of times the sum `curr_sum - target` occurred,\n        defines the number of matrices which use `c1 ... c2` rows and sum to target.\n        Increment the count: `count += h[curr_sum - target]`.\n        \n        - Add the current 1D prefix sum into hashmap.\n        \n- Return `count`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/BYei5gVm/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"BYei5gVm\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(R C^2)$$,\nwhere $$R$$ is the number of rows and $$C$$ is the number of columns.\n\n* Space complexity: $$\\mathcal{O}(RC)$$ to store 2D prefix sum.  \n<br /> \n<br />",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "874",
            "count": 57,
            "average": "4.596",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "number-of-submatrices-that-sum-to-target",
    "playgroundData": {
        "xmpEesyz": {
            "playground": {
                "testcaseInput": "",
                "name": "number-of-submatrices-that-sum-to-target-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "5AprNfeV": {
            "playground": {
                "testcaseInput": "",
                "name": "number-of-submatrices-that-sum-to-target-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "8DpFS3RT": {
            "playground": {
                "testcaseInput": "",
                "name": "number-of-submatrices-that-sum-to-target-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "BYei5gVm": {
            "playground": {
                "testcaseInput": "",
                "name": "number-of-submatrices-that-sum-to-target-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}