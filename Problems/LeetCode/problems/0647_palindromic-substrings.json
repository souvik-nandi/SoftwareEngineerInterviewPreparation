{
    "id": "647",
    "question": {
        "questionId": "647",
        "questionFrontendId": "647",
        "boundTopicId": null,
        "title": "Palindromic Substrings",
        "titleSlug": "palindromic-substrings",
        "content": "<p>Given a string <code>s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</p>\n\n<p>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaa&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 7504,
        "dislikes": 164,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Longest Palindromic Substring\", \"titleSlug\": \"longest-palindromic-substring\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Palindromic Subsequence\", \"titleSlug\": \"longest-palindromic-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "\"abc\"\n\"aaa\"",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 14}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Twitter\", \"slug\": \"twitter\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Docusign\", \"slug\": \"docusign\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Walmart Global Tech\", \"slug\": \"walmart-labs\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"SAP\", \"slug\": \"sap\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 0}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int countSubstrings(string s) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int countSubstrings(String s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def countSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint countSubstrings(char * s){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int CountSubstrings(string s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar countSubstrings = function(s) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef count_substrings(s)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func countSubstrings(_ s: String) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func countSubstrings(s string) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def countSubstrings(s: String): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun countSubstrings(s: String): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn count_substrings(s: String) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function countSubstrings($s) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function countSubstrings(s: string): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (count-substrings s)\n  (-> string? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec count_substrings(S :: unicode:unicode_binary()) -> integer().\ncount_substrings(S) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec count_substrings(s :: String.t) :: integer\n  def count_substrings(s) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"470.3K\", \"totalSubmission\": \"714K\", \"totalAcceptedRaw\": 470252, \"totalSubmissionRaw\": 713978, \"acRate\": \"65.9%\"}",
        "hints": [
            "How can we reuse a previously computed palindrome to compute a larger palindrome?",
            "If \u201caba\u201d is a palindrome, is \u201cxabax\u201d a palindrome? Similarly is \u201cxabay\u201d a palindrome?",
            "Complexity based hint:</br>\r\nIf we use brute force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation?"
        ],
        "solution": {
            "id": "1065",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "\"abc\"",
        "metaData": "{\n  \"name\": \"countSubstrings\",\n  \"params\": [\n    {\n      \"name\": \"s\",\n      \"type\": \"string\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "921",
            "date": "2022-05-22",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1065",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### A Brief Refresher\n\n**What is a palindrome?**\n\nA palindrome is a sequence of characters that read the same, forwards and backwards. If you tried reversing a palindrome, you wouldn't see a change. For example, the string \"kayak\" is a palindrome, but the word \"livid\" isn't one.\n\n**There are two types of palindromes...**\n\nOdd and even length palindromes!\n\nOdd-length palindromes have a single character in the middle. e.g. \"civic\" with middle character 'v'.\n\nEven-length palindromes have two characters constitute the middle, both of which are same. e.g. \"noon\" with two middle characters 'o'.\n\n> Pop Quiz: Is \"y\" a palindrome? Is \"gg\" a palindrome?\n\nYes, both of the above are palindromes. \"y\" is single letter (hence odd-length) palindrome whose middle is the single 'y' character. \"gg\" is a double letter (hence even-length) palindrome whose middle is comprised of the two 'g' characters.\n\n**Palindromes are compositionally homogeneous around their center...**\n\nIn layman's terms, smaller palindromes make up larger palindromes. If you take the palindrome \"eve\" and surround it with the character 'l', you get a larger palindrome \"level\". Conversely, if you removed the starting and ending characters from \"eve', you'd be left with the smaller, single-character palindrome \"v\".\n\n---\n#### Approach #1: Check All Substrings\n\n**Intuition**\n\nJust do what the question says! We look at all substrings of the input string and check if they are palindromes.\n\n\n**Algorithm**\n\nEach substring is denoted by a pair of variables pointing to the start and end indices of the sub-string. \n\n> A single character substring is denoted by start and end indices being equal in value.\n\nChecking for a palindrome is simple; we check if the ends of the substring are the same character, going outside-in:\n+ If they aren't, this substring is not a palindrome. \n+ Else, we continue checking inwards until we get to the middle.\n\n<iframe src=\"https://leetcode.com/playground/9Nn77q8j/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"9Nn77q8j\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $O(N^3)$ for input string of length $N$.  \n    Since we just need to traverse every substring once, the total time taken is sum of the length of all substrings.\n\n    In a string of length $N$, then there are:\n    + $N$ substrings of size $1$.\n    + $N-1$ substrings of size $2$.\n    + $N-2$ substrings of size $3$.\n    + ...\n    + $1$ substring of size $N$ (which is the entire string).\n\n    Total time taken to traverse all of these strings is in the order of \n    \n    $$\n    \\begin{aligned}\n\n    &1 \\cdot (N) + 2 \\cdot (N-1) + 3 \\cdot (N-2) + ... + N \\cdot (1) \\\\\n    &= N + 2(N-1) + 3(N-2) + ... + N(N - (N-1)) \\\\\n    &= (N + 2N + 3N + ... + N^2) - (2 + (3 \\times 2) + (4 \\times 3) + ... + (N \\times (N-1))) \\\\\n    &= N \\sum_{i = 1}^{N} i \\ - \\ \\sum_{i=1}^{N} i \\cdot (i-1) \\\\\n\n    \\end{aligned}\n    $$\n\n    The term $\\sum_{i=1}^{N} i \\cdot (i-1)$  can we written as $\\sum_{i=1}^{N} i^2 - \\sum_{i=1}^{N} i$, which transforms the aforementioned expression to\n\n    $$\n    \\begin{aligned}\n\n    &N \\sum_{i = 1}^{N} i \\ - \\ \\sum_{i=1}^{N} i^2 \\ + \\ \\sum_{i=1}^{N} i \\\\\n    &= (N+1) \\sum_{i = 1}^{N} i \\ - \\ \\sum_{i=1}^{N} i^2 \\\\\n    &= \\frac{N(N+1)^2}{2} \\ - \\ \\frac{N(N+1)(2N+1)}{6} \\\\\n    &= \\frac{N(N+1)^2}{6} \\simeq N^3\n\n    \\end{aligned}\n    $$\n\n* Space Complexity: $O(1)$. We don't need to allocate any extra space since we are repeatedly iterating on the input string itself.\n\n---\n\n#### Approach #2: Dynamic Programming\n\n**Intuition**\n\n[Approach #1](#approach-1-check-all-substrings) spent a lot of time checking if a particular substring is a palindrome. What if we could speed up this check, by say, reusing previously calculated results? Turns out that checking whether a string is a palindrome or not, is a good candidate for dynamic programming!\n\nIt displays the _two, **necessary** characteristics_ of a dynamic programming problem:\n\n1. **Optimal substructure**: Remember that larger palindromes are made of smaller palindromes. Congratulation, we have discovered a substructure to our problem! Knowing that a string is made up of a palindrome _helps_ us determine if the string itself is a palindrome.\n\n    Here's an example: for the string \"axbobxa\", the first and the last characters match, so it's a potential palindrome. If we knew already that its substring \"xbobx\" is also a palindrome, there wouldn't be a need for any further checks.\n\n    > But is this substructure optimal?\n    \n    Yes! Since the optimal result for a string relies only on the optimal result for just one subproblem, and has to do just one check for the boundary characters (in constant time), this is an optimal substructure. We cannot get this result by checking fewer than one subproblem (it wouldn't be a substructure anymore) _or_ doing the boundary characters check faster (it's already constant time!).\n\n2. **Overlapping sub-problems**: While checking all substrings of a large string for palindromicity, we might need to check some smaller substrings for the same, repeatedly. If we store the result of processing those smaller substrings, we can reuse those while processing larger substrings.\n\n    Here's an example: for the string \"axbobxa\", the substring \"bob\" needs to checked for the substring \"xbobx\" and the string \"axbobxa\". In fact, to check all three of these strings, the single character string \"o\" needs to be checked.\n\n**Algorithm**\n\nHere's the simple framework for our dynamic programming solution:\n\n1. Define the dynamic programming _state_. This is the result that gets reused in further computations.\n    \n    Let's define our state $\\text{dp(i, j)}$, which tells us whether the substring composed of the $i^{th}$ to the $j^{th}$ characters of the input string, is a palindrome or not.\n\n    Thus, the answer to our problem lies in counting all substrings whose state is _true_.\n\n2. Identify the _base cases_. There are essentially two base-cases:\n    + Single letter substrings are palindromes by definition. i.e. $dp(i, i) = true$\n    + Double letter substrings composed of the same character are palindromes. i.e.\n    $$\n    dp(i,i+1) = \\begin{cases}\n        true &\\text{if \\space \\space} s_i = s_{i+1} \\\\\n        false &\\text{otherwise}\n    \\end{cases}\n    $$\n\n3. Identify the *optimal substructure*. A string is considered a palindrome if:\n    + Its first and last characters are equal, and\n    + The rest of the string (excluding the boundary characters) is also a palindrome.\n\n    This optimal substructure can be formulated into a recurrence rule: \n    $$\n    dp(i,j) = \\begin{cases}\n        true &\\text{if \\space \\space} dp(i+1, j-1) \\land (s_i = s_j) \\\\\n        false &\\text{otherwise}\n    \\end{cases}\n    $$\n\n4. Identify *overlapping sub-problems* and compute them only once. The optimal substructure mentioned above ensures that the state for a string depends only on the state for a single substring. If we compute (and save) the states for all smaller strings first, larger strings can be processed by reusing previously saved states. The base cases that we have identified already define states for single and double letter strings. We can use those to compute states for three character (and subsequently larger) strings.\n\n5. The answer is found by counting all states that evaluate _true_. Since each state tells whether a unique substring is a palindrome or not, counting _true_ states provides us the number of palindromic substrings. \n\n<iframe src=\"https://leetcode.com/playground/W4fjMbKc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"W4fjMbKc\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $O(N^2)$ for input string of length $N$. The number of dynamic programming states that need to calculated is the same as the number of substrings i.e. ${N \\choose 2} = N(N-1)/2$. Each state can be calculated in constant time using a previously calculated state. Thus overall time take in the order of $O(N^2)$.\n\n* Space Complexity: $O(N^2)$ for an input string of length $N$. We need to allocate extra space to hold all $N \\choose 2$ dynamic programming states.\n    \n> Pop Quiz: Can you reduce the space consumption of this approach to linear extra space (i.e. $O(N)$)?\n\nYes, it's possible! Notice that the states of a subsbtring of length $n$ actually rely only on states for substrings of length $n-2$. Thus, we can choose to store only the states for substrings of length $n-1$ and $n-2$ for an iteration of susbtrings of length $n$, which takes only $O(N)$ extra space. All states older than those can be discarded in that iteration. The next approach builds on this insight.\n\n---\n\n#### Approach #3: Expand Around Possible Centers\n\n**Intuition**\n\n> Palindromes are like onions, you remove the boundary characters and you're left with another, smaller palindrome. \n\nMultiple palindromes have the same centers. If we choose a center, we can continue to expand around it as long as we can make larger and larger palindromes.\n\nLet's take the string \"lever\" as an example: if you choose the character 'v' as the center, one can see that the palindromes \"v\" and \"eve\" are possible. However, the final expansion \"lever\" is not a palindrome (the first and last characters don't match).\n\n**Algorithm**\n\n1. We choose all possible centers for potential palindromes:\n    + Every single character in the string is a center for possible odd-length palindromes\n    + Every pair of consecutive characters in the string is a center for possible even-length palindromes.\n\n2. For every center, we can expand around it as long as we get palindromes (i.e. the first and last characters should match).\n\n<iframe src=\"https://leetcode.com/playground/9qy7uV5c/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9qy7uV5c\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $O(N^2)$ for input string of length $N$. The total time taken in this approach is dictated by two variables:\n    + The number of possible palindromic centers we process.\n    + How much time we spend processing each center.\n\n    The number of possible palindromic centers is $2N-1$: there are $N$ single character centers and $N-1$ consecutive character pairs as centers.\n\n    Each center can potentially expand to the length of the string, so time spent on each center is linear on average. Thus total time spent is $N \\cdot (2N-1) \\simeq N^2$.\n\n* Space Complexity: $O(1)$. We don't need to allocate any extra space since we are repeatedly iterating on the input string itself.\n\n---\n\n#### Further Thoughts\n\nBetter approaches do exist to solve this problem in sub-quadratic time, however those are significantly complex and impractical to implement in most interviews. \n\nSome known approaches are:\n\n1. **Binary Search with a fast rolling hash algorithm (like Rabin-Karp).** This approach tries to optimize [Approach #3](#approach-3-expand-around-possible-centers) by speeding up the time to figure out the largest palindrome for each of the $2N-1$ centers in logarithmic time. This approach counts all palindromic substrings in $O(N \\log{N})$ time. [Here's a Quora answer by T.V. Raziman](https://qr.ae/pNkBDo) which explains this approach well.\n\n2. **Palindromic trees (also known as [EERTREE](https://arxiv.org/abs/1506.04862)).** It is a data structure invented by Mikhail Rubinchik which links progressively larger palindromic substrings within a string. The tree construction takes linear time, and the number of palindromic substrings can be counted while constructing the tree in $O(N)$ time. Additionally, the tree can be used to compute how many distinct palindromic substrings are in a string (it's just the number of nodes in the tree) and how frequently each such palindrome occurs. [This blog post](http://adilet.org/blog/palindromic-tree/https://medium.com/@alessiopiergiacomi/eertree-or-palindromic-tree-82453e75025b) does a good job of explaining the construction of a palindromic tree.\n\n3. **Suffix Arrays with quick Lowest common Ancestor (LCA) lookups.** This approach utilizes Ukonnen's algorithm to build suffix trees for the input string and its reverse in linear time. Subsequently, quick LCA lookups can be used to find maximum palindromes, which are themselves composed of smaller palindromes. This approach can produce a count of all palindromic substrings in $O(N)$ time. [The original paper](http://par.cse.nsysu.edu.tw/~algo/paper/paper06/A24.pdf) describes the algorithm, and [this Quora answer](https://qr.ae/pNkEWR) demonstrates an example.\n\n3. **Manacher's algorithm.** _It's basically [Approach #3](#approach-3-expand-around-possible-centers), on steroids._<sup>TM</sup> The algorithm reuses computations done for previous palindromic centers to process new centers in sub-linear time (which reduces progressively for each new center). This algorithm counts all palindromic substrings in $O(N)$ time. [This e-maxx post](https://cp-algorithms.com/string/manacher.html) provides a fairly simple implementation of this algorithm.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1020",
            "count": 374,
            "average": "4.965",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "palindromic-substrings",
    "playgroundData": {
        "9Nn77q8j": {
            "playground": {
                "testcaseInput": "",
                "name": "palindromic-substrings-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "W4fjMbKc": {
            "playground": {
                "testcaseInput": "",
                "name": "palindromic-substrings-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "9qy7uV5c": {
            "playground": {
                "testcaseInput": "",
                "name": "palindromic-substrings-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}