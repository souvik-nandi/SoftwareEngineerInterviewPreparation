{
    "id": "1052",
    "question": {
        "questionId": "1052",
        "questionFrontendId": "1057",
        "boundTopicId": null,
        "title": "Campus Bikes",
        "titleSlug": "campus-bikes",
        "content": "<p>On a campus represented on the X-Y plane, there are <code>n</code> workers and <code>m</code> bikes, with <code>n &lt;= m</code>.</p>\n\n<p>You are given an array <code>workers</code> of length <code>n</code> where <code>workers[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> is the position of the <code>i<sup>th</sup></code> worker. You are also given an array <code>bikes</code> of length <code>m</code> where <code>bikes[j] = [x<sub>j</sub>, y<sub>j</sub>]</code> is the position of the <code>j<sup>th</sup></code> bike. All the given positions are <strong>unique</strong>.</p>\n\n<p>Assign a bike to each worker. Among the available bikes and workers, we choose the <code>(worker<sub>i</sub>, bike<sub>j</sub>)</code> pair with the shortest <strong>Manhattan distance</strong> between each other and assign the bike to that worker.</p>\n\n<p>If there are multiple <code>(worker<sub>i</sub>, bike<sub>j</sub>)</code> pairs with the same shortest <strong>Manhattan distance</strong>, we choose the pair with <strong>the smallest worker index</strong>. If there are multiple ways to do that, we choose the pair with <strong>the smallest bike index</strong>. Repeat this process until there are no available workers.</p>\n\n<p>Return <em>an array </em><code>answer</code><em> of length </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the index (<strong>0-indexed</strong>) of the bike that the </em><code>i<sup>th</sup></code><em> worker is assigned to</em>.</p>\n\n<p>The <strong>Manhattan distance</strong> between two points <code>p1</code> and <code>p2</code> is <code>Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png\" style=\"width: 376px; height: 366px;\" />\n<pre>\n<strong>Input:</strong> workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]\n<strong>Output:</strong> [1,0]\n<strong>Explanation:</strong> Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/03/06/1261_example_2_v2.png\" style=\"width: 376px; height: 366px;\" />\n<pre>\n<strong>Input:</strong> workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]\n<strong>Output:</strong> [0,2,1]\n<strong>Explanation:</strong> Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == workers.length</code></li>\n\t<li><code>m == bikes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= m &lt;= 1000</code></li>\n\t<li><code>workers[i].length == bikes[j].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt; 1000</code></li>\n\t<li><code>0 &lt;= x<sub>j</sub>, y<sub>j</sub> &lt; 1000</code></li>\n\t<li>All worker and bike locations are <strong>unique</strong>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 868,
        "dislikes": 161,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Campus Bikes II\", \"titleSlug\": \"campus-bikes-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[[0,0],[2,1]]\n[[1,2],[3,3]]\n[[0,0],[1,1],[2,0]]\n[[1,0],[2,2],[2,1]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Greedy",
                "slug": "greedy",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Sorting",
                "slug": "sorting",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 2}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int[] assignBikes(int[][] workers, int[][] bikes) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def assignBikes(self, workers, bikes):\n        \"\"\"\n        :type workers: List[List[int]]\n        :type bikes: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> List[int]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* assignBikes(int** workers, int workersSize, int* workersColSize, int** bikes, int bikesSize, int* bikesColSize, int* returnSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int[] AssignBikes(int[][] workers, int[][] bikes) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[][]} workers\n * @param {number[][]} bikes\n * @return {number[]}\n */\nvar assignBikes = function(workers, bikes) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[][]} workers\n# @param {Integer[][]} bikes\n# @return {Integer[]}\ndef assign_bikes(workers, bikes)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func assignBikes(_ workers: [[Int]], _ bikes: [[Int]]) -> [Int] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func assignBikes(workers [][]int, bikes [][]int) []int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def assignBikes(workers: Array[Array[Int]], bikes: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun assignBikes(workers: Array<IntArray>, bikes: Array<IntArray>): IntArray {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn assign_bikes(workers: Vec<Vec<i32>>, bikes: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[][] $workers\n     * @param Integer[][] $bikes\n     * @return Integer[]\n     */\n    function assignBikes($workers, $bikes) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function assignBikes(workers: number[][], bikes: number[][]): number[] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (assign-bikes workers bikes)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof exact-integer?))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec assign_bikes(Workers :: [[integer()]], Bikes :: [[integer()]]) -> [integer()].\nassign_bikes(Workers, Bikes) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec assign_bikes(workers :: [[integer]], bikes :: [[integer]]) :: [integer]\n  def assign_bikes(workers, bikes) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"61.6K\", \"totalSubmission\": \"106.4K\", \"totalAcceptedRaw\": 61584, \"totalSubmissionRaw\": 106397, \"acRate\": \"57.9%\"}",
        "hints": [
            "<p>Sort the elements by distance. In case of a tie, sort them by the index of the worker. After that, if there are still ties, sort them by the index of the bike.</p>\r\n\r\n<p>Can you do this in less than O(nlogn) time, where n is the total number of pairs between workers and bikes?</p>",
            "Loop the sorted elements and match each pair of worker and bike if the given worker and bike where not used."
        ],
        "solution": {
            "id": "1308",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[[0,0],[2,1]]\n[[1,2],[3,3]]",
        "metaData": "{\r\n  \"name\": \"assignBikes\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"workers\",\r\n      \"type\": \"integer[][]\"\r\n    },\r\n    {\r\n      \"name\": \"bikes\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer[]\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "862",
            "date": "2022-03-15",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1308",
        "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nWe have $$n$$ workers and $$m$$ bikes. We need to assign each worker a bike and since $$m \\geq n$$ it's always possible to do so. We are instructed to make the above assignments in the ascending order of the following parameters:\n\n1. Manhattan Distance\n2. Worker Index\n3. Bike Index\n\nFirst, we will check the Manhattan distance between each worker and each bike and prioritize the `(worker, bike)` pairs with smaller Manhattan distances. If multiple pairs have the same distance, we will go on to check the worker index and prioritize pairs with smaller worker indices. If the worker index is also the same, we prioritize pairs with lower bike indices. Two `(worker, bike)` pairs cannot have all the three attributes the same, so these three attributes are enough to ensure a unique solution. Therefore, the problem boils down to sorting the `(worker, bike)` pairs in the order as explained above while keeping track of which workers and bikes have been assigned.\n</br>\n\n---\n\n#### Approach 1: Sorting\n\n\n**Intuition**\n\nAs discussed, we want to organize the `(worker, bike)` pairs in ascending order, prioritizing their Manhattan distance, then worker index, and then bike index. Therefore, we will generate all possible `(worker, bike)` pairs and sort them according to the previously listed priorities. We will then iterate over the pairs, if both the worker and bike are available, assign the bike to the worker, and mark them both as unavailable. We will repeat this process until all workers have been assigned a bike.\n\n**Algorithm**\n\n1. Generate all the `(worker, bike)` pairs, and for each pair find the Manhattan distance `distance`. Store these three attributes in the tuple as `{distance, worker index, bike index}`. In Java, we use the defined type `WorkerBikePair` to store these three attributes.\n2. Store all the generated triplets in `allTriplets` which is the list of tuples (or `WorkerBikePair` in the case of Java).\n3. Sort the list `allTriplets` in ascending order of their distance, worker index, and then bike index. In  C++ & Python we can use the default behavior of sorting in the order of the attributes by storing them as `{distance, worker index, bike index}` inside the tuple. While In Java we will explicitly define the custom comparator `WorkerBikePairComparator` to sort accordingly.\n4. Iterate over the list `allTriplets`, and for each triplet:\n  \n    - If the worker has not been assigned a bike (`workerStatus[workerIndex]` is `-1`), and the bike is still available (`bikeStatus[bike]` is `false`). Then assign the bike to the worker and mark them both as unavailable. Increment the number of pairs in the variable `pairCount`.\n    - If all the workers have been assigned a bike (`pairCount` is equal to the number of workers) we can stop iterating over the pairs.\n5. Return `workerStatus`.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/EFvVbdRo/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"EFvVbdRo\"></iframe>\n\n\n**Complexity Analysis**\n\nHere, $$N$$ is the number of workers, and $$M$$ is the number of bikes.\n\n* Time complexity: $$O(NM \\log (NM))$$\n\n   There will be a total of $$NM$$ `(worker, bike)` pairs. Sorting a list of $$NM$$ elements will cost $$O(NM \\log (NM))$$ time. In the worst case, we have to iterate over all the pairs to assign each worker a bike. Thus, iterating over these pairs costs $$O(NM)$$ time. Since the time complexity for sorting is the dominant term, the time complexity is $$O(NM \\log (NM))$$.\n\n* Space complexity: $$O(NM)$$\n\n  `WorkerBikePair` or the tuple has three variables, hence taking $$O(1)$$ space. Storing $$NM$$ `WorkerBikePairs` or tuples in `allTriplets` will cost $$O(NM)$$ space. To track the availability of the bikes `bikeStatus` takes $$O(M)$$ space. Storing bikes index corresponding to worker index in `workerStatus` takes $$O(N)$$ space. \n\n  The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, the Arrays.sort() for primitives is implemented as a variant of quicksort algorithm whose space complexity is $$O(\\log NM)$$. In C++ sort() function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort and has a worst-case space complexity of $$O(\\log NM)$$. In Python sort() function uses TimSort which has a worst-case space complexity of $$O(NM)$$. Thus, the use of the inbuilt sort() function might add up to $$O(NM)$$ to space complexity.\n\n  The total space required is $$(NM + N + M + NM)$$ hence, the complexity is equal to $$O(NM)$$.\n<br/>\n\n---\n\n#### Approach 2:  Bucket Sort\n\n\n**Intuition**\n\nAs stated in the problem description, there can be at most `1000` workers and at most `1000` bikes, which means we could potentially have $$10^6$$ `(worker, bike)` pairs. If we closely observe the problem constraints, the coordinates for both bike and worker are in the range `[0, 1000)`. Therefore, the maximum Manhattan distance that is possible between a worker, and a bike is `1998`. This maximum value is possible when one of the bike/workers is at `(0, 0)` and the other entity worker/bike is at `(999, 999)`. \n \nAs discussed earlier, we want the `(worker, bike)` pairs in ascending order of their distance, and distance could be in range `[0, 1998]`. Remember, when we have input distributed over a known **short** range, we can use bucket sort. In bucket sort, we distribute the elements into an array of buckets and then sort each bucket individually. So instead of sorting a large number of pairs, we can group the pairs by distance, then sort each group individually. Thus, iterating over the buckets in ascending order and for each bucket, iterating over the sorted contents will be equivalent to iterating over a sorted list of all pairs.\n\nAside from implementing bucket sort, this approach is the same as the previous approach. We will still sort all of the pairs, but this time we will first group them by their distance and sort each group individually. Then, to arrange the pairs in ascending order, we simply iterate over the possible distances in ascending order.\n\n**Note**: Our goal is to order the pairs according to distance first, then worker index, then bike index. Grouping the pairs by distance allows us to iterate over the groups of pairs in ascending order of distance. In bucket sort, normally, our next step is to sort each bucket to ensure that the `{worker index, bike index}` pairs are in ascending order within each bucket. However, when creating these pairs, we iterated over the worker indices in ascending order and then over the bike indices in ascending order. So it is guaranteed that the pairs are already in ascending order within each bucket! Thus, each bucket does not need to be sorted.\n\n**Algorithm**\n\n1. Generate all the `(worker, bike)` pairs, and for each pair, find the Manhattan distance, `distance`. Add this pair to the list `disToPairs` corresponding to the index `distance`.\n2. Among all the pairs generated, store the minimum distance in the variable `minDis`.\n3. Initialize `currDis` to `minDis`. Until all the workers have been assigned a bike, do the following:\n   - Iterate over the pairs with distance `currDis`\n   - If the worker and bike are available, assign the bike to the worker in the list `workerStatus` and mark the bike unavailable in `bikeStatus`. Increment the value of `pairCount` which is the value of worker-bike pairs that have been made.\n   - Once all the pairs with the current distance have been traversed, increment the value of `currDis`.\n4. Return `workerStatus`.\n\n**Implementation**\n\n\n<iframe src=\"https://leetcode.com/playground/6mwHGbvi/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"6mwHGbvi\"></iframe>\n\n\n**Complexity Analysis**\n\nHere, $$N$$ is the number of workers, $$M$$ is the number of bikes, and $$K$$ is the maximum possible Manhattan distance of a worker/bike pair. In this problem, $$K$$ equals $$1998$$.\n\n* Time complexity: $$O(NM + K)$$\n   \n   Generating all the `(worker, bike)` pairs takes $$O(NM)$$ time. We are iterating over the generated pairs in the while loop according to their distance. Hence, at most, we will iterate over all $$NM$$ pairs. But since there could be some `currDis` values at which no pairs exist, hence these operations have to be counted as well. The total possible values for `currDis` is $$K$$. Hence the time complexity equals $$O(NM + K)$$\n\n* Space complexity: $$O(NM + K)$$\n\n  We store all the pairs corresponding to their distance in `disToPairs`, which requires $$O(NM)$$ space. To track the availability of the bikes `bikeStatus` takes $$O(M)$$ space. Storing the index of the bike each worker is assigned in `workerStatus` takes $$O(N)$$ space. Also, note that in `C++` implementation, we have defined an array of size $$K$$. Hence, even if there are fewer than $$K$$ pairs, it will still cost $$O(K)$$ space.\n\n<br/>\n\n---\n\n#### Approach 3: Priority Queue\n\n\n**Intuition**\n\nAs discussed earlier, we need `(worker, bike)` pairs in ascending order. One way is to put all the $$n\\cdot m$$ `workerBikePair ({worker index, bike index, distance})` in a min-heap, and then we can keep popping from the heap to fetch the shortest Manhattan distance pair. The drawback here is that we have $$n \\cdot m$$ pairs to choose the first pair from. However, we can discard some of the pairs without ever inserting them into the priority queue. Consider the first worker who will receive a bike. We don't need to push all the pairs for this worker corresponding to all the bikes. Instead, we could just put the one pair corresponding to the closest bike because the other pairs cannot be the pair with the smallest Manhattan distance.\n\nIn this approach, we will find the closest bike for each worker and put their corresponding `workerBikePair` (or tuple in the case of C++) in the priority queue. Thus, we will have at most $$n$$ elements in the priority queue at any given time instead of $$n \\cdot m$$. This way, we can omit `(worker, bike)` pairs that are not the potential candidates for the shortest Manhattan distance.\n\nNow, among these $$n$$ elements (one element for each worker), the one with the shortest Manhattan distance will be on top. Hence, we will pop it, and if the bike in this element is not taken, we will assign the bike to the worker. In case, the bike in the pair we popped is already assigned to a different worker, we will discard this pair and push a new pair (that is the next closest bike to this worker) into the priority queue. This way, the priority queue will always have the smallest distance pair for each remaining worker. We will continue to pop from the priority queue until all the workers have been assigned a bike.\n\nEssentially we made a sorted list of bikes for each worker according to the Manhattan distance. Thus, we have sorted lists of size $$m$$ for each of the $$n$$ workers. We need to merge precisely one element from each of these $$n$$ sorted lists. Hence, we will insert the first element from each of the $$n$$ lists into a priority queue and pop the minimum element. If the bike in the popped pair is available, then we will assign it to the worker in the pair. Otherwise, we insert the next pair in the sorted list for the worker in the popped pair. This is very similar to what we do in merge sort when combining two sorted lists. The only difference is that we have $$n$$ lists, and we need to track the availability of bikes.\n\nThe below slideshow demonstrates the algorithm:\n\n!?!../Documents/1057_Campus_bikes.json:960,720!?! <br>\n\n**Algorithm**\n\n**Note:** We have a different implementation for C++ & Python than Java owing to the absence of any standard Tuple library in Java. Hence, we have covered the algorithm separately for C++/Python & Java.\n\n**Java**\n\n1. Iterate over workers and for each worker:\n   - Find the distance from each bike. Store the bike and distance information as defined type `WorkerBikePair` (`{distance, bike index}`) in the list `currWorkerPairs`.\n   - Sort the list `currWorkerPairs` using the custom comparator `WorkerBikePairComparator`.\n   - Store the above list corresponding to the worker as `workerToBikeList[worker] = currWorkerPairs`\n   - In the list `closestBikeIndex`, set the closest bike index for this worker to `0`, as `closestBikeIndex[worker] = 0`.\n   - Call the `addClosestBikeToPq` function, in this function we:\n     - Fetch the closest bike for the worker. The closest bike index is present at `closestBikeIndex[worker]`. Thus, the closest bike pair can be accessed as `workerToBikeList[worker][closestBikeIndex[worker]]`.\n     - Insert the above `WorkerBikePair` into the priority queue `pq`.\n     - Increment the value of `closestBikeIndex[worker]`. This value now points to the next closest bike for this worker.\n2. Until the priority queue is not empty:\n   - Pop the top element from `pq`.\n   - If the bike is available, assign it to the worker in the list `workerStatus` and mark the bike unavailable in `bikeStatus`.\n   - If the bike is unavailable, call the `addClosestBikeToPq` for the current worker.\n3. Return `workerStatus`.\n   \n**C++/Python**\n\n1. Iterate over workers and for each worker:\n   - Find the distance from each bike. Store the bike and distance information as a tuple `{distance, worker index, bike index}` in the list of tuples `currWorkerPairs`.\n   - Sort the list `currWorkerPairs` in reverse order. The reason we sort in reverse order is so that the `(worker, bike)` pair with minimum value (in order of distance, then worker index, then bike index) will be present at the end of the sorted list. So getting the next closest bike for a worker only requires popping the last element from the sorted list.\n   - Store the above list corresponding to the worker as `workerToBikeList[worker] = currWorkerPairs`\n   - Fetch the tuple corresponding to the closest bike for the worker. The closest bike is present at `currWorkerPairs.back()`. \n   - Insert the above tuple into the priority queue `pq`.\n   - Pop the last element from `currWorkerPairs` to get the next closest bike to this worker.\n2. While the priority queue is not empty:\n   - Pop the top element from `pq`.\n   - If the bike is available, assign it to the worker in the list `workerStatus` and mark the bike unavailable in `bikeStatus`.\n   - If the bike is unavailable, push the next closest bike for the current worker into the `pq`, and pop the last element from the sorted list for the current worker. \n3. Return `workerStatus`.\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/hDrShuqQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"hDrShuqQ\"></iframe>\n\n**Complexity Analysis**\n\nHere, $$N$$ is the number of workers, and $$M$$ is the number of bikes.\n\n* Time complexity: $$O(NM \\log M)$$\n\n   We iterate over the $$N$$ workers and for each worker:\n    \n     - Sorting the list of $$M$$ bikes `currWorkerPairs` takes $$O(M \\log M)$$.\n     - Add the next closest bike to `pq`. Insertion in `pq` takes $$O(\\log N)$$.\n\n    Thus, the time complexity up to this point is $$O(NM \\log M)$$.\n\n   In the worst case, the total number of pop operations from the `pq` in the while loop can be $$O(N^2)$$. This is because, for `ith` worker, its first `i-1` closest bike might have already been taken by previous workers. Hence, the first worker will get its first closest bike, the second worker gets its second-closest bike and so on. This way, the number of pop operations in the `pq` will be equal to `1 + 2 + 3 + 4 ...... N = (N * (N - 1)) / 2`.\n\n  In each while loop operation, we are popping and pushing into the priority queue, which takes $$O(\\log N)$$. Thus, the time complexity here is $$O(N^2 \\log N)$$.\n\n   Therefore, the total time complexity is $$O(NM \\log M + N^2 \\log N)$$. Since we know, $$M \\geq N$$, the complexity can be written as $$O(NM \\log M)$$.\n\n* Space complexity: $$O(NM)$$\n  - `workerToBikeList` store the list of $$M$$ bikes for each $$N$$ worker, hence it takes $$O(NM)$$. \n  - `bikeStatus` takes $$O(M)$$ space. \n  - `workerStatus` takes $$O(N)$$ space.\n  - `pq` will store at most $$N$$ elements.\n\n  Hence, the total space complexity is equal to $$O(NM)$$.\n<br/>\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1313",
            "count": 16,
            "average": "5.000",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "campus-bikes",
    "playgroundData": {
        "EFvVbdRo": {
            "playground": {
                "testcaseInput": "",
                "name": "campus-bikes-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "6mwHGbvi": {
            "playground": {
                "testcaseInput": "",
                "name": "campus-bikes-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "hDrShuqQ": {
            "playground": {
                "testcaseInput": "",
                "name": "campus-bikes-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}