{
    "id": "1762",
    "question": {
        "questionId": "1762",
        "questionFrontendId": "1642",
        "boundTopicId": null,
        "title": "Furthest Building You Can Reach",
        "titleSlug": "furthest-building-you-can-reach",
        "content": "<p>You are given an integer array <code>heights</code> representing the heights of buildings, some <code>bricks</code>, and some <code>ladders</code>.</p>\n\n<p>You start your journey from building <code>0</code> and move to the next building by possibly using bricks or ladders.</p>\n\n<p>While moving from building <code>i</code> to building <code>i+1</code> (<strong>0-indexed</strong>),</p>\n\n<ul>\n\t<li>If the current building&#39;s height is <strong>greater than or equal</strong> to the next building&#39;s height, you do <strong>not</strong> need a ladder or bricks.</li>\n\t<li>If the current building&#39;s height is <b>less than</b> the next building&#39;s height, you can either use <strong>one ladder</strong> or <code>(h[i+1] - h[i])</code> <strong>bricks</strong>.</li>\n</ul>\n\n<p><em>Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/27/q4.gif\" style=\"width: 562px; height: 561px;\" />\n<pre>\n<strong>Input:</strong> heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 &gt;= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7.\n- Go to building 3 without using ladders nor bricks since 7 &gt;= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n<strong>Output:</strong> 7\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [14,3,19,3], bricks = 17, ladders = 0\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= bricks &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= ladders &lt;= heights.length</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 3666,
        "dislikes": 78,
        "isLiked": null,
        "similarQuestions": "[]",
        "exampleTestcases": "[4,2,7,6,9,14,12]\n5\n1\n[4,12,2,7,3,18,20,3,19]\n10\n2\n[14,3,19,3]\n17\n0",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Greedy",
                "slug": "greedy",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Heap (Priority Queue)",
                "slug": "heap-priority-queue",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 8}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 3}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Media.net\", \"slug\": \"medianet\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 4}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def furthestBuilding(self, heights, bricks, ladders):\n        \"\"\"\n        :type heights: List[int]\n        :type bricks: int\n        :type ladders: int\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int FurthestBuilding(int[] heights, int bricks, int ladders) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} heights\n * @param {number} bricks\n * @param {number} ladders\n * @return {number}\n */\nvar furthestBuilding = function(heights, bricks, ladders) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} heights\n# @param {Integer} bricks\n# @param {Integer} ladders\n# @return {Integer}\ndef furthest_building(heights, bricks, ladders)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func furthestBuilding(_ heights: [Int], _ bricks: Int, _ ladders: Int) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func furthestBuilding(heights []int, bricks int, ladders int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def furthestBuilding(heights: Array[Int], bricks: Int, ladders: Int): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun furthestBuilding(heights: IntArray, bricks: Int, ladders: Int): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn furthest_building(heights: Vec<i32>, bricks: i32, ladders: i32) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $heights\n     * @param Integer $bricks\n     * @param Integer $ladders\n     * @return Integer\n     */\n    function furthestBuilding($heights, $bricks, $ladders) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function furthestBuilding(heights: number[], bricks: number, ladders: number): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (furthest-building heights bricks ladders)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec furthest_building(Heights :: [integer()], Bricks :: integer(), Ladders :: integer()) -> integer().\nfurthest_building(Heights, Bricks, Ladders) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec furthest_building(heights :: [integer], bricks :: integer, ladders :: integer) :: integer\n  def furthest_building(heights, bricks, ladders) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"98.2K\", \"totalSubmission\": \"203.8K\", \"totalAcceptedRaw\": 98183, \"totalSubmissionRaw\": 203777, \"acRate\": \"48.2%\"}",
        "hints": [
            "Assume the problem is to check whether you can reach the last building or not.",
            "You'll have to do a set of jumps, and choose for each one whether to do it using a ladder or bricks. It's always optimal to use ladders in the largest jumps.",
            "Iterate on the buildings, maintaining the largest r jumps and the sum of the remaining ones so far, and stop whenever this sum exceeds b."
        ],
        "solution": {
            "id": "1061",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[4,2,7,6,9,14,12]\n5\n1",
        "metaData": "{\n  \"name\": \"furthestBuilding\",\n  \"params\": [\n    {\n      \"name\": \"heights\",\n      \"type\": \"integer[]\"\n    },\n    {\n      \"type\": \"integer\",\n      \"name\": \"bricks\"\n    },\n    {\n      \"type\": \"integer\",\n      \"name\": \"ladders\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "956",
            "date": "2022-06-21",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1061",
        "content": "[TOC] \n\n## Solution\n\n---\n\n#### Overview\n\nThis is one of my favorite questions on LeetCode. There are several very different approaches for solving it; each requires looking at the problem from a slightly different angle. I've covered five approaches in this article. The first and second are closely related and are the \"standard\" solutions to this problem. The third is quite different, and the fourth is a clever optimization of the third. The fifth approach is an optional extra aimed at those keen on a good challenge.\n\nRemember that to best prepare for your interviews, you should look at multiple ways of solving problems. For this problem, I recommend that, at a minimum, you look at approaches 1 and 3. In addition to that, I also recommend trying to code up approach 2 as independently as you can to help you ensure you understood approach 1. \n\n*Warning: The \"greedy solution\" mentioned on the forum does not work!*\n\nWhen this question was first released, the test cases were not adequate and allowed an incorrect greedy algorithm with a time complexity of $$O(N)$$ (where $$N$$ is the number of buildings) and a space complexity of $$O(1)$$ to pass. I've not included this algorithm here, as it's incorrect, and there is no shortage of forum posts on it anyway.\n\nUnfortunately, this has meant, at least at the time of writing this article, that a lot of the sample solutions for the lower runtimes are buggy, and there are numerous incorrect forum posts. It also means that it\u2019s very difficult to write a correct algorithm that gets a good comparative run time, as it has to compete against the numerous incorrect submissions.\n\n<br/>\n\n---\n\n#### Approach 1: Min-Heap\n\n**Intuition**\n\nTo get started, here's an example where it's actually possible to get all the way across. You have `8` bricks, `2` ladders, and heights `[2, 7, 9, 3, 1, 2, 5, 9, 4, 6]`. Determine where to put the bricks and ladders before reading further (remember, you do *not* need to use bricks or ladders to go *down*).\n\n![The buildings for the example described above.](../Figures/1642/example_1.png)\n\nIf you solved the problem correctly, this is what you will have gotten.\n\n![The solution for the above example.](../Figures/1642/example_1_solution.png)\n\nWe'll refer to movements between buildings where a ladder or bricks are needed as climbs.\n\nYou might have already realized that the best strategy is to use the ladders for the longest climbs and the bricks for the shortest climbs. This shouldn\u2019t seem too surprising; a ladder is most valuable in the cases where we would have to use a lot of bricks.\n\nThe above example was made easy by me telling you that it was possible to get all the way across. Given an input, determining whether or not it is possible to go *all the way across* is an easy problem; you could simply make a list of all the *climbs*, min-sort the list, and then cover as many climbs as you can with bricks, and then cover the rest with ladders. If this covered the entire climb list, then you\u2019d know that it was possible to get all the way across.\n\nHowever, this problem requires determining *how far* we can get. We don't know which climbs we need to cover because we don't know the final building we can reach.\n\nThe solution is to move along the buildings sequentially, one climb at a time. At all times, we should ensure ladders have been allocated to the longest climbs seen *so far* and bricks to the shortest. This might sometimes involve going back and changing an earlier allocation.\n\nThe simplest way of doing this is to begin by using all of the available ladders; in the example we're working with, recall that you have `2` ladders. Once you've made `2` climbs (ignoring the places where you could jump down), you know that you've allocated your `2` ladders to the `2` longest climbs you've seen *so far*. What should you do next to ensure that the ladders remain on the `2` longest climbs?\n\n![Figure at building 5](../Figures/1642/walkthrough_1.png)\n\nYou should use a brick; this next climb is smaller than either of the ladder climbs. \n\nHow about the next climb?\n\n![Figure at building 6](../Figures/1642/walkthrough_2.png)\n\nFor this climb, you should replace the second ladder with 2 bricks and then use the reclaimed ladder.\n\n![Figure at building 7](../Figures/1642/walkthrough_3.png)\n\nTo do the next climb, you'll need to either use bricks or reclaim a ladder by replacing one of the earlier ladder climbs with bricks.\n\nThis strategy should be repeated until we reach the final building, or we can't go any further (i.e., there aren't enough bricks to do the next climb or replace a previous ladder). Here is an animation of it in action.\n\n!?!../Documents/1642_approach_1_animation.json:960,480!?!\n\n**Algorithm**\n\nThe outer loop of the algorithm needs to iterate over all climbs, going from left to right.\n\nTo find all climbs, we'll need to check the difference between each adjacent (side-by-side) pair of buildings to see if there is a climb there *or* a jump down/ walk across. Remember, we only need to put a ladder or bricks on the actual climbs. Here is the pseudocode to do that.\n\n```text\ndefine function furthestBuilding(heights, bricks, ladders):\n    for each i from 0 to heights.length - 2 (including the end point):\n        current_height = heights[i]\n        next_height = heights[i + 1]\n        difference = next_height - current_height\n        if difference is 0 or difference is negative:\n            continue to next iteration (jumping down is free)\n        otherwise, difference is a climb \n```\n\nThis code loops over all buildings, starting from the first and ending at the second-to-last. For each building, it calculates the difference between the next building and itself. If this difference is non-positive, then we know this is **not** a climb and therefore should be skipped. Otherwise, it's a climb that we will need to allocate bricks or a ladder to.\n\nNote that when you code this bit up, you'll need to be quite careful; it's very easy to make off-by-one errors here if you're inexperienced. There are `N` buildings, but there are only `N - 1` gaps between them. Make sure your code isn't trying to define a gap *stating* from the last building.\n\nAnyway, the next thing to do is to decide how we're going to handle the allocation of ladders and bricks. We decided above that the strategy we'll use is to use a ladder if we have one available. If we're out of ladders, we'll replace the most wasteful ladder allocation with bricks. In code, this means we'll need a data structure that we can insert climbs into, and then when needed, retrieve the smallest climb. The data structure we use for this is a **heap**, also known as a **priority queue**. \n\n> Recall that a **heap** is a data structure that allows us to efficiently perform two operations: inserting items with a priority and retrieving and/or removing the item with the highest priority. In some cases, such as this problem, the priority is calculated from the inserted item itself with a priority function, removing the need for an explicit priority to be inserted.\n\nWe refer to a heap that simply returns the smallest item as a **min-heap**.\n\nPutting all of the logic we've discussed so far into pseudocode, you would get something like this.\n\n```text\ndefine function furthestBuilding(heights, bricks, ladders):\n    ladder_allocations = a new min heap\n    for each i from 0 to heights.length - 2 (including the end point):\n        current_height = heights[i]\n        next_height = heights[i + 1]\n        difference = next_height - current_height\n        if difference is 0 or difference is negative:\n            continue\n        rename difference to climb\n        if there are ladders remaining:\n            add climb to ladder_allocations\n            subtract 1 from ladders\n        else: (There are no ladders remaining)\n            smallest_ladder_allocation = peek at the minimum in ladder_allocations\n            if smallest_ladder_allocation is null or climb is smaller:\n                subtract climb from bricks\n            else: (smallest_ladder_allocation is smaller)\n                pop smallest_ladder_allocation from ladder_allocations\n                add climb to ladder_allocations\n                subtract smallest_ladder_allocation from bricks\n            if bricks is now negative:\n                return i (we didn't have enough bricks to climb to i + 1)\n    return heights.length - 1 (we must have covered all of the climbs)\n```\n\nEssentially, we allocate a ladder if one is available. Otherwise, we look at the smallest ladder allocation in the heap. If the heap is empty or the current climb is shorter than the smallest in the heap, we subtract bricks for this climb. Otherwise, we reclaim a ladder from the smallest ladder allocation in the heap and subtract bricks to replace the ladder. If this results in bricks going negative, then we must not have had enough bricks to go any further.\n\nThis algorithm would be acceptable for you to now code up; however, there is a nicer way that we can design the algorithm that removes most of the conditionals. \n\n> Coming up with these really elegant designs is a skill that takes practice, so don't worry too much if your own code is a bit longer.\n\n```text\ndefine function furthestBuilding(heights, bricks, ladders):\n    ladder_allocations = a new min heap\n    for each i from 0 to heights.length - 2 (including the end point):\n        current_height = heights[i]\n        next_height = heights[i + 1]\n        difference = next_height - current_height\n        if difference is 0 or difference is negative:\n            continue\n        rename difference to climb\n        add climb to ladder_allocations\n        if climbs in ladder_allocations is now greater than ladders:\n            smallest_ladder_allocation = remove minimum from ladder_allocations\n            subtract smallest_ladder_allocation from bricks\n            if bricks is now negative:\n                return i (we didn't have enough bricks to climb to i + 1)\n    return heights.length - 1 (we must have covered all of the climbs)\n```\n\nOn each iteration, we always add the current climb to the heap. If this causes the heap to become larger than the number of ladders available, then we need to remove the smallest climb from the heap (which could be the one just inserted) and replace it with bricks. If there aren't enough bricks for that, then we can't go any further.\n\nThis algorithm is a lot better, as we no longer have to handle the empty-heap case, and we don't have to handle the current climb needing bricks as a special case. Like I said, though, don't worry too much if you didn't come up with it on your own; practice makes perfect (and it wasn't the first version I wrote either)!\n\n**Code**\n\n<iframe src=\"https://leetcode.com/playground/ZGMbcLaQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ZGMbcLaQ\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the `heights` array. Let $$L$$ be the number of ladders available. We're mostly going to focus on analyzing in terms of $$N$$; however, it is also interesting to look at how the number of ladders available impacts the time and space complexity. \n\n- Time complexity : $$O(N \\log N)$$ or $$O(N \\log L)$$.\n\n    Inserting or removing an item from a heap incurs a cost of $$O(\\log x)$$, where $$x$$ is the number of items currently in the heap. In the worst case, we know that there will be $$N - 1$$ climbs in the heap, thus giving a time complexity of $$O(\\log N)$$ for each insertion and removal, and we're doing up to $$N$$ of each of these two operations. This gives a total time complexity of $$O(N \\log N)$$. \n\n    In practice, though, the heap will never contain more than $$L + 1$$ climbs at a time\u2014when it gets to this size, we immediately remove a climb from it. So, the heap operations are actually $$O(\\log L)$$. We are still performing up to $$N$$ of each of them, though, so this gives a total time complexity of $$O(N \\log L)$$. \n\n- Space complexity : $$O(N)$$ or $$O(L)$$.\n\n    As we determined above, the heap can contain up to $$O(L)$$ numbers at a time. In the worst case, $$L = N$$, so we get $$O(N)$$.\n    \n<br/>\n\n---\n\n#### Approach 2: Max-Heap\n\n**Intuition**\n\nThis approach is similar to Approach 1, except instead of initially allocating ladders, we allocate bricks. When we run out of bricks, we replace the *longest* climb with a ladder. This was in contrast to before when we were replacing the *shortest* climb with bricks. Because we now need to retrieve maximums instead of minimums, we should use a **max-heap** instead of a min-heap.\n\nYou should have a go at coding up this approach by yourself before reading any further; it's a good exercise to ensure you understood approach 1.\n\n**Algorithm**\n\nIn addition to replacing the min-heap with a max-heap, we also need to keep track of how many bricks we've used so far (as we can't simply check the current size of the heap like we did in Approach 1). The simplest way of doing this is to subtract from the `bricks` input parameter and check for when it goes to zero. Here is the pseudocode for this approach.\n\n\n```text\ndefine function furthestBuilding(heights, bricks, ladders):\n    bricks_allocations = a new max heap\n    for each i from 0 to heights.length - 2 (including the end point):\n        current_height = heights[i]\n        next_height = heights[i + 1]\n        difference = next_height - current_height\n        if difference is 0 or difference is negative:\n            continue (this is a jump)\n        rename difference to climb\n        add climb to brick_allocations\n        subtract climb from bricks\n        if bricks is not negative:\n            continue (this climb is fine for now)\n        if ladders is zero:\n            return i (we can't get to i + 1)\n        largest_brick_allocation = remove maximum from brick_allocations\n        add largest_brick_allocation onto bricks\n        subtract one from ladders\n    return heights.length - 1 (we must have covered all of the climbs)\n```\n\nLike how we first tried to use a ladder in approach 1, in this approach, we first try to allocate bricks; this requires adding the climb to the heap and subtracting the climb from `bricks`. If `bricks` is still non-negative after doing this, then there is nothing else we need to do for this climb right now, so we continue onto the next one.\n\nIf, however, `bricks` has become negative, then we'll need to make `bricks` positive again by reclaiming some bricks; we do this by removing the largest brick allocation from the heap and subtracting 1 from `ladders` to cover the removed brick allocation. This works because one of two cases is true; either there's a previous climb with more bricks to reclaim, or we've just added the largest climb onto the max-heap. So when we remove the maximum from the max-heap, we'll definitely get at least as many bricks as we just subtracted to make `bricks` non-negative again.\n\nThe only case we can't simply replace the largest brick allocation with a ladder happens when `ladders` is already zero. In this case, we know we can't jump to the next building index and so should return the current building index. In the pseudocode, we've firstly checked for this case and then gone onto the process described above for making `bricks` non-negative.\n\n**Code**\n\n<iframe src=\"https://leetcode.com/playground/gvs2qqK5/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gvs2qqK5\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the `heights` array. Unlike approach 1, it doesn't really make sense to analyze approach 2 in terms of the number of `ladders` or `bricks` we started with.\n\n- Time complexity : $$O(N \\log N)$$.\n\n    Same as Approach 1. In the worst case, we'll be adding and removing up to $$N - 1$$ climbs from the heap. Heap operations are $$O(\\log N)$$ in the worst case.\n\n- Space complexity : $$O(N)$$.\n\n    Same as Approach 1. In the worst case, there'll be $$N - 1$$ climbs in the heap.\n\n<br/>\n\n---\n\n#### Approach 3: Binary Search for Final Reachable Building\n\n**Intuition**\n\nIn Approach 1, we made the following observation.\n\n> Given an input, determining whether or not it is possible to go *all the way across* is an easy problem; you could simply make a list of all the *climbs*, min-sort it, and then cover as many climbs as you can with bricks, and then cover the rest with ladders. If this covered the entire climb list, then you\u2019d know that it was possible to get all the way across.\n\nMore generally, this implies that *given a specific building*, we can easily determine whether or not we have enough bricks and ladders to reach it (starting from the first building). For example, if you have 9 bricks and 4 ladders, can you reach building 8 on this example?\n\n![An example showing building 8 highlighted](../Figures/1642/example_2_building_8_highlighted.png)\n\nHow about reaching building 15? (Again, with 9 bricks and 4 ladders)\n\n![An example showing building 15 highlighted](../Figures/1642/example_2_building_15_highlighted.png)\n\nIf you solved these examples correctly, you would have found that the answer was \"yes\" for reaching building 8 but \"no\" for reaching building 15.\n\nNow, remembering that our goal is to find the furthest building reachable with a given quantity of bricks and ladders, a possible (but inefficient) algorithm would be to iterate backward through the list of buildings, checking whether or not each is reachable. The first one we find that is reachable has to be the furthest building we can reach and so should be returned.\n\nUnfortunately, though, this algorithm will be too slow. Remember that determining reachability for a given building requires sorting. Doing $$N - 1$$ sorts in the worst case gives an overall time complexity of $$O(N\u00b2 \\log N)$$. \n\nLooking at this algorithm from another angle, it\u2019s actually performing a **linear search**. We are, after all, sequentially going through a list and checking each item until we find the one we\u2019re looking for (the highest-index one that is reachable). Whenever you have an algorithm based on linear search that is too slow, your brain should be jumping straight to thinking about **binary search**. Binary search can be used whenever the list is ***sorted*** *on the property we\u2019re searching for*. \n\nIn this case, that property is simply a boolean \"yes\" or \"no\" for each building that specifies whether or not that building is reachable. For the list to be sorted on this property, either all of the buildings would have to have the same value, or all of one value would have to come after the other. Let's go back to the example that we played around with above. Each building has its corresponding \"yes\" or \"no\" written on it (remember, we had 9 bricks and 4 ladders). \n\n![An example showing reachability stretches to building 12](../Figures/1642/example_2_reachability.png)\n\nThis looks promising; all of the \"yes\" tags are before all of the \"no\" tags. And in fact, we can easily see that this will always be true. For a given case, either all of the buildings are reachable (so it's trivially sorted), or there is some building before the last building that is the *final-reachable-building*. All of the buildings after it have to have a \"no\" (otherwise, it couldn't be the final reachable building), and all of the buildings before it have to have a \"yes\", as we reached them in the process of getting to the *final-reachable-building*. \n\nIn conclusion, we can confidently say that the list is sorted on this property. All of the \"yes\" tags come before any \"no\" tags. And this means that we can use binary search!\n\nIn binary search, we repeatedly halve the search space by checking the building in the middle. If that building is not reachable, then we know that none of the buildings after it are (and therefore they couldn't possibly be the *final-reachable-building*). If the building *is* reachable, then we know that it is the *final-reachable-building*, or some building *after* it is.\n\nWhile we won't look too much at the time complexity yet, it's always worth having a quick think about whether or not an approach is viable before you go too far with it. In this case, recall that binary search is $$O(\\log N)$$. Sorting is $$O(N \\log N)$$. We're going to do a sort for each binary search, so this is looking to be $$O(N \\log\u00b2 N)$$. This isn't too bad, and so it is worth continuing on with. While it is slightly worse than approach 1, it's not by much, and it's still worth looking at as an alternate approach (and in approach 4, we'll look at how we can optimize it a bit more).\n\n**Algorithm**\n\nThere are two main parts to this algorithm: checking whether or not a given building is reachable and using a binary search to decide which buildings to check. The first is easier, so we\u2019ll start with that.\n\nRecall that given a building index, we want to determine whether or not we have enough bricks and ladders to get from the first building to the building with that given index. We do this by firstly making a min-sorted list of all the climbs we'd need to make, and then by allocating bricks to the smallest climbs and ladders once we run out of bricks. If we could cover all the climbs, then we know it is possible to reach the given building.\n\n```text\n\nheights, bricks, and ladders are as specified in the problem\n\ndefine function isReachable(building_index):\n    climbs = a new list\n    for each i between 0 and building_index - 1 (inclusive):\n        climb_distance = heights[i + 1] - heights[i]\n        if climb_distance is positive:\n            add climb_distance to climbs\n    min-sort climbs\n    bricks_remaining = bricks\n    ladders_remaining = ladders\n    for each climb in climbs:\n        if there are enough bricks_remaining for climb:\n            subtract climb from bricks_remaining\n        else if there is at least one ladder left:\n            subtract 1 from ladders_available\n        else:\n            return false\n     return true\n```\n\nNow that we have that out of the way, we need to figure out the details for the Binary search.\n\nBinary search's details easily confuse many programmers, so many become tempted to resort to poor practices such as [Programming by Permutation](https://en.wikipedia.org/wiki/Programming_by_permutation). With that in mind, I'm going to walk you through a methodical way of approaching this problem that also applies to other binary search problems. If you\u2019re already confident with binary search and don't want to walk through it in this level of detail, then you can skip straight to the pseudocode, or ideally, go away and try and code it up on your own. Otherwise, I recommend following really carefully, as this process really does help.\n\n> The importance of being able to methodically design and implement a binary search cannot be understated. You'll almost certainly encounter it in multiple interviews. Focus firstly on your accuracy and then work on your coding speed. While coding fast *and* correctly is the ideal, keep in mind that accuracy is still worth more than speed. Buggy code is bad, no matter how quickly you wrote it.\n\nThese are the questions we'll be answering and then putting into code.\n\n1. What is the target item, value, and type?\n2. What bounds must the target item be within?\n3. What can we conclude when `isReachable(mid)` returns `true` (\"yes\")?\n4. What can we conclude when `isReachable(mid)` returns `false` (\"no\") ?\n5. How do we know when we've found the target item?\n6. Which calculation for `mid` should we use?\n\n*Step 1: What is the target item, value, and type?*\n\nWe want to know which *building* in the `heights` array (i.e., *not* a climb distance) is the *final-reachable-building*. Buildings are identified by indexes in the array; therefore, we're looking for *the index in `heights` that corresponds to the final-reachable-building*. It might sound obvious in this case, but it's always important to pinpoint whether we're looking for an index, between two indexes, or something else entirely.\n\n*Step 2: What bounds must the target item be within?*\n\nThe highest possible index for the *final-reachable-building* is `heights.length - 1` (i.e. the last building in `heights`). In the worst case, the only building we\u2019ll be able to reach is the building at index `0` (which we can always reach). Therefore, the answer could be anywhere from `0` to `heights.length - 1`, *inclusive* of both of these endpoints. In the binary search code, this will be:\n\n```text\nlo = 0\nhi = heights.length - 1\n```\n\n> Notice that we haven't used `hi = heights.length` or `lo = -1`, or anything else like that. People are sometimes tempted to put that stuff in to \"cover edge cases\", handle inclusive vs. exclusive endpoints, etc., without fully understanding what they were trying to achieve with it. It's generally easiest to set `lo` to represent the lowest possible position of the target and `hi` to be the highest possible position.\n\n*Step 3: How do we know when we found the target?*\n\nOften in a binary search, we immediately know when we've found the answer. For example, if the problem was to search for `12` in a sorted array, then as soon as the value at `mid` is `12`, we can return `true`.\n\nFor this problem, though, we can't do that. If the value of `isReachable(mid)` is `true`, then it is *possible* that it is indeed the *final-reachable-building*, but it is also very possible that the *final-reachable-building* is further to the right. Because of this, we should instead shrink the search space down to length-one (i.e., to where `lo = hi`) and then determine whether or not that one item is the one we want. In this case, we know that the target definitely exists, so as soon as the search space is of length-one, the index in it is for the *final-reachable-building*.\n\nWith that, this is what we have so far.\n\n```text\nlo = 0\nhi = heights.length - 1\nwhile lo is less than hi:\n    Details here are still to be decided\nreturn lo\n```\n\n> *Don't* attempt to keep track of the highest `true` so far using an additional variable. It's unnecessary, as we can simply shrink the search space down so that in the end, it only contains the final reachable value.\n\n*Step 4: What can we conclude when `isReachable(mid)` returns `true`?*\n\nIf `isReachable(mid)` returns `true`, then we know that the building at `mid` is reachable. We're no longer interested in any of the buildings *before* `mid`, as they can\u2019t possibly be the *final-reachable-building* (as `mid` is further than them).\n\nWe don't know whether or not the building at `mid + 1` is reachable, though, and nor should we check right now.\n\nRemembering that `lo` and `hi` represent the boundaries of where the *final-reachable-building* could be, we should set `lo = mid`. This means that the building at `mid` is now the lowest building in the search range.\n\n> Setting `lo = mid + 1` would be *incorrect* here because it\u2019s possible that all buildings from `mid + 1` onwards are *not reachable*, and that we\u2019ve just chopped the *final-reachable-building* out of the search space (remember, we want to shrink the search space down to a single index; the index of the *final-reachable-building*).\n\n*Step 5: What can we conclude when `isReachable(mid)` returns `false`?*\n\nIf `isReachable(mid)` returns `false`, then we know that the building at `mid` is *not* reachable. This means that none of the buildings after `mid` could possibly be reachable either. Therefore, the final reachable building must be *before* `mid`; in other words, the highest possible candidate now is `mid - 1`. So we should set `hi = mid - 1`. \n\n> A common mistake here is to simply use `hi = mid` so as to avoid having to reason about whether or not to put the `- 1`. This is very problematic, though, as whenever you\u2019re doing a binary search with the `while lo is less than hi` condition (i.e., reducing the search space to length-one), you must have at least one of `hi = mid - 1` and `lo = mid + 1`. If you have neither of these, then your algorithm might infinitely loop once the search space is of length-two.\n\nUpdating our code with the latest details we've determined, here is what we have so far.\n\n```text\nlo = 0\nhi = heights.length - 1\nwhile lo is less than hi:\n    mid = [formula to be decided]\n    if building at mid is reachable:\n        lo = mid\n    else:\n        hi = mid - 1\nreturn lo\n```\n\n*Step 6: Which calculation for `mid` should we use?*\n\nOn an odd-lengthed search space, identifying the midpoint is straightforward. On even-lengthed search spaces, though, we have two possible midpoints. The final step of the binary search algorithm design process is to decide whether it is the lower or higher midpoint that should be used.\n\nYour decision should be based on how you are updating `hi` and `lo` (i.e., `lo = mid` and `hi = mid - 1` for the algorithm we've designed here). Think about what happens once the search space is of length-two. You must ensure that the search space is guaranteed to be shrunk down to length-one, regardless of which condition is executed. If you take the lower middle, it will sometimes infinitely loop. And if you take the upper middle, it will be guaranteed to shrink the search space down to one.\n\nSo, it is the *upper-middle* that we want.\n\n> The short rule to remember is: if you used `hi = mid - 1`, then use the higher midpoint. If you used `lo = mid + 1`, then use the lower midpoint. If you used both of these, then you can use either midpoint. If you didn\u2019t use either (i.e., you have `lo = mid` and `hi = mid`), then, unfortunately, your code is buggy, and you won\u2019t be able to guarantee convergence.\n\nWhenever we want the *upper middle*, we use either `mid = (lo + hi + 1) / 2` or `mid = lo + (hi - lo + 1) / 2`. These formulas ensure that on even-lengthed search spaces, the *upper middle* is chosen and on odd-lengthed search spaces, the actual middle is chosen.\n\nThis completes our binary search algorithm.\n\n```text\nlo = 0\nhi = heights.length - 1\nwhile lo is less than hi:\n    mid = lo + (hi - lo + 1) / 2\n    if building at mid is reachable:\n        lo = mid\n    else:\n        hi = mid - 1\nreturn lo\n```\n\n**Code**\n\n<iframe src=\"https://leetcode.com/playground/8nYDsadQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"8nYDsadQ\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the `heights` array. \n\n- Time complexity : $$O(N \\log\u00b2 N)$$.\n\n    On an array of length $$N$$, binary search requires $$O(\\log N)$$ iterations to reduce the array down to a single item. On each of these binary search iterations, we're doing a sort. On average, we'll be sorting $$N/2$$ items each time. In Big O notation, though, we can simply treat this as $$N$$. The average cost of sorting is $$O(N \\log N)$$. Putting this together, we get $$O(\\log N) \\cdot O(N \\log N) = O(N \\log\u00b2 N)$$. \n\n- Space complexity : $$O(N)$$.\n\n    For each iteration, we need to make a new list of up to `N - 1` climbs. This gives us a $$O(N)$$ space complexity (the list is discarded at the end of each iteration, so we never have more than one of these lists using memory at the same time).\n\n<br/>\n\n---\n\n#### Approach 4: Improved Binary Search for Final Reachable Building\n\n**Intuition**\n\nThe previous approach had some redundant sorting. We're now going to look very briefly at a neat trick we can do to remove this and reduce the time complexity down to $$O(N \\log N)$$. \n\nIf we were to simply extract all the climbs, put them in a list, and sort them, then `isReachable(...)` would run into the problem of not knowing which climbs are within the relevant range and which are not. The solution to this is surprisingly simple, though: attach an index to each climb in the climbs list. This way, `isReachable(...)` can iterate over the sorted list in the same fashion as before, but with an extra conditional telling it to skip any climbs with an index higher than the index of the building we're checking the reachability of.\n\n**Algorithm**\n\nAt the start, the algorithm needs to make a sorted list of all the climbs. Each climb must have the index it reaches attached to it.\n\n```text\nheights, bricks, and ladders are as specified in the problem\n\nsorted_climbs = a new list\nfor each i between 0 and heights.length - 2 (inclusive):\n    difference = heights[i + 1] - heights[i]\n    if difference is positive:\n        add pair(difference, i + 1) to sorted_climbs\nmin-sort sorted_climbs using the first value (climb distances) of each pair\n```\n\nThe code above only runs **once** for each test case. `sorted_climbs` will be reused by all calls to `isReachable(...)`.\n\nWhile the binary search algorithm stays the same, the implementation of `isReachable(...)` needs to be changed slightly. We no longer need to build and sort a list of climbs within it. We should, instead, use `sorted_climbs` and add an additional check to skip any climbs that are beyond the index we're checking the reachability of.\n\n```text\nheights, bricks, and ladders are as specified in the problem\nsorted_climbs is the list we defined just above\n\ndefine function isReachable(building_index):\n    bricks_remaining = bricks\n    ladders_remaining = ladders\n    for each value in sorted_climbs:\n        climb, index = split value into its two parts\n        if index is greater than building_index:\n            continue to the next iteration\n        if bricks_remaining is at least climb:\n            subtract climb from bricks_remaining\n        else if ladders_remaining greater than 0:\n            subtract 1 from ladders_available\n        else:\n            return false\n     return true\n```\n\nYou may have observed that once we've allocated a ladder, we'll never again allocate bricks (remember, the climbs are sorted. If we don't have enough bricks for the current climb, we definitely won't have enough for the climbs after it!). An alternate algorithm design could be to use two loops; one that allocates bricks and then one that allocates ladders.\n\n**Code**\n\n<iframe src=\"https://leetcode.com/playground/XccxVRai/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XccxVRai\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the `heights` array. \n\n- Time complexity : $$O(N \\log N)$$.\n\n    There are two parts to this algorithm: constructing the sorted climbs list and doing the binary search + reachability checking.\n    \n    Extracting the climbs has a cost of $$O(N)$$ as there are up to $$N - 1$$ of them, and access to them is sequential. Sorting them has a cost of $$O(N \\log N)$$.\n    \n    For this implementation, `isReachable(...)` simply goes down the pre-generated `sorted_climbs` list and performs an $$O(1)$$ operation on each of the up to $$N$$ items. Therefore, it has a cost of $$O(N)$$. \n    \n    Like before, we're calling `isReachable(...)` a total of $$\\log N$$ times, driven by the binary search. So in total, the calls to `isReachable(...)` have a cost of $$O(N \\log N)$$. \n    \n    Because the creation of `sorted_climbs` and the binary search happen sequentially, we *add* their time complexities. $$O(N \\log N) + O(N \\log N) = 2 \\dot O(N \\log N) = O(N \\log N)$$.\n    \n- Space complexity : $$O(N)$$.\n\n    The sorted list of climbs requires $$O(N)$$ space.\n\n<br/>\n\n---\n\n\n#### Approach 5: Binary Search on Threshold (Advanced)\n\n*Note: This approach is almost certainly beyond what would be expected from you in an interview; the other approaches we\u2019ve looked at should be sufficient. It is essentially a \"hard\" solution to a \"medium\" problem. In particular, to understand it, you'll need to be comfortable with mathematical reasoning. Even though you don't need this approach for interviews, working through it will be beneficial to your general problem-solving skills. It is a very cool approach, as it needs no auxiliary memory yet has a good time complexity.*\n\n**Intuition and Algorithm**\n\nIn this final approach, we're going to come up with a way of solving the problem with $$O(1)$$ space and with a comparable time complexity. It involves binary searching for a threshold value representing the shortest climb we should allocate a ladder to (which is also the longest climb we should allocate bricks to) and then examines the solution found to deduce whether it is optimal or whether the threshold was too high or too low. To really understand how and why this approach works, we need to explore and prove various mathematical properties of solutions. I've tried to keep the math as friendly as possible, but keep in mind that this is an **advanced** approach beyond the scope of interviews.\n\n*Characterizing an optimal solution*\n\nAll of our approaches so far have used a strategy of allocating bricks to the shortest climbs and ladders to the longest climbs until no ladders or \"usable\" bricks remained. This guaranteed that **at least one** of the following conditions was true at the end.\n\n- We reached the final building.\n- We were not able to go any further, and there was no way of rearranging bricks or ladders so that we could go any further.\n\nLet's quickly define and prove what we mean by \"we were not able to go any further\". \n\nMore precisely, each of the previous approaches guaranteed that all of the following conditions were true of an optimal solution (in cases where it was not possible to reach the final building).\n\n1. There were no `ladders` remaining, and there were not enough bricks for the next climb.\n2. The number of `bricks` remaining at the end was *less than* the length of the shortest climb to use a ladder.\n3. The longest climb to use bricks was shorter than, or equal to, the shortest climb to use a ladder.\n\nIntuitively, these all make sense. Condition 1 ensures that we don't have enough bricks or ladders left to simply do the next climb, condition 2 ensures that we can't use our remaining bricks to reclaim an earlier ladder and then use that to go further, and condition 3 ensures that we can't reclaim bricks or a ladder by rearranging our earlier allocations. If any of these conditions weren't true, then there could be a way of doing an additional climb, thus contradicting the assertion that this solution is optimal.\n\n> Interestingly, the third condition isn't strictly necessary for a solution to be optimal. In some cases, there is more than one way of allocating bricks and ladders to get to the *final-reachable-index*. But there is always at least one optimal solution that *does* satisfy condition 3, and in fact, all of our approaches found the solution that satisfied it. Therefore, we're able to treat it as \"strictly necessary\" for our purposes, and as we'll see, this assumption is important for making sense of approach 5.\n\nWhat we've convinced ourselves of so far is that all of these conditions are **necessary** for a solution to be optimal. What we haven't yet proven, though, is that they are **sufficient** for a solution to be optimal. In other words, if a solution meets these three conditions, can we safely conclude that it must be an **optimal solution**?\n\n> When we're trying to prove (or at least informally convince ourselves) of the correctness of an algorithm, it is very important to not muddle necessity and sufficiency. A condition or group of conditions might be necessary for a solution to be optimal, but this doesn't always mean that those conditions are enough to conclude that the solution has to be optimal!\n\nThe easiest way to prove that it must be optimal is to use contradiction. In other words, we need to show that the claim of having a solution that is **not optimal**, yet meets all three of the conditions, would lead to a contradiction.\n\nSo, assume that you have a solution that satisfies all three of the above criteria, but it is **not optimal**. \n\nBecause our solution is not optimal, this means that there must exist a more optimal solution *that can cover an additional climb*. For starters, we know we don't have enough ladders or bricks remaining from our \"not optimal\" solution to cover that additional climb; otherwise, our \"not optimal\" solution would be violating condition 1.\n\nThis leaves only one possibility: we'd have to somehow cover the current climbs of our \"non-optimal\" solution using *less* ladders and bricks than we have. After all, this is the only way we could possibly reclaim enough climbing implements to do that additional climb! Is it possible for us to rearrange the previous allocations to make this happen? We're going to look at two options: remove 1 ladder, and remove at least 1 brick.\n\nWe can't simply take a brick; this would mean a climb was no longer fully covered. In order to reclaim some bricks, we'd have to move a ladder to where they were. This would then require putting some of our reclaimed bricks where the ladder was. But if we were able to do that and have any bricks left over, then condition 3 would be violated: all of the ladder climbs are at least the length of all the brick climbs. Again, we get a contradiction.\n\nSimply taking out a ladder for the next climb would leave an uncovered climb that we'd now have to cover with bricks. But we don't have enough bricks left over to do this; otherwise, our \"not optimal\" solution would violate condition 2, resulting in another contradiction. And like we determined just above, we can't reclaim any additional bricks with rearranging.\n\nIn conclusion, if we have a solution that meets the above three conditions, then it is not possible for there to exist a solution that does an additional climb. **This proves that a climb meeting the above 3 conditions is optimal.**\n\n*Defining K: the threshold between ladder and brick climbs*\n\nCondition 3 from above is particularly interesting: the longest climb to use bricks is not greater than the shortest climb to use a ladder. The implication of this is that for all optimal solutions identified by our previous approaches, there exists some threshold value, `K`, where the shortest climb to use a ladder is equal to this `K`, and there is no climb greater than `K` that used bricks.\n\nIf we somehow knew `K` beforehand (we don't, but let's just follow this thought through), then coming up with the optimal solution could be done in linear time and constant space! Let's write an algorithm to do exactly this.\n\nThe main challenge in designing the algorithm is handling climbs of length `K` itself; some will be with bricks, and others with ladders. We'll start by pretending that **all climb lengths are unique**, and as such, there will be at most one climb of length `K`, and this would be covered with a ladder.\n\n```text\nheights, bricks, and ladders are as specified in the problem\n\ndefine function solveWithGivenThreshold(K):\n    \n    ladders_remaining = ladders\n    bricks_remaining = bricks\n    \n    for each i between 0 and building_index - 1 (inclusive):\n    \n        climb = heights[i + 1] - heights[i]\n        if climb is not positive:\n            continue (this is not a climb)\n    \n        if climb is greater than or equal to K:\n            subtract 1 from ladders_remaining\n        else:\n            subtract climb from bricks_remaining\n    \n        if bricks_remaining or ladders_remaining is now negative:\n            return i\n    \n    return heights.length - 1\n```\n\nThe way that we can make it work with non-unique climb lengths is to allocate ladders to climbs of length `K`, but keep track of how many ladders were allocated in this way. If we then come across a climb of length `K` when we only have bricks left, we should simply cover it with bricks. And if we come across a climb longer than `K` and are out of ladders, we should check if we used any ladders on `K` length climbs, and if so, attempt to replace that ladder with bricks to reclaim it. Essentially, we are optimizing the use of ladders and bricks on this edge case.\n\n```text\nheights, bricks, and ladders are as specified in the problem\n\ndefine function solveWithGivenThreshold(K):\n    \n    ladders_remaining = ladders\n    bricks_remaining = bricks\n    ladders_assigned_on_threshold = 0\n    \n    for each i between 0 and building_index - 1 (inclusive):\n        \n        climb = heights[i + 1] - heights[i]\n        if climb is not positive:\n            continue (this is not a climb)\n        \n        if climb is greater than or equal to K:\n            subtract 1 from ladders_remaining\n            if climb is equal to K:\n                ladders_assigned_on_threshold += 1\n        else:\n            subtract climb from bricks_remaining\n        \n        if ladders_remaining is now negative:\n            if ladders_assigned_on_threshold is positive:\n                subtract 1 from ladders_assigned_on_threshold\n                add 1 to ladders_remaining\n                subtract K from bricks_remaining\n                [Note: if this made bricks_remaining negative, the next condition will catch it]\n            else:\n                return i\n        \n        if bricks_remaining is now negative:\n            return i\n\n    return heights.length - 1\n```\n\n*Laying the foundations for a binary search on K*\n\nWhat is the range of values that this `K` could be? \n\nWell, the shortest climb to use a ladder must be the shortest climb that can be extracted from the heights array. If `K` was this value, then potentially all climbs would be using a ladder, other than possibly a few of length `K` itself that were using bricks. \n\nThe other extreme would be that we're not using ladders at all. In this case, the shortest climb to use a ladder would essentially be 1 more than the longest climb from the height array (in code, we can get away with just setting it to be the length of the longest climb; the optimization around `K` itself will cover the possibility of no ladders being used on `K`).\n\nWith this, we could do a linear search until we find a solution that is **optimal**, based on our definition above of an optimal solution. This linear search wouldn't work very well; the possible range in climb length is huge! In the worst case, it will be equal to the maximum height in `heights`, and according to the problem description, that is a very big number!\n\nAs I said earlier in this article, when linear search is too slow, consider using binary search!\n\nA binary search would work by identifying the maximum possible value for `K`, the lowest possible value, and then cutting out half of the possible values on each iteration.\n\nWe've already figured out a way of knowing if a solution is **optimal**, but in the case that it's not, how do we know whether the value we tried was too high or too low? It turns out there is a way, and that's what we're going to look at next.\n\n*Identifying when mid is greater than K*\n\nIf `mid > K`, then it turns out that either we'd reach the *final building* regardless, or *we'd have at least one ladder left over.* But why?\n\nWell, the *optimal solution*, whatever it is, makes $$C$$ climbs. Additionally, we know that $$L$$ of those climbs have to be with ladders (remember, optimal solutions that don't reach the end have to use all of the ladders!). These ladders were allocated to all climbs greater than `K`, and at least one climb equal to `K`. If `mid` was not optimal, then it has to have made a *subset* of those $$C$$ climbs (i.e., it can't have covered any climbs that were *beyond* the optimal solution's *final-reachable-building*). Of that subset, it only put ladders on the climbs *greater than `K`*, which is strictly a smaller number of climbs than the optimal solution put ladders on. Therefore, there has to be at least one ladder left over at the end.\n\nSo, if there is at least one ladder left over, then we know that `mid` is **too high**.\n\n*Identifying when mid is less than K*\n\nIf `mid < K`, then either we'd reach the *final building* regardless, or we'd have a *non-optimal solution that used all of the ladders*.\n\nBy setting `mid` below `K`, we're essentially going to be wasting a lot of ladders on climbs that the optimal solution would have used bricks for. Remember that our not-optimal solution could only make a subset of the $$C$$ climbs that the optimal solution must make. There are enough bricks to get to the optimal solution's *final-reachable-index* using a *higher* threshold, and so our lower threshold definitely won't run out of bricks. So, it will be running out of ladders that causes it to fail to go all of the way.\n\n*Putting everything together*\n\nYou now have all the ingredients you need to assemble the code for this algorithm. \n\nFirstly, we should modify the `solveWithGivenThreshold` function so that it returns a 2D array with 3 values: the index reached, ladders remaining, and bricks remaining. Secondly, we need to write the binary search. It needs to interpret the return value from `solveWithGivenThreshold` to know how to proceed with the search. Keep in mind: this algorithm is not allowed to use auxiliary memory!\n\n```text\ndefine function furthestBuilding(heights, bricks, ladders):\n\n    lo = find the minimum climb \n    hi = find the maximum climb\n    if lo and hi are undefined (there was no climbs):\n        return heights.length - 1\n\n    while lo is not greater than hi:\n        mid = lo + (hi - lo) / 2\n        result = solveWithGivenThreshold(mid)\n        index_reached, ladders_remaining, bricks_remaining = unpack result\n        if index_reached is heights.length - 1:\n            return heights.length - 1\n        if ladders_remaining is not zero:\n            hi = mid - 1\n        else if the climb from index_reached to index_reached + 1 could be covered\n                with the bricks_remaining, or bricks_remaining was at least K:\n            lo = mid + 1\n        else:\n            return index_reached\n\n```\n\nTo help you visualize what this algorithm is doing, here's an animation. To keep the focus on the core algorithm details, we've made the assumption that the climbs are all unique (and therefore, we don't need to do the optimizing around `K` itself). \n\nNote that the bars represent **climbs**, not **heights**. Also, the actual algorithm won't explicitly make a climb list; we refrain from doing this as that would require auxiliary memory.\n\n!?!../Documents/1642_binary_search_threshold.json:960,540!?!\n\n**Code**\n\n<iframe src=\"https://leetcode.com/playground/edriQB3R/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"edriQB3R\"></iframe>\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the `heights` array. Let $$\\text{maxClimb}$$ be the length of the longest climb. An upper bound on this value is $$\\max(\\text{heights})$$.\n\n- Time complexity : $$O(N \\log(\\text{maxClimb}))$$.\n\n    The `solveWithGivenThreshold(...)` function iterates over the `heights` list, performing $$O(1)$$ operations for each index. Because `heights` contains $$N$$ items, this gives a total time complexity of $$O(N)$$ for this function.\n\n    The binary search starts with a search space of up to $$\\text{maxClimb}$$ and halves it each time. This means that $$\\log(\\text{maxClimb})$$ calls are made to `solveWithGivenThreshold(...)`.\n\n    Multiplying these together, we get a final time complexity of $$O(N \\log(\\text{maxClimb}))$$.\n    \n- Space complexity : $$O(1)$$.\n\n    We are only using constant extra memory (note that the fixed-length arrays used to return 3 values are considered to be constant).\n\nComparing this to the previous approaches, it will generally perform quite well. With the problem constraints we're given, $$\\log(\\text{maxClimb})$$ isn't much worse than $$\\log N$$ in the worst case, and in fact, it is often better. Most notably, this approach shows that it is possible to solve this problem without using auxiliary memory while keeping the time complexity almost the same. \n\n<br/>\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1016",
            "count": 250,
            "average": "4.952",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "furthest-building-you-can-reach",
    "playgroundData": {
        "ZGMbcLaQ": {
            "playground": {
                "testcaseInput": "",
                "name": "furthest-building-you-can-reach-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "gvs2qqK5": {
            "playground": {
                "testcaseInput": "",
                "name": "furthest-building-you-can-reach-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "8nYDsadQ": {
            "playground": {
                "testcaseInput": "",
                "name": "furthest-building-you-can-reach-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "XccxVRai": {
            "playground": {
                "testcaseInput": "",
                "name": "furthest-building-you-can-reach-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "edriQB3R": {
            "playground": {
                "testcaseInput": "",
                "name": "furthest-building-you-can-reach-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}