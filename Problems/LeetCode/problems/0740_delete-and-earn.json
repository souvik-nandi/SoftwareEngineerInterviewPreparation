{
    "id": "740",
    "question": {
        "questionId": "740",
        "questionFrontendId": "740",
        "boundTopicId": null,
        "title": "Delete and Earn",
        "titleSlug": "delete-and-earn",
        "content": "<p>You are given an integer array <code>nums</code>. You want to maximize the number of points you get by performing the following operation any number of times:</p>\n\n<ul>\n\t<li>Pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. Afterwards, you must delete <b>every</b> element equal to <code>nums[i] - 1</code> and <strong>every</strong> element equal to <code>nums[i] + 1</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum number of points</strong> you can earn by applying the above operation some number of times</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,2]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].\n- Delete 2 to earn 2 points. nums = [].\nYou earn a total of 6 points.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,3,3,3,4]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2&#39;s and 4&#39;s are also deleted. nums = [3,3].\n- Delete a 3 again to earn 3 points. nums = [3].\n- Delete a 3 once more to earn 3 points. nums = [].\nYou earn a total of 9 points.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 5171,
        "dislikes": 284,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "exampleTestcases": "[3,4,2]\n[2,2,3,3,3,4]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Akuna Capital\", \"slug\": \"akuna-capital\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 10}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int deleteAndEarn(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def deleteAndEarn(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def deleteAndEarn(self, nums: List[int]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint deleteAndEarn(int* nums, int numsSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int DeleteAndEarn(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar deleteAndEarn = function(nums) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef delete_and_earn(nums)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func deleteAndEarn(_ nums: [Int]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func deleteAndEarn(nums []int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def deleteAndEarn(nums: Array[Int]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun deleteAndEarn(nums: IntArray): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn delete_and_earn(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function deleteAndEarn($nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function deleteAndEarn(nums: number[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (delete-and-earn nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec delete_and_earn(Nums :: [integer()]) -> integer().\ndelete_and_earn(Nums) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec delete_and_earn(nums :: [integer]) :: integer\n  def delete_and_earn(nums) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"207.7K\", \"totalSubmission\": \"361K\", \"totalAcceptedRaw\": 207661, \"totalSubmissionRaw\": 361035, \"acRate\": \"57.5%\"}",
        "hints": [
            "If you take a number, you might as well take them all.  Keep track of what the value is of the subset of the input with maximum M when you either take or don't take M."
        ],
        "solution": {
            "id": "1311",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[3,4,2]",
        "metaData": "{\r\n  \"name\": \"deleteAndEarn\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "833",
            "date": "2022-03-05",
            "incompleteChallengeCount": 31,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1311",
        "content": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nThis problem is an excellent example of why it is important to read the problem description carefully. We can make a substantial optimization by noticing that the order of the elements in `nums` is irrelevant.\n\nAt any operation, we pick a number, let's say `x`, and delete **all** occurrences of `x - 1` and  `x + 1`. That means if `x` occurs multiple times in `nums` and we take one, we may as well take all of them because after deleting all `x - 1` and `x + 1`, we can only stand to gain more points by taking additional `x`. \n\nBefore we start, we can simplify `nums` by collecting all duplicate numbers together. As an example, `nums` can be represented as a hash map with numbers as keys which map to the number of times the key occurs in `nums`. `[2, 2, 3, 3, 3, 4]` would be converted to `{2: 2, 3: 3, 4: 1}`. Furthermore, since we are only really concerned about how many points each number can give us, we can multiply the keys and values to represent how many points taking the key will give us. In this case, we would have `{2: 4, 3: 9, 4: 4}`.\n\n**In the first approach of this article, we will talk about an algorithm that solves this problem in detail. In the second approach, we will implement the same algorithm in a slightly more efficient way.** \n\nThen, we will look at some approaches that build on the idea from the first two approaches, but each one will have differences in their time and space complexities.\n\n#### Approach 1: Top-Down Dynamic Programming\n\n**Intuition**\n\nThere are two characteristics of this problem that hint towards the use of dynamic programming (DP). The first is that the problem is asking us to find the **maximum** of something. The second is that we need to make decisions on which numbers to take, and each decision may influence future decisions. For example, if we wanted to take all the fives, then we can no longer take the fours or sixes.\n\nAs described in the [Dynamic Programming Explore Card](https://leetcode.com/explore/learn/card/dynamic-programming/), these two characteristics suggest that we should consider a DP solution. If you're new to DP, then reading this card is highly recommended.\n\nThe difficult part about this problem is figuring out how to always make the optimal decisions on which elements to take. Let's look at an example to illustrate the problem: `nums = [5, 4, 5, 4, 3, 5, 3]`. As we mentioned above, we can convert this into a format that's easier to use. We have two `3`, two `4`, and three `5`. That means:\n\n- If we take all the `3`, we get `3 * 2 = 6` points.\n- If we take all the `4`, we get `4 * 2 = 8` points.\n- If we take all the `5`, we get `5 * 3 = 15` points.\n\nIf we tried moving from smaller keys to larger ones in a greedy manner, our first decision would be to take all `3` or all `4`. We can only choose one because picking one deletes the other one. Well, we get `8` points if we pick `4` and `6` points if we pick `3`, so perhaps we should greedily pick `4`. Unfortunately, this prevents us from picking `5`, which gives us way more points.\n\nPerhaps a different greedy strategy would work. How about sorting the keys by how many points they give, and then greedily trying to pick the most points? That way, we would take the `15` points here immediately. Well, what if we had an example `nums = [5, 5, 5, 6, 6, 6, 6, 7, 7]`? We would have:\n\n- `5` --> `15` points.\n- `6` --> `24` points.\n- `7` --> `14` points.\n\nAgain, this greedy strategy won't work. Those `24` points are tempting, but by taking them, we delete `29` points. In these small examples, it's easy to see what the correct decisions are. But for larger test cases, the question can get out of hand quickly. We need to ensure that we always make the correct decision.\n\nThis is where DP comes in. We'll skip over the underlying details of DP, so the article stays focused on the problem - but if DP is relatively new to you, then you will likely find the DP explore card to be a very helpful resource.\n\nWe can formulate DP algorithms in 3 easy steps. First, we need some sort of memory that stores the answer to our question. Because we're doing top-down, we'll use a hash table for memory and a recursive function. Let's declare a function `maxPoints`. We want `maxPoints(num)` to return the maximum points that we can gain if we only consider all the elements in `nums` with values between `0` and `num`.\n\nThe second thing we need is a recurrence relation, a way to move between states. Let's say that we are currently at some arbitrary number `x`, where `x` is in `nums` one or more times. How can we find `maxPoints(x)`? When it comes to `x`, we have to make a choice: **take, or don't take.**\n\n- If we take `x`, then we gain points equal to `x` times the number of times `x` occurs in `nums` - we can pre-compute these values. For now, let's call this value `gain`. However, because of the deletion, by taking `x`, we are no longer allowed to take `x - 1`. The largest number that we can still consider is `x - 2`. Therefore, if we choose to take `x`, then the most points that we can have here is `gain + maxPoints(x - 2)`, where `gain` is how many points we gain from taking `x` and `maxPoints(x - 2)` is the maximum number of points we can obtain from the numbers between `x - 2` and `0`.\n\n- If we choose not to take `x`, then we don't gain any points here, but we still may have accumulated some points from numbers smaller than `x`. Because we didn't take `x`, we did not close the door to `x - 1`. In this case, the most points we can have here is `maxPoints(x - 1)`.\n\nThis forms our recurrence relation: for an arbitrary `x`, `maxPoints(x) = max(maxPoints(x - 1), maxPoints(x - 2) + gain)`, where `gain` is the number of points we can gain from taking `x`.\n\n> The problem is, even though we figured out how to find `maxPoints(x)`, how do we find `maxPoints(x - 1)` and `maxPoints(x - 2)`? That would involve finding `maxPoints(x - 3)` and `maxPoints(x - 4)` and so on.\n\nThe third component of a dynamic programming solution is base cases. Typically, we can find base cases with a little bit of logical thinking. First, `maxPoints(0)` will always be equal to `0`. Second, when considering `maxPoints(1)`, we only care about the elements `0` and `1`. We do not care about `2` because of how we defined `maxPoints(x)`. Looking at the recurrence relation, we know that if we arrived at `1`, it means that we must not have taken `2`, and because `1` times any quantity will be greater than or equal to the number of points we can get from taking `0`, we should always take `1` (if there are any).\n\nWith these base cases, we can find `maxPoints(2)`. With `maxPoints(2)` calculated, we can find `maxPoints(3)`, all the way up to `maxPoints(max(nums))`. Remember, we defined `maxPoints(x)` as the maximum points we can gain when we consider the numbers from `0` to `x`, so `maxPoints(max(nums))` covers the entire input, and stores the answer to the original problem.\n\n> Because each call to `maxPoints` will create 2 extra calls (the recurrence relation looks for `maxPoints(num - 1)` and `maxPoints(num - 2)`), we would end up with an exponential amount of function calls. To avoid this, we will **memoize** our function. When we find the answer for a certain number for the first time, we will store this answer. Then in the future, we can refer to this value instead of repeating computation.\n\n!?!../Documents/740_Delete_and_Earn.json:960,540!?!\n\n**Algorithm**\n\n1. Declare a hash table `points` that will map elements to the number of points that we can gain from taking each element. Also, declare a hash map `cache` that we will use to memoize our recursive function.\n\n2. Loop through `nums` once to populate `points` to find `maxNumber`, which is the largest element in `nums`.\n\n3. Initialize a function `maxPoints`, where `maxPoints(num)` will return the maximum amount of points we can gain if we only consider numbers from `0` to `num`.\n\n4. In `maxPoints`, first check for the base cases. If `num == 0`, return `0`. If `num == 1`, return `points[1]`. Otherwise, check if `num` is already in `cache`. If it is, just return `cache[num]`.\n\n5. Otherwise, apply the recurrence relation. Find the answer for `num` with `max(maxPoints(num - 1), maxPoints(num - 2) + points[num])`. Store this answer in `cache`, and then return it.\n\n6. Return `maxPoints(maxNumber)`.\n\n<br>\n\n**Implementation**\n\nIn Python, we can use [functools](https://docs.python.org/3/library/functools.html) to easily memoize our function with the `@cache` decorator.\n\n<iframe src=\"https://leetcode.com/playground/MGGZ8yxV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"MGGZ8yxV\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$N$$ as the length of `nums` and $$k$$ as the maximum element in `nums`,\n\n* Time complexity: $$O(N + k)$$\n\n    To populate `points`, we need to iterate through `nums` once, which costs $$O(N)$$ time. Then, we call `maxPoints(maxNumber)`. This call will repeatedly call `maxPoints` until we get down to our base cases. Because of `cache`, already solved sub-problems will only cost $$O(1)$$ time. Since `maxNumber = k`, we will solve `k` unique sub-problems so, this recursion will cost $$O(k)$$ time. Our final time complexity is $$O(N + k)$$.\n\n* Space complexity: $$O(N + k)$$\n\n    The extra space we use is the hash table `points`, the recursion call stack needed to find `maxPoints(maxNumber)`, and the hash table `cache`.\n    \n    The size of `points` is equal to the number of unique elements in `nums`. In the worst case, where every element in `nums` is unique, this will take $$O(N)$$ space. The recursion call stack will also grow up to size `k`, since we start our recursion at `maxNumber`, and we don't start returning values until our base cases at `0` and `1`. Lastly, `cache` will store the answer for all states, from `2` to `maxNumber`, which means it also grows up to `k` size. Our final space complexity is $$O(N + 2 \\cdot k)$$ = $$O(N + k)$$.\n\n<br/>\n\n---\n\n#### Approach 2: Bottom-Up Dynamic Programming\n\n**Intuition**\n\nIn the top-down approach, we start at the \"top\" (`maxNumber`), and move towards our base cases (`maxPoints[0] = 0, maxPoints[1] = nums.count(1)`). With bottom-up, we will start at the base cases and iterate away from them towards the result we want (`maxNumber`).\n\nFor this approach, instead of having `maxPoints` be a recursive function, we will have it be an array where `maxPoints[num]` stores the maximum points we can gain if we consider only numbers from `0` to `num`. As you can see, this is just a different way to format `maxPoints`, but in terms of functionality, it will be the same as the previous approach.\n\n**Algorithm**\n\n1. Declare a hash table `points` that will map elements to the amount of points that we can gain from taking each element.\n\n2. Loop through `nums` once to populate `points` and find the largest element in `nums`, `maxNumber`.\n\n3. Initialize an array `maxPoints` of size `maxNumber + 1`, where `maxPoints[num]` will store the maximum amount of points we can gain if we only considered numbers from `0` to `num` (inclusive). Set all the values to `0` initially, except for `maxPoints[1]` - it should be set to `points[1]` (our base case).\n\n4. Iterate from `2` to `maxNumber`. At each iteration, apply the recurrence relation `maxPoints[num] = max(maxPoints[num - 1], maxPoints[num - 2] + points[num])` to populate `maxPoints`.\n\n5. At the end, return `maxPoints[maxNumber]`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/X9dSxHE2/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"X9dSxHE2\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$N$$ as the length of `nums` and $$k$$ as the maximum element in `nums`,\n\n* Time complexity: $$O(N + k)$$\n\n    To populate `points`, we need to iterate through `nums` once, which costs $$O(N)$$ time. Then, we populate `maxPoints` by iterating over it. The length of `maxPoints` is equal to `k + 1`, so this will cost $$O(k)$$ time. Our final time complexity is $$O(N + k)$$.\n\n* Space complexity: $$O(N + k)$$\n\n    The extra space we use is the hash table `points` and our DP array `maxPoints`. The size of `maxPoints` is equal to `k + 1`, which means it takes $$O(k)$$ space. The size of `points` is equal to the number of unique elements in `nums`. In the worst case, where every element in `nums` is unique, this will take $$O(N)$$ space. Our final space complexity is $$O(N + k)$$.\n\n<br/>\n\n#### Approach 3: Space Optimized Bottom-Up Dynamic Programming\n\n**Intuition**\n\nIn our recurrence relation, for a given `num`, we refer to `num - 1` and `num - 2`. To find `maxPoints[10]`, we only need `maxPoints[9]` and `maxPoints[8]`. While it is true that we also need to calculate `maxPoints` for `0` to `7`, by the time we get to `10`, we don't need those values anymore. Because of this, instead of using an array to store the answers to all states, we can improve to constant space by only storing the previous two values.\n\nLet's use two integer variables, `twoBack` and `oneBack`, that at any given `num` will represent `maxPoints[num - 2]` and `maxPoints[num - 1]` respectively. In the second approach, we started iterating from `2`. This means that `twoBack` should be initialized the same as `maxPoints[0] = 0`, and `oneBack` should be initialized the same as `maxPoints[1] = nums.count(1)`.\n\nOur recurrence relation remains the same, as long as we appropriately substitute the variables. Now, it is `maxPoints[num] = max(oneBack, twoBack + points[num])`. Once we calculate this value, we need to update `twoBack` and `oneBack`. When we go to the next number, the previous value (`oneBack`) will become `twoBack`, and the current value will become `oneBack`. At the very end, `oneBack` will be our answer.\n\n**Algorithm**\n\n1. Declare a hash table `points` that will map elements to the amount of points that we can gain from taking each element.\n\n2. Loop through `nums` once to populate `points` to find `maxNumber`, which is the largest element in `nums`.\n\n3. Initialize `twoBack = 0` and `oneBack = points[1]`. These are the base cases from the previous approaches.\n\n4. Loop from `2` to `maxNumber`. At each iteration `num`, update `oneBack` and `twoBack`. `oneBack` should be updated according to the recurrence relation - `max(oneBack, twoBack + points[num])`. `twoBack` should be updated to what `oneBack` was before applying the recurrence relation. This way, when we get to the next number, one step back will become two steps back, and the current step will become the previous step.\n\n5. Return `oneBack`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/iHvhK65h/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"iHvhK65h\"></iframe>\n\n\n**Complexity Analysis**\n\nGiven $$N$$ as the length of `nums` and $$k$$ as the maximum element in `nums`,\n\n* Time complexity: $$O(N + k)$$\n\n    To populate `points`, we need to iterate through `nums` once, which costs $$O(N)$$ time. Then, we iterate from `2` to `k`, doing $$O(1)$$ work at each iteration, so this will cost $$O(k)$$ time. Our final time complexity is $$O(N + k)$$.\n\n* Space complexity: $$O(N)$$\n\n    The extra space we use is the hash table `points`.\n    \n    The size of `points` is equal to the number of unique elements in `nums`. In the worst case, where every element in `nums` is unique, this will take $$O(N)$$ space.\n\n    Unlike in approach 2, we no longer need an array `maxPoints` which would be of size `k`. Thus, we have improved the space complexity to $$O(N)$$.\n\n<br/>\n\n#### Approach 4: Iterate Over Elements\n\n**Intuition**\n\nIn the previous three approaches, we found the maximum element in `nums`, and iterated from `0` to `maxNumber`. The problem with this idea is that in some test cases, there could be large gaps between elements that we will waste time iterating over. In all three approaches, our time complexity was $$O(N + k)$$, or $$O(\\text{nums.length} + \\text{max(nums)})$$. This is very inefficient for a case such as `nums = [1, 2, 3, 10000]`.\n\nInstead of iterating over **all** numbers from `0` to `max(nums)`, we can iterate over **only** the elements that appear in `nums`. Unfortunately, we will need to perform a sort to do this, but in cases like `nums = [1, 2, 3, 10000]`, the algorithm will run **much** faster.\n\nLet's use the same logic from the previous approaches to create a hash map `points` that keeps track of how many points we gain from taking elements. Once we have `points`, we can sort the keys in ascending order. These keys will be what we iterate over.\n\nIf we find that adjacent elements have a difference of `1`, that means we can only take the points associated with one of them, and we need to use the same recurrence relation as in the previous approach (`oneBack = max(oneBack, twoBack + points[num])`). However, if two elements do not differ by `1`, then that means we don't need to worry about deletions, and we should always take the points. In this case, we just add `points[num]` to `oneBack`.\n\n<img src=\"../Figures/740/740_4.png\" width=\"960\"> <br>\n\n**Algorithm**\n\n1. Declare a hash table `points` that will map elements to the amount of points that we can gain from taking each element.\n\n2. Loop through `nums` once to populate `points`.\n\n3. Create a list `elements` that holds the keys of `points` in ascending order.\n\n4. Initialize `twoBack = 0` and `oneBack = points[elements[0]]`. These are the base cases.\n\n5. Iterate through `elements`, starting from index `1`. At each `currentElement`, compare the element number with the previous element's number.\n    - If they differ by `1`, then we need to apply the normal recurrence relation `oneBack = max(oneBack, twoBack + points[currentElement]`.\n    - If they don't, then it is always beneficial to take the points. Do `oneBack += points[currentElement]`.\n    - In either case, we need to update `twoBack` to what `oneBack` was before it was updated.\n\n6. Return `oneBack`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/3cozCjKs/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"3cozCjKs\"></iframe>\n\n\n**Complexity Analysis**\n\nGiven $$N$$ as the length of `nums`,\n\n* Time complexity: $$O(N \\cdot log(N))$$\n\n    To populate `points`, we need to iterate through `nums` once, which costs $$O(N)$$ time. \n    \n    Next, we take all the keys of `points` and sort them to create `elements`. In the worst case when `nums` only contains unique elements, there will be `N` keys, which means this will cost $$O(N \\cdot log(N))$$ time.\n\n    Lastly, we iterate through `elements`, which again in the worst case costs $$O(N)$$ time when all the elements are unique.\n\n    This gives us a time complexity of $$O(N + N \\cdot log(N) + N) = O(N \\cdot log(N))$$.\n\n* Space complexity: $$O(N)$$\n\n    The extra space we use is the hash table `points` and `elements`. These have the same length, and in the worst case scenario when `nums` only contains unique elements, their lengths will be equal to `N`.\n\n<br/>\n\n---\n\n#### Further Thoughts: The Best of Both Worlds\n\n> Below is some additional discussion on how the algorithms we have created can be combined to create a fully optimized approach. The previous solutions would be sufficient in an interview setting; this is just bonus content.\n\nApproach 3 has a time complexity of $$O(N + k)$$. Approach 4 has a time complexity of $$O(N \\cdot log(N))$$. When `k` is large compared to `N`, approach 4 is faster. When `N` is not large compared to `k`, such as in the example `nums = [1, 2, 3, 4, ..., 9997, 9998, 9999]`, we should use approach 3.\n\nIt should be noted that the time complexity $$O(N \\cdot log(N))$$ is for the worst case. We are actually only sorting the number of keys in `points`, which is equal to the number of unique elements in `nums`. When we precompute `points`, we can find the number of keys `n` as well as `k`. With `n` and `k`, we can decide if approach 3 or approach 4 is faster, and then perform the faster one.\n\nFor approach 3, we iterate `k = maxNumber` times. For approach 4, we iterate `n` times after performing `n * log(n)` operations to sort. If `k < n + n * log(n)`, then it is better to use the algorithm from approach 3. Otherwise, it might be more efficient to use the algorithm from approach 4.\n\n\n**Example Implementations**\n\n<iframe src=\"https://leetcode.com/playground/etgMmCv2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"etgMmCv2\"></iframe>\n\n\n**Complexity Analysis**\n\nGiven $$N$$ as the length of `nums` and $$k$$ as the maximum element in `nums`,\n\n* Time complexity: $$O(N + min(k, N \\cdot log(N)))$$\n\n    To populate `points`, we need to iterate through `nums` once, which costs $$O(N)$$ time.\n    \n    Approach 3's algorithm costs $$O(k)$$ time. Approach 4's algorithm costs $$O(N \\cdot log(N))$$ time. We choose the faster one, so the final time complexity will be $$O(N + min(k, N \\cdot log(N)))$$.\n\n* Space complexity: $$O(N)$$\n\n    The extra space we use is the hash table `points`, and maybe `elements` if we are to use approach 4's algorithm. However, `points` has the same length as `elements`, so it doesn't matter either way in terms of space complexity.\n\n    In the worst-case scenario when all elements in `nums` are unique, `points` will grow to a size of `N`.\n\n<br/>\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1316",
            "count": 121,
            "average": "4.843",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "delete-and-earn",
    "playgroundData": {
        "MGGZ8yxV": {
            "playground": {
                "testcaseInput": "",
                "name": "delete-and-earn-4",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "X9dSxHE2": {
            "playground": {
                "testcaseInput": "",
                "name": "delete-and-earn-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "iHvhK65h": {
            "playground": {
                "testcaseInput": "",
                "name": "delete-and-earn-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "3cozCjKs": {
            "playground": {
                "testcaseInput": "",
                "name": "delete-and-earn-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "etgMmCv2": {
            "playground": {
                "testcaseInput": "",
                "name": "delete-and-earn-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}