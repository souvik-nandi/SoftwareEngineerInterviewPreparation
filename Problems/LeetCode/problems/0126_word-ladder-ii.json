{
    "id": "126",
    "question": {
        "questionId": "126",
        "questionFrontendId": "126",
        "boundTopicId": null,
        "title": "Word Ladder II",
        "titleSlug": "word-ladder-ii",
        "content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]\n<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Hard",
        "likes": 3793,
        "dislikes": 362,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Word Ladder\", \"titleSlug\": \"word-ladder\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Groups of Strings\", \"titleSlug\": \"groups-of-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "String",
                "slug": "string",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Breadth-First Search",
                "slug": "breadth-first-search",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 10}, {\"taggedByAdmin\": false, \"name\": \"Box\", \"slug\": \"box\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Lyft\", \"slug\": \"lyft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Yelp\", \"slug\": \"yelp\", \"timesEncountered\": 0}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar *** findLadders(char * beginWord, char * endWord, char ** wordList, int wordListSize, int* returnSize, int** returnColumnSizes){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, wordList) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {String[][]}\ndef find_ladders(begin_word, end_word, word_list)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func findLadders(beginWord string, endWord string, wordList []string) [][]string {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def findLadders(beginWord: String, endWord: String, wordList: List[String]): List[List[String]] = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun findLadders(beginWord: String, endWord: String, wordList: List<String>): List<List<String>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn find_ladders(begin_word: String, end_word: String, word_list: Vec<String>) -> Vec<Vec<String>> {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return String[][]\n     */\n    function findLadders($beginWord, $endWord, $wordList) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (find-ladders beginWord endWord wordList)\n  (-> string? string? (listof string?) (listof (listof string?)))\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec find_ladders(BeginWord :: unicode:unicode_binary(), EndWord :: unicode:unicode_binary(), WordList :: [unicode:unicode_binary()]) -> [[unicode:unicode_binary()]].\nfind_ladders(BeginWord, EndWord, WordList) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec find_ladders(begin_word :: String.t, end_word :: String.t, word_list :: [String.t]) :: [[String.t]]\n  def find_ladders(begin_word, end_word, word_list) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"295.4K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 295407, \"totalSubmissionRaw\": 1089996, \"acRate\": \"27.1%\"}",
        "hints": [],
        "solution": {
            "id": "1148",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "metaData": "{\r\n  \"name\": \"findLadders\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"beginWord\",\r\n      \"type\": \"string\"\r\n    },\r\n    {\r\n      \"name\": \"endWord\",\r\n      \"type\": \"string\"\r\n    },\r\n    {\r\n      \"name\": \"wordList\",\r\n      \"type\": \"list<string>\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"list<list<string>>\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1148",
        "content": "[TOC]\r\n\r\n## Solution\r\n\r\n--- \r\n\r\n#### Overview\r\n\r\nThis problem is an extension of the problem [Word Ladder](https://leetcode.com/problems/word-ladder/), where we only need to find the minimum number of words in the transformation from `beginWord` to `endWord`. Here, we need to find all the transformations that exist between `beginWord` and `endWord` that are the minimum length. We can use BFS to find the minimum number of words in the transformation, however, finding all such transformations is tricky because the number of transformations may be enormous.\r\n</br>\r\n\r\n---\r\n\r\n#### Approach 1: Breadth-First Search (BFS) + Backtracking\r\n\r\n**Intuition**\r\n\r\nThe problem can be correlated with the graph data structure. We can represent the words as the vertices and an edge can be used to connect two words which differ by a single letter.\r\n\r\nBefore diving further let's see how we can find all the direct connections of a particular word. To find the adjacent words for a particular word, one approach is to traverse all of the other words and add an edge for those that differ by a single letter. This approach requires $$O(N\\cdot K)$$ time where $N$ is the number of words given and $K$ is the maximum length of a word. The observation behind the optimal approach is that the words only consist of lowercase English letters. Hence we can change each character of the word to all other English lowercase characters and check whether or not that word exists in the `wordList`(this particular check operation takes $$O(1)$$ in C++ while in Java it will take $$O(K)$$ due to the immutable nature of Strings).This way the number of operations will be $$(25\\cdot K*K + 1)$$, hence the time complexity will be $$O(K^2)$$.\r\n\r\nThus we can find all the words that are directly connected.  Now, the task is to find all of the shortest paths from `beginWord` to `endWord`. \r\n\r\nThe naive way to do this is to use backtracking. We will start from `beginWord`, then traverse all the adjacent words until we reach the `endWord`. When we reach the `endWord`, we can compare the path length and find all the paths that have the minimum path length. This method however is extremely inefficient because the number of paths between two vertices can be enormous.\r\n\r\nLet's try to optimize our approach. Somehow, we need to reduce the number of traversed paths. Let's say the number of shortest paths that exist between `beginWord` and `endWord` is `x` and the number of paths that we must traverse to find these shortest paths is `y`. The closer the value `y` gets to the value `x`,  the more efficient our approach will be.\r\n\r\nThe diagram below shows the graph that represents the connectivity among words. As shown in the diagram we want to go from `red` to `tax`.  While backtracking on this graph, we will also cover the edges upwards that is from the `tad` to `ted` similarly from `tex` we will traverse to `ted` as well as `rex`. The key observation here is that going back in the upward direction will never lead us to the shortest path. We should always traverse the edges in the direction of `beginWord` to `endWord`. \r\n![fig](../Figures/126/126A.png)\r\nTo ensure that we never traverse up the ladder, let's use directed edges to connect the words. The edges in the graph below are all directed towards `endWord`. Also, notice that graphs produced by BFS do not contain cycles.  Thus, the graph will be a Directed Acyclic Graph (DAG).\r\n![fig](../Figures/126/126B.png)\r\nNow for the easy part, think of the previous graph as a bunch of layers and observe that once we reach a particular layer we don't want the future words to have the connection back to this layer. We will build our DAG using BFS.  We will then add all the directed edges from the words present in the current layer and once all words in this layer have been traversed, we will remove them from the `wordList`. This way we will avoid adding any edges that point towards `beginWord`.\r\n\r\nAfter constructing the graph, we can use our same backtracking approach to find the shortest paths between `beginWord` and `endWord`. Also, note that in the graph all paths between `beginWord` and `endWord`, obtained through BFS, will be the shortest possible. This is because all the edges in the graph will be directed in the direction of `beginWord` to `endWord`.  Furthermore, there will not be any edge between the words that are on the same level.  Therefore, iterating over any edge will bring us one step closer to the `endWord`, thus there is no need to compare the length of the path each time we reach the `endWord`.\r\n\r\n**Algorithm**\r\n\r\n1.\tStore the words present in `wordList` in an unordered set so that the words can be efficiently removed during the breadth-first search.\r\n\r\n2.\tPerform the BFS, and add the edges to the adjacency list `adjList`. Also once a level is finished remove the `visited` words from the `wordList`.\r\n\r\n3.\tStart from `beginWord` and while keep tracking of the current path as `currPath` traverse all the possible paths, whenever the path leads to the `endWord` store the path in `shortestPaths`.\r\n\r\n**Implementation**\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/SedpZWux/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"SedpZWux\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(NK^2 + \u03b1)$$.\r\n\r\n  Here $$N$$ is the number of words in `wordList`, $$K$$ is the maximum length of a word, $$\u03b1$$ is the number of possible paths from `beginWord` to `endWord` in the directed graph we have.\r\n\r\n  Copying the `wordList` into the set will take $${O}(N)$$.\r\n\r\n  In BFS, every word will be traversed and for each word, we will find the neighbors using the function `findNeighbors` which has a time complexity of $O(K^2)$. Therefore the total complexity for all the `N` words will be $O(NK^2)$. Also, each word will be enqueued and will be removed from the set hence it will take $${O}(N)$$. The total time complexity of BFS will therefore be equal to $O(NK^2 )$.\r\n\r\n  While backtracking, we will essentially be finding all the paths from `beginWord` to \r\n `endWord`. Thus the time complexity will be equal to $O(\u03b1)$.\r\n\r\n  We can estimate the upper bound for $$\u03b1$$ by assuming that every layer except the first and the last layer in the DAG has $$x$$ number of words and is fully connected to the next layer. Let $$h$$ represent the height of the DAG, so the total number of paths will be $$x^h$$ (because we can choose any one word out of $$x$$ words in each layer and each choice will be part of a valid shortest path that leads to the `endWord`). Here, $$h$$ equals $$(N-2)/x$$. This would result in $$x^{(N-2)/x}$$ total paths, which is maximized when $$x = 2.718$$, which we will round to $$3$$ because $$x$$ must be an integer. Thus the upper bound for $$\u03b1$$ is $$3^{(N/3)}$$, however, this is a very loose bound because the nature of this problem precludes the possibility of a DAG where every layer is fully connected to the next layer.\r\n\r\n  The total time complexity is therefore equal to $$O(NK^2 + \u03b1)$$.\r\n\r\n* Space complexity: $${O}(NK)$$.\r\n  \r\n  Here $$N$$ is the Number of words in `wordList`, $$K$$ is the Maximum length of a word.\r\n  \r\n  Storing the words in a set will take $${O}(NK)$$ space.\r\n  \r\n  To build the adjacency list $${O}(N)$$ space is required as the BFS will produce a directed \r\n  graph and hence there will be at max $$(N - 1)$$ edges.\r\n  \r\n  In backtracking, stack space will be consumed which will be equal to the maximum number of active functions in the stack which is equal to the $N$ as the path can have all the words in the `wordList`. Hence space required is $${O}(N)$$.\r\n\r\n  The total space complexity is therefore equal to $${O}(NK)$$.\r\n\r\n<br/>\r\n\r\n---\r\n\r\n#### Approach 2: Bidirectional Breadth-First Search (BFS) + Backtracking\r\n\r\n**Intuition**\r\n\r\nThis approach is very similar to the previous one in that both approaches will use the same Directed Acyclic Graph (DAG). The difference lies in the way that the graph is produced, which is better optimized in this case.\r\n\r\nIn the previous solution, we performed BFS starting from `beginWord` and explored down the ladder until we reached `endWord`.  However, now we will start from `beginWord` stored in `forwardQueue` and from `endWord` stored in `backwardQueue` and explore towards the middle of the ladder. At each iteration, we will connect the words to their neighbors, which we will find using `findNeighbors`. At each iteration, we will have two options, either to connect edges using the`forwardQueue` or by using the `backwardQueue`. The optimal choice is to use the queue that contains fewer words. In this solution, for simplicity, we will swap `forwardQueue` and `backwardQueue` whenever `forwardQueue` is larger.  In doing so, we will always choose the `forwardQueue`.\r\n\r\nWe will traverse the `forwardQueue` find the neighbors of each of the words present using `findNeighbors` and add the edge to the `adjList`.  We will also store the next layer words in the `visited` list. Once a level is finished we can assign the `forwardQueue` to `visited`.  We will repeat this process until either the size of `forwardQueue` becomes zero, signifying that there is no valid sequence from `beginWord` to `endWord`, or until the contents of `forwardQueue` and `backwardQueue` overlap.  The reason for stopping when `forwardQueue` and `backwardQueue` overlap is because after completing this level, it is guaranteed that `beginWord` and `endWord` will be connected by at least one sequence that that passes through the words that exist in both queues.  Thus, the DAG will be completed.\r\n\r\nThe remaining process is the same as Approach 1, once the queue has been traversed, at each iteration, we will remove those words from the `wordList` to avoid including any edges to previous layers. Once the graph is complete, we will use backtracking to find all of the paths between `beginWord `and `endWord`.\r\n\r\n**Algorithm**\r\n\r\n1.\tStore the words present in `wordList` in an unordered set so that the words can be efficiently removed during the breadth-first search.\r\n\r\n2.\tPerform a bidirectional BFS.  Initialize two queues, `forwardQueue` with `beginWord` and `backwardQueue` with `endWord`. At each iteration add the edges to the adjacency list `adjList` by extending the shorter queue. The parameter `direction` is used to decide in which direction the edges should be connected, where `1` indicates towards `endWord` (down the ladder) and vice versa. Also once a level is finished, remove the `forwardQueue` words from the `wordList`.\r\n\r\n3.\tIf a sequence connecting `beginWord` to `endWord` does not exist, return an empty list. Otherwise, start from `beginWord` and while keeping track of the current path as `currPath` traverse all the possible paths, whenever the path leads to the `endWord` store the path in `shortestPaths`.\r\n\r\n**Implementation**\r\n\r\n\r\n<iframe src=\"https://leetcode.com/playground/9qoB7yfc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9qoB7yfc\"></iframe>\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$O(NK^2 + \u03b1)$$.\r\n\r\n  Here $$N$$ is the Number of words in `wordList`, $$K$$ is the maximum length of a word, $$\u03b1$$ is the Number of possible paths from `beginWord` to `endWord` in the directed graph we have.\r\n\r\n  Copying the `wordList` into the set will take $${O}(N)$$.\r\n\r\n  In the worst-case scenario, the number of operations in the bidirectional BFS will be equal to the BFS approach discussed before. However, in some cases, this approach will perform better because the search space is reduced by selecting the shorter queue at each iteration.   In bidirectional BFS, at most, every word will be traversed once, and for each word, we will find the neighbors using the function `findNeighbors` which has a time complexity of $O(K^2)$. Therefore the total complexity for all the `N` words will be $O(NK^2)$. Also, each word will be enqueued and will be removed from the set which will take $${O}(N)$$. Thus, the total time complexity of bidirectional BFS will be $O(NK^2)$.\r\n\r\n  In the backtracking process, we will essentially find all of the paths from `beginWord` to `endWord`. Thus, the time complexity is equal to $O(\u03b1)$.\r\n\r\n  We can estimate the upper bound for $$\u03b1$$ by assuming that every layer except the first and the last layer in the DAG has $$x$$ number of words and is fully connected to the next layer. Let $$h$$ represent the height of the DAG, so the total number of paths will be $$x^h$$ (because we can choose any one word out of $$x$$ words in each layer and each choice will be part of a valid shortest path that leads to the `endWord`). Here, $$h$$ equals $$(N-2)/x$$. This would result in $$x^{(N-2)/x}$$ total paths, which is maximized when $$x = 2.718$$, which we will round to $$3$$ because $$x$$ must be an integer. Thus the upper bound for $$\u03b1$$ is $$3^{(N/3)}$$, however, this is a very loose bound because the nature of this problem precludes the possibility of a DAG where every layer is fully connected to the next layer.\r\n\r\n  The total time complexity is therefore equal to $$O(NK^2 + \u03b1)$$.\r\n\r\n* Space complexity: $${O}(NK)$$.\r\n  \r\n  Here $$N$$ is the Number of words in `wordList`, $$K$$ is the Maximum length of a word.\r\n  \r\n  Storing the words in a set will take $${O}(NK)$$ space.\r\n  \r\n  To build the adjacency list $${O}(N)$$ space is required as the BFS will produce a directed graph and hence there will be at most $$(N - 1)$$ edges. Also, in the worst-case scenario, the combined size of both queues will be equal to $$N$$.\r\n  \r\n  In backtracking, stack space will be consumed which will be equal to the maximum number of active functions in the stack, which is equal to the $N$ as the path can have all the words in the `wordList`. Hence the space required is $${O}(N)$$.\r\n\r\n  The total space complexity is therefore equal to $${O}(NK)$$.\r\n    \r\n\r\n<br/>\r\n\r\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1153",
            "count": 56,
            "average": "4.161",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "word-ladder-ii",
    "playgroundData": {
        "SedpZWux": {
            "playground": {
                "testcaseInput": "",
                "name": "word-ladder-ii-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "9qoB7yfc": {
            "playground": {
                "testcaseInput": "",
                "name": "word-ladder-ii-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}