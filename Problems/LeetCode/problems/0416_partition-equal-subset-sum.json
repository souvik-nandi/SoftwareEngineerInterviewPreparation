{
    "id": "416",
    "question": {
        "questionId": "416",
        "questionFrontendId": "416",
        "boundTopicId": null,
        "title": "Partition Equal Subset Sum",
        "titleSlug": "partition-equal-subset-sum",
        "content": "<p>Given a <strong>non-empty</strong> array <code>nums</code> containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,11,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The array can be partitioned as [1, 5, 5] and [11].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The array cannot be partitioned into equal sum subsets.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Medium",
        "likes": 8065,
        "dislikes": 128,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Partition to K Equal Sum Subsets\", \"titleSlug\": \"partition-to-k-equal-sum-subsets\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimize the Difference Between Target and Chosen Elements\", \"titleSlug\": \"minimize-the-difference-between-target-and-chosen-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Ways to Partition an Array\", \"titleSlug\": \"maximum-number-of-ways-to-partition-an-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Partition Array Into Two Arrays to Minimize Sum Difference\", \"titleSlug\": \"partition-array-into-two-arrays-to-minimize-sum-difference\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[1,5,11,5]\n[1,2,3,5]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Infosys\", \"slug\": \"infosys\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 14}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Walmart Global Tech\", \"slug\": \"walmart-labs\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Splunk\", \"slug\": \"splunk\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"tcs\", \"slug\": \"tcs\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Intuit\", \"slug\": \"intuit\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 0}]}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public boolean canPartition(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def canPartition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nbool canPartition(int* nums, int numsSize){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public bool CanPartition(int[] nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_partition(nums)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func canPartition(_ nums: [Int]) -> Bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func canPartition(nums []int) bool {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def canPartition(nums: Array[Int]): Boolean = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun canPartition(nums: IntArray): Boolean {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn can_partition(nums: Vec<i32>) -> bool {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canPartition($nums) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function canPartition(nums: number[]): boolean {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (can-partition nums)\n  (-> (listof exact-integer?) boolean?)\n\n  )",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec can_partition(Nums :: [integer()]) -> boolean().\ncan_partition(Nums) ->\n  .",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule Solution do\n  @spec can_partition(nums :: [integer]) :: boolean\n  def can_partition(nums) do\n\n  end\nend",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"478.3K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 478300, \"totalSubmissionRaw\": 1024948, \"acRate\": \"46.7%\"}",
        "hints": [],
        "solution": {
            "id": "1000",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": true,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[1,5,11,5]",
        "metaData": "{\r\n  \"name\": \"canPartition\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": null,
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1000",
        "content": "[TOC]\n\n## Video Solution\n---\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/487088932?texttrack=en\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n---\n\n#### Overview ####\n\nThe problem is similar to the classic _Knapsack_ problem. The basic idea is to understand that to partition an array into two subsets of equal sum say $$\\text{subSetSum}$$,  the $$\\text{totalSum}$$ of given array must be twice the $$\\text{subSetSum}$$\n\n$$\\text{totalSum} = \\text{subSetSum} * 2$$\n\nThis could also be written as,\n$$\\text{subSetSum} = \\text{totalSum}/2$$\n\n_Example_\nAssume $$\\text{totalSum}$$ of an array is $$20$$ and if we want to partition it into 2 subsets of equal sum, then the $$\\text{subSetSum}$$ must be $$(20/2) = 10$$.\n\nNow, the problem to find the subset with a sum equals a given target. Here target is $$\\text{subSetSum}$$.\n\nIt must be noted that the total sum of an array must be _even_, only then we can divide it into 2 equal subsets. For instance, we cannot have an equal $$\\text{subSetSum}$$ for an array with total sum as $$21$$.\n\n**Note:**\n\n>Finding a subset with a sum equal to a given target is different than [Subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/). Subarray is a contiguous sequence of array elements, whereas the subset could consist of any array elements regardless of the sequence. But each array element must belong to exactly one subset.\n\nLet's discuss different algorithms to find the subset with a given sum.\n\n---\n\n#### Approach 1: Brute Force\n\n**Intuition**\n\nWe have to find a subset in an array where the sum must be equal to $$\\text{subSetSum}$$ that we calculated above. The brute force approach would be to generate all the possible subsets of an array and return true if we find a subset with the required sum.\n\n**Algorithm**\n\nAssume, there is an array $$\\text{nums}$$ of size $$n$$ and we have to find if there exists a subset with total $$\\text{sum} = \\text{subSetSum}$$.\nFor a given array element $$x$$, there could be either of 2 possibilities:\n\n- Case 1) $$x$$ is included in subset sum. $$\\text{subSetSum} = \\text{subSetSum} - x$$\n\n- Case 2) $$x$$ is not included in subset sum, so we must take previous sum without $$x$$. $$\\text{subSetSum} = \\text{subSetSum}$$\n\nWe can use _depth first search_ and recursively calculate the $$\\text{subSetSum}$$ for each case and check if either of them is true. This can be formulated as\n\n```java\nisSum (subSetSum, n) = isSum(subSetSum- nums[n], n-1) ||  isSum(subSetSum, n-1)\n```\n\n_Base Cases_\n\n- If $$\\text{subSetSum}$$ is $$0$$, return _true_ ( Since we found a subset with sum subSetSum )\n- If $$\\text{subSetSum}$$ is less than $$0$$, return _false_\n\n<iframe src=\"https://leetcode.com/playground/DDSLErcB/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"DDSLErcB\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(2^{n})$$, where $$n$$ is equal to number of array elements.\nThe recursive solution takes the form of a binary tree where there are 2 possibilities for every array element and the maximum depth of the tree could be $$n$$.  The time complexity is exponential, hence this approach is exhaustive and results in _Time Limit Exceeded (TLE)_.\n\n- Space Complexity: $$\\mathcal{O}(N)$$ This space will be used to store the recursion stack. We can\u2019t have more than $$n$$ recursive calls on the call stack at any time.\n\n---\n\n#### Approach 2: Top Down Dynamic Programming - Memoization\n\n**Intuition**\n\nIn the above approach, we observe that the same subproblem is computed and solved multiple times.\n\nExample :\n\n![img](../Figures/416/subset_sum_rec_tree.png)\n\nIn the above recursion tree, we could see that   $$\\text{isSum}( 3,[6] )$$  is computed twice and the result is always the same. Since the same subproblem is computed again and again, the problem has _Overlapping Subproblem_ property and can be solved using _Dynamic Programming_.\n\n**Algorithm**\n\n We could have stored the results of our computation for the first time and used it later.\n This technique of computing once and returning the stored value is called memoization.\nWe use a two dimensional array $$\\text{memo}$$ and follow the following steps for each recursive call :\n- Check if subSetSum for a given $$n$$ exists in $$\\text{memo}$$ to see if we can avoid computing the answer and return the result stored in memo.\n- Save the results of any calculations to $$\\text{memo}$$.\n\n<iframe src=\"https://leetcode.com/playground/nshd3XDH/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"nshd3XDH\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the number of array elements and $$m$$ be the $$\\text{subSetSum}$$.\n\n- Time Complexity : $$\\mathcal{O}(m \\cdot n)$$.\n\n    - In the worst case where there is no overlapping calculation, the maximum number of entries in the `memo` would be $$m \\cdot n$$. For each entry, overall we could consider that it takes constant time, _i.e._ each invocation of `dfs()` at most emits one entry in the `memo`.\n\n    - The overall computation is proportional to the number of entries in `memo`. Hence, the overall time complexity is $$\\mathcal{O}(m \\cdot n)$$.\n\n- Space Complexity: $$\\mathcal{O}(m \\cdot n)$$. We are using a 2 dimensional array $$\\text{memo}$$ of size $$(m \\cdot n)$$ and $$\\mathcal{O}(n)$$ space to store the recursive call stack. This gives us the space complexity as $$\\mathcal{O}(n)$$ + $$\\mathcal{O}(m \\cdot n)$$ = $$\\mathcal{O}(m \\cdot n)$$\n\n---\n\n#### Approach 3: Bottom Up Dynamic Programming\n\n**Intuition**\n\nThis is another approach to solving the Dynamic Programming problems. We use the iterative approach and store the result of subproblems in bottom-up fashion also known as Tabulation.\n\n**Algorithm**\n\nWe maintain a 2D array ,\n$$\\text{dp}[n][\\text{subSetSum}]$$\nFor an array element $$i$$ and sum $$j$$ in array $$\\text{nums}$$,\n\n$$\\text{dp}[i][j] =\n\\text{true}$$ if the sum $$j$$ can be formed by array elements in subset $$\\text{nums[0]} .. \\text{nums[i]}$$,otherwise $$\\text{dp}[i][j] = \\text{false}$$\n\n$$\\text{dp}[i][j]$$ is $$\\text{true}$$ it satisfies one of the following conditions :\n\n- Case 1) sum $$j$$ can be formed without including $$i^{th}$$ element,\n\n$$\\text{if } \\text{dp}[i-1][j] ==   \\text{true}$$\n\n- Case 2) sum $$j$$ can be formed including $$i^{th}$$ element,\n\n$$\\text{if } \\text{dp}[i-1][j - \\text{nums}[i]] == \\text{true}$$\n\n!?!../Documents/416_LIS.json:1094,378!?!\n\n<iframe src=\"https://leetcode.com/playground/Afe5UKz8/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Afe5UKz8\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(m \\cdot n)$$, where $$m$$ is the $$\\text{subSetSum}$$, and $$n$$ is the number of array elements. We iteratively fill the array of size $$m \\cdot n$$.\n\n- Space Complexity : $$\\mathcal{O}(m \\cdot n)$$ , where $$n$$ is the number of array elements and $$m$$ is the $$\\text{subSetSum}$$. We are using a 2 dimensional array $$\\text{dp}$$ of size $$m \\cdot n$$\n\n---\n\n#### Approach 4: Optimised Dynamic Programming - Using 1D Array\n\n**Intuition**\n\nWe could further optimize _Approach 3_. We must understand that for any array element $$i$$, we need results of the previous iteration (i-1) only. Hence, we could achieve the same using a one-dimensional array as well.\n\n<iframe src=\"https://leetcode.com/playground/d3H3HUid/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"d3H3HUid\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(m \\cdot n)$$, where $$m$$ is the $$\\text{subSetSum}$$, and $$n$$ is the number of array elements. The time complexity is the same as _Approach 3_.\n\n- Space Complexity: $$\\mathcal{O}(m)$$, As we use an array of size $$m$$ to store the result of subproblems.\n\n**Note:**\n\nThe overall performance of _Approach 2_ is better than all the approaches discussed above. This is because we terminate our search as soon as we find a subset with the required sum. Hence, it performs better in most cases except for the worst case.",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": true,
        "paidOnlyVideo": true,
        "rating": {
            "id": "945",
            "count": 110,
            "average": "4.627",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "partition-equal-subset-sum",
    "playgroundData": {
        "DDSLErcB": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-equal-subset-sum-3",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "nshd3XDH": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-equal-subset-sum-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "Afe5UKz8": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-equal-subset-sum-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "d3H3HUid": {
            "playground": {
                "testcaseInput": "",
                "name": "partition-equal-subset-sum-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}