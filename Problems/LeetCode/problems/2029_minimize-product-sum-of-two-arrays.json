{
    "id": "2029",
    "question": {
        "questionId": "2029",
        "questionFrontendId": "1874",
        "boundTopicId": null,
        "title": "Minimize Product Sum of Two Arrays",
        "titleSlug": "minimize-product-sum-of-two-arrays",
        "content": "<p>The <b>product sum </b>of two equal-length arrays <code>a</code> and <code>b</code> is equal to the sum of <code>a[i] * b[i]</code> for all <code>0 &lt;= i &lt; a.length</code> (<strong>0-indexed</strong>).</p>\r\n\r\n<ul>\r\n\t<li>For example, if <code>a = [1,2,3,4]</code> and <code>b = [5,2,3,1]</code>, the <strong>product sum</strong> would be <code>1*5 + 2*2 + 3*3 + 4*1 = 22</code>.</li>\r\n</ul>\r\n\r\n<p>Given two arrays <code>nums1</code> and <code>nums2</code> of length <code>n</code>, return <em>the <strong>minimum product sum</strong> if you are allowed to <strong>rearrange</strong> the <strong>order</strong> of the elements in </em><code>nums1</code>.&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums1 = [5,3,4,2], nums2 = [4,2,2,5]\r\n<strong>Output:</strong> 40\r\n<strong>Explanation:</strong>&nbsp;We can rearrange nums1 to become [3,5,4,2]. The product sum of [3,5,4,2] and [4,2,2,5] is 3*4 + 5*2 + 4*2 + 2*5 = 40.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums1 = [2,1,4,5,7], nums2 = [3,2,4,8,6]\r\n<strong>Output:</strong> 65\r\n<strong>Explanation: </strong>We can rearrange nums1 to become [5,7,4,1,2]. The product sum of [5,7,4,1,2] and [3,2,4,8,6] is 5*3 + 7*2 + 4*4 + 1*8 + 2*6 = 65.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>n == nums1.length == nums2.length</code></li>\r\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\r\n</ul>",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": true,
        "difficulty": "Medium",
        "likes": 162,
        "dislikes": 22,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Choose Numbers From Two Arrays in Range\", \"titleSlug\": \"choose-numbers-from-two-arrays-in-range\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[5,3,4,2]\n[4,2,2,5]\n[2,1,4,5,7]\n[3,2,4,8,6]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Greedy",
                "slug": "greedy",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Sorting",
                "slug": "sorting",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class Solution {\npublic:\n    int minProductSum(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class Solution {\n    public int minProductSum(int[] nums1, int[] nums2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class Solution(object):\n    def minProductSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class Solution:\n    def minProductSum(self, nums1: List[int], nums2: List[int]) -> int:\n        ",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\nint minProductSum(int* nums1, int nums1Size, int* nums2, int nums2Size){\n\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class Solution {\n    public int MinProductSum(int[] nums1, int[] nums2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar minProductSum = function(nums1, nums2) {\n    \n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer}\ndef min_product_sum(nums1, nums2)\n    \nend",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "class Solution {\n    func minProductSum(_ nums1: [Int], _ nums2: [Int]) -> Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "func minProductSum(nums1 []int, nums2 []int) int {\n    \n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "object Solution {\n    def minProductSum(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class Solution {\n    fun minProductSum(nums1: IntArray, nums2: IntArray): Int {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "impl Solution {\n    pub fn min_product_sum(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer\n     */\n    function minProductSum($nums1, $nums2) {\n        \n    }\n}",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "function minProductSum(nums1: number[], nums2: number[]): number {\n\n};",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define/contract (min-product-sum nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n\n  )",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"12.9K\", \"totalSubmission\": \"14.2K\", \"totalAcceptedRaw\": 12909, \"totalSubmissionRaw\": 14216, \"acRate\": \"90.8%\"}",
        "hints": [
            "Is there a particular way we should order the arrays such that the product sum is minimized?",
            "Would you want to multiply two numbers that are closer to one another or further?"
        ],
        "solution": {
            "id": "1316",
            "canSeeDetail": true,
            "paidOnly": false,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[5,3,4,2]\n[4,2,2,5]",
        "metaData": "{\n  \"name\": \"minProductSum\",\n  \"params\": [\n    {\n      \"name\": \"nums1\",\n      \"type\": \"integer[]\"\n    },\n    {\n      \"type\": \"integer[]\",\n      \"name\": \"nums2\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "896",
            "date": "2022-04-08",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "WEEKLY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "1316",
        "content": "[TOC]\n\n## Solution\n\n--- \n#### Overview\n\nIn this problem, we are given two arrays $$ \\text{nums1} $$ and $$ \\text{nums2} $$ of the same length. Let's assume that $$ \\text{nums1} = [a_1, a_2, ... , a_n] $$, $$ \\text{nums2} = [b_1, b_2, ... , b_n]$$, their **product sum** is defined as:\n$$ \\text{product\\_sum} = a_1 \\cdot b_1 + a_2 \\cdot b_2 + ... + a_n \\cdot b_n $$.\n\n\nWe are allowed to freely rearrange the order of the elements in $$\\text{nums1}$$. After doing so, this operation might result in a different **product sum**. Take the figure below as an example: \n\n\n![img](../Figures/1874/1874-intro.png)\n\nOur goal is to find the minimum **product sum** of $$\\text{nums1}$$ and $$\\text{nums2}$$.\n\n---\n\n#### Approach 1: Sort both arrays\n\n**Intuition**   \n\nFor convenience, let's temporarily disregard the restriction on $$\\text{nums2}$$ and assume that we can freely sort both arrays.\n\nStart from the base case, given $$\\text{nums1} = [a1, a2]$$ and $$\\text{nums2} = [b1, b2]$$ respectively, assume that: \n- $$a1 \\leqslant a2$$ \n- $$b1 \\leqslant b2$$\n\nAs shown in the figure below, these two arrays have two possible product sums:\n- $$\\text{sum1} = a_1 \\cdot b_1 + a_2 \\cdot b_2$$\n- $$\\text{sum2} = a_1 \\cdot b_2 + a_1 \\cdot b_2$$\n\n\n![img](../Figures/1874/1874-1.png)\n\nIt shows that: if we pair them as $${a_1 \\times b_2}$$ and $${a_2 \\times b_1}$$, their product sum is smaller than that of the other case. \n\n\n> Can we extend the conclusion of the base case to a more general case? In other words, will this rule work for longer arrays?\n\nSuppose that we have two arrays with certain orders so that their product sum is minimized. We randomly select two indexes $$i, j$$ and the corresponding elements from $$\\text{nums1}$$ and $$\\text{nums2}$$, namely: $$\\text{nums1}[i], \\text{nums1}[j], \\text{nums2}[i]$$, and $$\\text{nums2}[j]$$.\n\n\n> Assume $$i < j$$, what should the order of $$a_i,\\  a_j$$ and $$b_i,\\ b_j$$ be?\n\nIn the previous section, we demonstrated that: in order to obtain the minimum product sum of two arrays of size 2: \n- If $$a_i \\leqslant a_j$$, then $$b_i \\geqslant b_j$$ must hold.\n- If $$a_i \\geqslant a_j$$, then $$b_i \\leqslant b_j$$ must hold.\n\nFor this example, let's assume $$\\text{nums1}$$ is sorted in ascending order, that is: $$a_i \\leqslant a_j$$ if $$i < j$$. \nLet's also assume $$b_i \\geqslant b_j$$ for $$b_i, b_j$$ from $$\\text{nums2}$$, that is, $$\\text{nums2}$$ is sorted in descending order.  \n\n\n![img](../Figures/1874/1874-2.png)\n\n> This is equivalent to saying that $$\\text{nums2}$$ is sorted in descending order!\n\n![img](../Figures/1874/1874-3.png)\n\nTherefore, if $$\\text{nums1}$$ is sorted in ascending order, then we must sort $$\\text{nums2}$$ in **descending** order to get the minimum product sum!\n\n> Recall that we temporarily ignored the restriction that says we can only sort $$\\text{nums1}$$. Did sorting $$\\text{nums1}$$ and $$\\text{nums2}$$ allow us to obtain a smaller product sum than we could obtain by only sorting $$\\text{nums1}$$?\n\nThe answer is No. Suppose we sort $$\\text{nums1}$$ and $$\\text{nums2}$$ accordingly. We can always rearrange the relative order of these **element pairs** according to the original $$\\text{nums2}$$. Then the rearranged $$\\text{nums1}$$ can be obtained by reordering it. In other words, any product sum obtained from reordering both arrays can also be obtained from only reordering one array.\n\nTake the picture below as an example.\n\n![img](../Figures/1874/1874-sort_ornot.png)\n\n\n\n**Algorithm**\n\n1) Sort $$\\text{nums1}$$ in ascending order and $$\\text{nums2}$$ in descending order.\n2) Initialize the product sum $$\\text{ans}$$ as 0.\n3) Iterate over both sorted arrays and update the cumulative product sum.\n4) Return $$\\text{ans}$$.\n\n\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/9EPvQ6wc/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"9EPvQ6wc\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of the input arrays $$\\text{nums1}$$ and $$\\text{nums2}$$.\n\n* Time complexity: $$O(n\\cdot \\log n)$$\n\n    - We sort $$\\text{nums1}$$ and $$\\text{nums2}$$, each takes $$O(n\\cdot \\log n)$$ time.\n    - Then we iterate over the two sorted arrays to calculate the cumulative product sum, at step $$i$$ we need to calculate $$\\text{nums1}[i] \\cdot \\text{nums2}[i]$$ which takes constant time. This iteration takes $$O(n)$$ time.\n    - To sum up, the overall time complexity is $$O(n\\cdot \\log n)$$\n    \n\n* Space complexity: $$O(n)$$\n    - Some extra space is used when we sort $$\\text{nums1}$$ and $$\\text{nums2}$$ in place. The space complexity of the sorting algorithm depends on the programming language.\n        - In python, the `sort` method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses $$O(n)$$ additional space.\n        - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of $$O(\\log n)$$.\n        - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $$O(\\log n)$$.\n    - We then traverse both arrays and calculate the cumulative product sum, this step takes $$O(1)$$ extra space.\n    - To sum up, the overall space complexity is $$O(n)$$ for Python and $$O(\\log n)$$ for C++ and Java.\n\n<br/>\n\n---\n\n#### Approach 2: PriorityQueue\n\n**Intuition**   \n\nIn the previous approach, we sorted both $$\\text{nums1}$$ and $$\\text{nums2}$$. Recall the restriction on $$\\text{nums2}$$. So in this approach, we will just sort $$\\text{nums1}$$ in ascending order and keep $$\\text{nums2}$$ as it is. However, we can use a PriorityQueue $$\\text{pq}$$ to store all the elements from $$\\text{nums2}$$, thus we can get the elements from $$\\text{nums2}$$ in sorted order without actually 'sorting' $$\\text{nums2}$$. \n\nIn the previous approach, we iterated over the elements of $$\\text{nums2}$$ by their descending values. Similarly, we can get the elements from $$\\text{nums2}$$ in descending order by implementing a PriorityQueue $$\\text{pq}$$ as a Max-Heap; in each step during the iteration, we pop the top element - the largest element from the $$\\text{pq}$$. Therefore, we can repeatedly accumulate the product of each element from $$\\text{nums1}$$ with the top element in $$\\text{pq}$$, which is equivalent to iterating over decreasingly sorted $$\\text{nums2}$$.\n\n\n**Algorithm**\n\n1) Sort $$\\text{nums1}$$ in ascending order.\n2) Initialize the product sum $$\\text{ans}$$ as 0.\n3) Initialize an empty PriorityQueue $$\\text{pq}$$ and add every element of $$\\text{nums}$$ to $$\\text{pq}$$.\n4) Iterate over the sorted arrays $$\\text{nums1}$$. For each element in $$\\text{nums1}$$, calculate its product with the top element in $$\\text{pq}$$, then pop the top element from $$\\text{pq}$$.\n5) After finishing the iteration in step 4, return $$\\text{ans}$$.\n\n\n<iframe src=\"https://leetcode.com/playground/5XrSUYdb/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"5XrSUYdb\"></iframe>\n\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of the input array $$\\text{nums1}$$ and $$\\text{nums2}$$.\n\n* Time complexity: $$O(n\\cdot \\log n)$$\n\n    - We create a max heap with the elements in $$\\text{nums2}$$. This requires $$O(n \\log n)$$ time if we push each element into the heap one by one and $$O(n)$$ time if we use the heapify method.  \n    - During the iteration, we repeatedly pop the top element from $$\\text{pq}$$, it takes $$O(n\\cdot \\log n)$$ time to pop $$n$$ elements.\n    - To sum up, the overall time complexity is $$O(n\\cdot \\log n)$$.\n    \n    \n* Space complexity: $$O(n)$$\n\n    - We initialize a PriorityQueue $$\\text{pq}$$ to keep all the elements from $$\\text{nums2}$$, which takes $$O(n)$$ space.\n    - Some extra space is used when we sort $$\\text{nums1}$$ in place. The space complexity of the sorting algorithm depends on the programming language.\n        - In python, the `sort` method sorts a list using Timesort algorithm which is a combination of Merge Sort and Insertion Sort, and has $$O(n)$$ additional space.\n        - In C++, the sort() fucntion is implemented as a hybrid of Quick Sort, Heap Sort and Insetion Sort, with a worse-case sapce complexity of $$O(\\log n)$$.\n        - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $$O(\\log n)$$.\n    - In the iteration, we repeatedly pop the top element from $$\\text{pq}$$ and calculate the product of each pair and update the product sum, which only takes constant space.\n    - Therefore, the overall space complexity is $$O(n)$$.\n\n\n<br/>\n\n---\n\n#### Approach 3: Counting Sort\n\n**Intuition**   \n\nThe constraints of integers in the input arrays is $$1 \\leq \\text{nums1}[i], \\text{nums2}[i] \\leq 100$$. Notice that the valid range of elements is quite small compared with the scale of the array. Therefore, it seems like a promising method is Counting Sort, which has linear time complexity and space complexity.\n\n\n>What is Counting Sort?\n\nFor a detailed introduction, you can refer to this article on [Counting Sort](https://en.wikipedia.org/wiki/Counting_sort).\n\nIn short, Counting Sort is not a comparison sort; thus, the $$O(n \\cdot \\log(n))$$ time complexity for comparison sorting does not apply. To perform a Counting Sort, we create an empty auxiliary array ($$\\text{counter1}$$), and for each number in $$\\text{nums1}$$, we increment $$\\text{counter1[index]}$$ where the index is based on the number's value. \n\n>How do we determine the size of the auxiliary array? \n\nGiven the constraints of integers in the input arrays as $$1 \\leq nums1[i], nums2[i] \\leq 100$$, using an auxiliary array with a length of 101 is enough to cover all the possible values within the given range. We let $$counter1[1]$$ represent the number of occurrences of all 1's, $$counter1[2]$$ represent the number of occurrences of all 2's, so on so forth. Hence we have built a bijection, a one-to-one correspondence between the element value in $$\\text{nums1}$$ and the index of $$counter1$$. As shown in the figure below.\n\n![img](../Figures/1874/1874-c1.png)\n\nMore specifically, let's take a look at the slides below as an example of how we sort $$\\text{nums1}$$ using Counting Sort. All the elements in $$\\text{counter1}$$ are initialized as 0 since we haven't count the occurrence of any number yet. Then we traverse $$\\text{nums1}$$, for each number $$num$$ in the array, we increment its number of occurrence by 1 in $$\\text{counter1}$$, that is, let $$\\text{counter1[num]} = \\text{counter1[num]} + 1$$. Please refer to the slides below.\n\n!?!../Documents/1874/countingSort.json:601,301!?!\n\nNow we have saved the 'sorted' arrays $$\\text{nums1}$$ and $$\\text{nums2}$$ in $$\\text{counter1}$$ and $$\\text{counter2}$$ respectively, the next step is to traverse $$\\text{counter1}$$ in ascending order and $$\\text{counter2}$$ in descending order.\n\n![img](../Figures/1874/1874-c2.png)\n\nTake the slides below as an example. \n\n!?!../Documents/1874/countingSort2.json:601,301!?!\n\n\n**Algorithm**\n\n1) Initialize two empty arrays $$\\text{counter1}$$ and $$\\text{counter2}$$ of length 101 as counters, initialize the product sum as $$\\text{ans} = 0$$.\n2) Iterate over $$\\text{nums1}$$ and update $$\\text{counter1}$$, the occurrence of each element, during the iteration.\n3) Iterate over $$\\text{nums2}$$ and update $$\\text{counter2}$$, the occurrence of each element, during the iteration.\n4) Initialize two 'pointers' $$p1 = 1$$, $$p2 = 100$$, stands for the index of $$\\text{counter1}$$ and $$\\text{counter2}$$ respectively.\n5) Calculate the cumulative product sum $$\\text{ans}$$ of each pair of elements.\n6) Return $$\\text{ans}$$.\n\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/gMA2sUNK/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gMA2sUNK\"></iframe>\n\n**Complexity Analysis**\n\nLet $$n$$ be the length of the input array $$\\text{nums1}$$ and $$\\text{nums2}$$, and $$k$$ be the range of values in $$\\text{nums1}$$ or $$\\text{nums2}$$.\n\n* Time complexity: $$O(n + k)$$\n    - We need to traverse both the input arrays once. In each step during the iteration, we increment the count of the current number by 1 in $$\\text{counter1}$$ or $$\\text{counter2}$$; which just takes constant time. Thus each of these two traversals takes $$O(n)$$ time.\n    - Then, we traverse the two counter arrays $$\\text{counter1}$$ and $$\\text{counter2}$$, calculate the cumulative product sum, which takes $$O(k)$$ time.\n    - To sum up, the overall time complexity is $$O(n + k)$$.\n    \n\n* Space complexity: $$O(k)$$\n    - Given the range of input values, we used two arrays $$\\text{counter1}$$, $$\\text{counter2}$$ of size $$k$$ to record the number of occurrences of each number in $$\\text{nums1}$$ and $$\\text{nums2}$$, which takes $$O(k)$$ space.\n    - In the second iteration, we just need to record the cumulative product sum of the elements.\n    - To sum up, the overall space complexity is $$O(k)$$.\n\n<br/>\n\n---",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": false,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "1321",
            "count": 14,
            "average": "4.714",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "minimize-product-sum-of-two-arrays",
    "playgroundData": {
        "9EPvQ6wc": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-product-sum-of-two-arrays-2",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "5XrSUYdb": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-product-sum-of-two-arrays-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "gMA2sUNK": {
            "playground": {
                "testcaseInput": "",
                "name": "minimize-product-sum-of-two-arrays-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}