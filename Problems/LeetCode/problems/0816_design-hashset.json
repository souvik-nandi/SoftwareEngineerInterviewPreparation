{
    "id": "816",
    "question": {
        "questionId": "816",
        "questionFrontendId": "705",
        "boundTopicId": null,
        "title": "Design HashSet",
        "titleSlug": "design-hashset",
        "content": "<p>Design a HashSet without using any built-in hash table libraries.</p>\n\n<p>Implement <code>MyHashSet</code> class:</p>\n\n<ul>\n\t<li><code>void add(key)</code> Inserts the value <code>key</code> into the HashSet.</li>\n\t<li><code>bool contains(key)</code> Returns whether the value <code>key</code> exists in the HashSet or not.</li>\n\t<li><code>void remove(key)</code> Removes the value <code>key</code> in the HashSet. If <code>key</code> does not exist in the HashSet, do nothing.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n<strong>Output</strong>\n[null, null, null, true, false, null, true, null, false]\n\n<strong>Explanation</strong>\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>, <code>remove</code>, and <code>contains</code>.</li>\n</ul>\n",
        "translatedTitle": null,
        "translatedContent": null,
        "isPaidOnly": false,
        "difficulty": "Easy",
        "likes": 2156,
        "dislikes": 212,
        "isLiked": null,
        "similarQuestions": "[{\"title\": \"Design HashMap\", \"titleSlug\": \"design-hashmap\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Design Skiplist\", \"titleSlug\": \"design-skiplist\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "exampleTestcases": "[\"MyHashSet\",\"add\",\"add\",\"contains\",\"contains\",\"add\",\"contains\",\"remove\",\"contains\"]\n[[],[1],[2],[1],[3],[2],[2],[2],[2]]",
        "categoryTitle": "Algorithms",
        "contributors": [],
        "topicTags": [
            {
                "name": "Array",
                "slug": "array",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Linked List",
                "slug": "linked-list",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Design",
                "slug": "design",
                "translatedName": null,
                "__typename": "TopicTagNode"
            },
            {
                "name": "Hash Function",
                "slug": "hash-function",
                "translatedName": null,
                "__typename": "TopicTagNode"
            }
        ],
        "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}], \"3\": [{\"taggedByAdmin\": true, \"name\": \"Wix\", \"slug\": \"wix\", \"timesEncountered\": 0}], \"2\": []}",
        "codeSnippets": [
            {
                "lang": "C++",
                "langSlug": "cpp",
                "code": "class MyHashSet {\npublic:\n    MyHashSet() {\n        \n    }\n    \n    void add(int key) {\n        \n    }\n    \n    void remove(int key) {\n        \n    }\n    \n    bool contains(int key) {\n        \n    }\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj->add(key);\n * obj->remove(key);\n * bool param_3 = obj->contains(key);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Java",
                "langSlug": "java",
                "code": "class MyHashSet {\n\n    public MyHashSet() {\n        \n    }\n    \n    public void add(int key) {\n        \n    }\n    \n    public void remove(int key) {\n        \n    }\n    \n    public boolean contains(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * boolean param_3 = obj.contains(key);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python",
                "langSlug": "python",
                "code": "class MyHashSet(object):\n\n    def __init__(self):\n        \n\n    def add(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: None\n        \"\"\"\n        \n\n    def remove(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: None\n        \"\"\"\n        \n\n    def contains(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Python3",
                "langSlug": "python3",
                "code": "class MyHashSet:\n\n    def __init__(self):\n        \n\n    def add(self, key: int) -> None:\n        \n\n    def remove(self, key: int) -> None:\n        \n\n    def contains(self, key: int) -> bool:\n        \n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C",
                "langSlug": "c",
                "code": "\n\n\ntypedef struct {\n    \n} MyHashSet;\n\n\nMyHashSet* myHashSetCreate() {\n    \n}\n\nvoid myHashSetAdd(MyHashSet* obj, int key) {\n  \n}\n\nvoid myHashSetRemove(MyHashSet* obj, int key) {\n  \n}\n\nbool myHashSetContains(MyHashSet* obj, int key) {\n  \n}\n\nvoid myHashSetFree(MyHashSet* obj) {\n    \n}\n\n/**\n * Your MyHashSet struct will be instantiated and called as such:\n * MyHashSet* obj = myHashSetCreate();\n * myHashSetAdd(obj, key);\n \n * myHashSetRemove(obj, key);\n \n * bool param_3 = myHashSetContains(obj, key);\n \n * myHashSetFree(obj);\n*/",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "C#",
                "langSlug": "csharp",
                "code": "public class MyHashSet {\n\n    public MyHashSet() {\n        \n    }\n    \n    public void Add(int key) {\n        \n    }\n    \n    public void Remove(int key) {\n        \n    }\n    \n    public bool Contains(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.Add(key);\n * obj.Remove(key);\n * bool param_3 = obj.Contains(key);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "JavaScript",
                "langSlug": "javascript",
                "code": "\nvar MyHashSet = function() {\n    \n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.add = function(key) {\n    \n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.remove = function(key) {\n    \n};\n\n/** \n * @param {number} key\n * @return {boolean}\n */\nMyHashSet.prototype.contains = function(key) {\n    \n};\n\n/** \n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Ruby",
                "langSlug": "ruby",
                "code": "class MyHashSet\n    def initialize()\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Void\n=end\n    def add(key)\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Void\n=end\n    def remove(key)\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Boolean\n=end\n    def contains(key)\n        \n    end\n\n\nend\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet.new()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Swift",
                "langSlug": "swift",
                "code": "\nclass MyHashSet {\n\n    init() {\n        \n    }\n    \n    func add(_ key: Int) {\n        \n    }\n    \n    func remove(_ key: Int) {\n        \n    }\n    \n    func contains(_ key: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * let obj = MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * let ret_3: Bool = obj.contains(key)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Go",
                "langSlug": "golang",
                "code": "type MyHashSet struct {\n    \n}\n\n\nfunc Constructor() MyHashSet {\n    \n}\n\n\nfunc (this *MyHashSet) Add(key int)  {\n    \n}\n\n\nfunc (this *MyHashSet) Remove(key int)  {\n    \n}\n\n\nfunc (this *MyHashSet) Contains(key int) bool {\n    \n}\n\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(key);\n * obj.Remove(key);\n * param_3 := obj.Contains(key);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Scala",
                "langSlug": "scala",
                "code": "class MyHashSet() {\n\n    def add(key: Int) {\n        \n    }\n\n    def remove(key: Int) {\n        \n    }\n\n    def contains(key: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Kotlin",
                "langSlug": "kotlin",
                "code": "class MyHashSet() {\n\n    fun add(key: Int) {\n        \n    }\n\n    fun remove(key: Int) {\n        \n    }\n\n    fun contains(key: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Rust",
                "langSlug": "rust",
                "code": "struct MyHashSet {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyHashSet {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, key: i32) {\n        \n    }\n    \n    fn remove(&self, key: i32) {\n        \n    }\n    \n    fn contains(&self, key: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * let obj = MyHashSet::new();\n * obj.add(key);\n * obj.remove(key);\n * let ret_3: bool = obj.contains(key);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "PHP",
                "langSlug": "php",
                "code": "class MyHashSet {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function add($key) {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function remove($key) {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return Boolean\n     */\n    function contains($key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * $obj = MyHashSet();\n * $obj->add($key);\n * $obj->remove($key);\n * $ret_3 = $obj->contains($key);\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "TypeScript",
                "langSlug": "typescript",
                "code": "class MyHashSet {\n    constructor() {\n\n    }\n\n    add(key: number): void {\n\n    }\n\n    remove(key: number): void {\n\n    }\n\n    contains(key: number): boolean {\n\n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Racket",
                "langSlug": "racket",
                "code": "(define my-hash-set%\n  (class object%\n    (super-new)\n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add key)\n\n      )\n    ; remove : exact-integer? -> void?\n    (define/public (remove key)\n\n      )\n    ; contains : exact-integer? -> boolean?\n    (define/public (contains key)\n\n      )))\n\n;; Your my-hash-set% object will be instantiated and called as such:\n;; (define obj (new my-hash-set%))\n;; (send obj add key)\n;; (send obj remove key)\n;; (define param_3 (send obj contains key))",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Erlang",
                "langSlug": "erlang",
                "code": "-spec my_hash_set_init_() -> any().\nmy_hash_set_init_() ->\n  .\n\n-spec my_hash_set_add(Key :: integer()) -> any().\nmy_hash_set_add(Key) ->\n  .\n\n-spec my_hash_set_remove(Key :: integer()) -> any().\nmy_hash_set_remove(Key) ->\n  .\n\n-spec my_hash_set_contains(Key :: integer()) -> boolean().\nmy_hash_set_contains(Key) ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_hash_set_init_(),\n%% my_hash_set_add(Key),\n%% my_hash_set_remove(Key),\n%% Param_3 = my_hash_set_contains(Key),\n\n%% my_hash_set_init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            },
            {
                "lang": "Elixir",
                "langSlug": "elixir",
                "code": "defmodule MyHashSet do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec add(key :: integer) :: any\n  def add(key) do\n\n  end\n\n  @spec remove(key :: integer) :: any\n  def remove(key) do\n\n  end\n\n  @spec contains(key :: integer) :: boolean\n  def contains(key) do\n\n  end\nend\n\n# Your functions will be called as such:\n# MyHashSet.init_()\n# MyHashSet.add(key)\n# MyHashSet.remove(key)\n# param_3 = MyHashSet.contains(key)\n\n# MyHashSet.init_ will be called before every test case, in which you can do some necessary initializations.",
                "__typename": "CodeSnippetNode"
            }
        ],
        "stats": "{\"totalAccepted\": \"240.3K\", \"totalSubmission\": \"363.6K\", \"totalAcceptedRaw\": 240275, \"totalSubmissionRaw\": 363552, \"acRate\": \"66.1%\"}",
        "hints": [],
        "solution": {
            "id": "852",
            "canSeeDetail": true,
            "paidOnly": true,
            "hasVideoSolution": false,
            "paidOnlyVideo": true,
            "__typename": "ArticleNode"
        },
        "status": null,
        "sampleTestCase": "[\"MyHashSet\",\"add\",\"add\",\"contains\",\"contains\",\"add\",\"contains\",\"remove\",\"contains\"]\n[[],[1],[2],[1],[3],[2],[2],[2],[2]]",
        "metaData": "{\n  \"classname\": \"MyHashSet\",\n  \"constructor\": {\n    \"params\": []\n  },\n  \"methods\": [\n    {\n      \"params\": [\n        {\n          \"type\": \"integer\",\n          \"name\": \"key\"\n        }\n      ],\n      \"name\": \"add\",\n      \"return\": {\n        \"type\": \"void\"\n      }\n    },\n    {\n      \"params\": [\n        {\n          \"type\": \"integer\",\n          \"name\": \"key\"\n        }\n      ],\n      \"return\": {\n        \"type\": \"void\"\n      },\n      \"name\": \"remove\"\n    },\n    {\n      \"params\": [\n        {\n          \"type\": \"integer\",\n          \"name\": \"key\"\n        }\n      ],\n      \"return\": {\n        \"type\": \"boolean\"\n      },\n      \"name\": \"contains\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"boolean\"\n  },\n  \"systemdesign\": true\n}",
        "judgerAvailable": true,
        "judgeType": "large",
        "mysqlSchemas": [],
        "enableRunCode": true,
        "enableTestMode": false,
        "enableDebugger": true,
        "envInfo": "{\"cpp\": [\"C++\", \"<p>Compiled with <code> clang 11 </code> using the latest C++ 17 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level two optimization (<code>-O2</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\"], \"java\": [\"Java\", \"<p><code> OpenJDK 17 </code>. Java 8 features such as lambda expressions and stream API can be used. </p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n<p>Includes <code>Pair</code> class from https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html.</p>\"], \"python\": [\"Python\", \"<p><code>Python 2.7.12</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/2/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/2/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/2/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\\r\\n\\r\\n<p>Note that Python 2.7 <a href=\\\"https://www.python.org/dev/peps/pep-0373/\\\" target=\\\"_blank\\\">will not be maintained past 2020</a>. For the latest Python, please choose Python3 instead.</p>\"], \"c\": [\"C\", \"<p>Compiled with <code>gcc 8.2</code> using the gnu11 standard.</p>\\r\\n\\r\\n<p>Your code is compiled with level one optimization (<code>-O1</code>). <a href=\\\"https://github.com/google/sanitizers/wiki/AddressSanitizer\\\" target=\\\"_blank\\\">AddressSanitizer</a> is also enabled to help detect out-of-bounds and use-after-free bugs.</p>\\r\\n\\r\\n<p>Most standard library headers are already included automatically for your convenience.</p>\\r\\n\\r\\n<p>For hash table operations, you may use <a href=\\\"https://troydhanson.github.io/uthash/\\\" target=\\\"_blank\\\">uthash</a>. \\\"uthash.h\\\" is included by default. Below are some examples:</p>\\r\\n\\r\\n<p><b>1. Adding an item to a hash.</b>\\r\\n<pre>\\r\\nstruct hash_entry {\\r\\n    int id;            /* we'll use this field as the key */\\r\\n    char name[10];\\r\\n    UT_hash_handle hh; /* makes this structure hashable */\\r\\n};\\r\\n\\r\\nstruct hash_entry *users = NULL;\\r\\n\\r\\nvoid add_user(struct hash_entry *s) {\\r\\n    HASH_ADD_INT(users, id, s);\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>2. Looking up an item in a hash:</b>\\r\\n<pre>\\r\\nstruct hash_entry *find_user(int user_id) {\\r\\n    struct hash_entry *s;\\r\\n    HASH_FIND_INT(users, &user_id, s);\\r\\n    return s;\\r\\n}\\r\\n</pre>\\r\\n</p>\\r\\n\\r\\n<p><b>3. Deleting an item in a hash:</b>\\r\\n<pre>\\r\\nvoid delete_user(struct hash_entry *user) {\\r\\n    HASH_DEL(users, user);  \\r\\n}\\r\\n</pre>\\r\\n</p>\"], \"csharp\": [\"C#\", \"<p><a href=\\\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9\\\" target=\\\"_blank\\\">C# 10 with .NET 6 runtime</a></p>\"], \"javascript\": [\"JavaScript\", \"<p><code>Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES6 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\\r\\n\\r\\n<p>For Priority Queue / Queue data structures, you may use <a href=\\\"https://github.com/datastructures-js/priority-queue\\\" target=\\\"_blank\\\">datastructures-js/priority-queue</a> and <a href=\\\"https://github.com/datastructures-js/queue\\\" target=\\\"_blank\\\">datastructures-js/queue</a>.</p>\"], \"ruby\": [\"Ruby\", \"<p><code>Ruby 3.1</code></p>\\r\\n\\r\\n<p>Some common data structure implementations are provided in the Algorithms module: https://www.rubydoc.info/github/kanwei/algorithms/Algorithms</p>\"], \"swift\": [\"Swift\", \"<p><code>Swift 5.5.2</code>.</p>\"], \"golang\": [\"Go\", \"<p><code>Go 1.17.6</code>.</p>\\r\\n\\r\\n<p>Support <a href=\\\"https://godoc.org/github.com/emirpasic/gods\\\" target=\\\"_blank\\\">https://godoc.org/github.com/emirpasic/gods</a> library.</p>\"], \"python3\": [\"Python3\", \"<p><code>Python 3.10</code>.</p>\\r\\n\\r\\n<p>Most libraries are already imported automatically for your convenience, such as <a href=\\\"https://docs.python.org/3/library/array.html\\\" target=\\\"_blank\\\">array</a>, <a href=\\\"https://docs.python.org/3/library/bisect.html\\\" target=\\\"_blank\\\">bisect</a>, <a href=\\\"https://docs.python.org/3/library/collections.html\\\" target=\\\"_blank\\\">collections</a>. If you need more libraries, you can import it yourself.</p>\\r\\n\\r\\n<p>For Map/TreeMap data structure, you may use <a href=\\\"http://www.grantjenks.com/docs/sortedcontainers/\\\" target=\\\"_blank\\\">sortedcontainers</a> library.</p>\"], \"scala\": [\"Scala\", \"<p><code>Scala 2.13.7</code>.</p>\"], \"kotlin\": [\"Kotlin\", \"<p><code>Kotlin 1.3.10</code>.</p>\"], \"rust\": [\"Rust\", \"<p><code>Rust 1.58.1</code></p>\\r\\n\\r\\n<p>Supports <a href=\\\"https://crates.io/crates/rand\\\" target=\\\"_blank\\\">rand </a> v0.6\\u00a0from crates.io</p>\"], \"php\": [\"PHP\", \"<p><code>PHP 8.1</code>.</p>\\r\\n<p>With bcmath module</p>\"], \"typescript\": [\"Typescript\", \"<p><code>TypeScript 4.5.4, Node.js 16.13.2</code>.</p>\\r\\n\\r\\n<p>Your code is run with <code>--harmony</code> flag, enabling <a href=\\\"http://node.green/\\\" target=\\\"_blank\\\">new ES2020 features</a>.</p>\\r\\n\\r\\n<p><a href=\\\"https://lodash.com\\\" target=\\\"_blank\\\">lodash.js</a> library is included by default.</p>\"], \"racket\": [\"Racket\", \"<p>Run with <code>Racket 8.3</code>.</p>\"], \"erlang\": [\"Erlang\", \"Erlang/OTP 24.2\"], \"elixir\": [\"Elixir\", \"Elixir 1.13.0 with Erlang/OTP 24.2\"]}",
        "libraryUrl": null,
        "adminUrl": null,
        "challengeQuestion": {
            "id": "885",
            "date": "2022-04-21",
            "incompleteChallengeCount": 30,
            "streakCount": 0,
            "type": "DAILY",
            "__typename": "ChallengeQuestionNode"
        },
        "__typename": "QuestionNode"
    },
    "solution": {
        "id": "852",
        "content": "[TOC]\n\n## Solution\n\n---\n#### Intuition\n\nThis is a classical question from textbook, which is intended to test one's knowledge on data structure. Therefore, needless to say, it is not desirable to solve the problem with any build-in HashSet data structure.\n\n>There are two key questions that one should address, in order to implement the HashSet data structure, namely _**hash function**_ and _**collision handling**_.\n\n- _**hash function**_: the goal of the hash function is to assign an address to store a given value. Ideally, each unique value should have a unique hash value. \n\n- _**collision handling**_: since the nature of a hash function is to map a value from a space `A` into a corresponding value in a __*smaller*__ space `B`, it could happen that multiple values from space `A` might be mapped to the _same_ value in space `B`. This is what we call __*collision*__. Therefore, it is indispensable for us to have a strategy to handle the collision. \n\nOverall, there are several strategies to resolve the collisions:\n\n- [Separate Chaining](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining): for values with the same hash key, we keep them in a _bucket_, and each bucket is independent of each other.\n\n- [Open Addressing](https://en.wikipedia.org/wiki/Hash_table#Open_addressing): whenever there is a collision, we keep on _probing_ on the main space with certain strategy until a free slot is found.\n\n- [2-Choice Hashing](https://en.wikipedia.org/wiki/2-choice_hashing): we use two hash functions rather than one, and we pick the generated address with fewer collision.\n\nIn this article, we focus on the strategy of _**separate chaining**_. Here is how it works overall.\n\n- Essentially, the primary storage underneath a HashSet is a continuous memory as `Array`. Each element in this array corresponds to a `bucket` that stores the actual values.\n\n- Given a `value`, first we generate a key for the value via the _hash function_. The generated key serves as the index to locate the bucket.\n\n- Once the `bucket` is located, we then perform the desired operations on the bucket, such as `add`, `remove` and `contains`.\n\n---\n#### Approach 1: LinkedList as Bucket\n\n**Intuition**\n\n\nThe common choice of hash function is the `modulo` operator, _i.e._ $$\\text{hash} = \\text{value} \\mod \\text{base}$$. Here, the $$\\text{base}$$ of modulo operation would determine the number of buckets that we would have at the end in the HashSet.\n\nTheoretically, the more buckets we have (hence the larger the space would be), the less likely that we would have _collisions_. The choice of $$\\text{base}$$ is a tradeoff between the space and the collision. \n\nIn addition, it is generally advisable to use a prime number as the base of modulo, _e.g._ $$769$$, in order to reduce the potential collisions. \n\n![pic](../Figures/705/705_linked_list.png)\n\nAs to the design of `bucket`, again there are several options. One could simply use another `Array` as bucket to store all the values.\nHowever, one drawback with the Array data structure is that it would take $$\\mathcal{O}(N)$$ time complexity to remove or insert an element, rather than the desired $$\\mathcal{O}(1)$$.\n\nSince for any update operation, we would need to scan the entire _bucket_ first to avoid any duplicate, a better choice for the implementation of _bucket_ would be the _**LinkedList**_, which has a constant time complexity for the _insertion_ as well as _deletion_, once we locate the position to update.\n\n**Algorithm**\n\nAs we discussed in the above section, here we adopt the `LinkedList` to implement our _bucket_ within the HashSet.\n\n>Essentially, we are implementing a _LinkedList_ that does not contain any duplicate.\n\nFor each of the functions of `add`, `remove` and `contains`, we first generate the bucket index with the hash function. Then, we simply pass down the operation to the underlying bucket.\n\n\n<iframe src=\"https://leetcode.com/playground/9dmmFzE2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9dmmFzE2\"></iframe>\n\n\n***Implementation Notes***\n\nIn the Python implementation, we employed a sort of **_pseudo head_** to keep a reference to the _actual_ head of the LinkedList, which could _simplify_ a bit the logic by reducing the number of branchings.\n\nFor a value that was never seen before, we insert it to the **head** of the bucket, though we could also append it to the tail. It is a choice that we made, which could **fit better** the scenario where redundant values are operated in nearby time windows, since it is more likely that we spot the value at the head of the bucket rather than walking through the entire bucket.\n\n\n**Complexity Analysis**\n\n- Time Complexity: $$\\mathcal{O}(\\frac{N}{K})$$ where $$N$$ is the number of all possible values and $$K$$ is the number of predefined buckets, which is `769`.\n\n    - Assuming that the values are _evenly_ distributed, thus we could consider that the average size of bucket is $$\\frac{N}{K}$$. \n\n    - Since for each operation, in the worst case, we would need to scan the entire bucket, hence the time complexity is $$\\mathcal{O}(\\frac{N}{K})$$.\n<br/>\n\n- Space Complexity: $$\\mathcal{O}(K+M)$$ where $$K$$ is the number of predefined buckets, and $$M$$ is the number of unique values that have been inserted into the HashSet.\n<br/>\n<br/>\n\n---\n#### Approach 2: Binary Search Tree (BST) as Bucket\n\n**Intuition**\n\nIn the above approach, one of the drawbacks is that we have to scan the entire linkedlist in order to verify if a value already exists in the bucket (_i.e._ the lookup operation).\n\nTo optimize the above process, one of the strategies could be that we maintain a _**sorted list**_ as the bucket. With the sorted list, we could obtain the $$\\mathcal{O}(\\log{N})$$ time complexity for the lookup operation, with the binary search algorithm, rather than a linear $$\\mathcal{O}({N})$$ complexity as in the above approach.\n\nOn the other hand, if we implement the sorted list in a continuous space such as Array, it would incur a _linear_ time complexity for the update operations (_e.g._ _insert_ and _delete_), since we would need to shift the elements.\n\n>So the question is can we have a data structure that have $$\\mathcal{O}(\\log{N})$$ time complexity, for the operations of _search_, _insert_ and _delete_ ?\n\nWell. The answer is yes, with _**Binary Search Tree**_ (BST). Thanks to the properties of BST, we could optimize the time complexity of our first approach with LinkedList.\n\n![pic](../Figures/705/705_BST.png)\n\nAs a result, now the problem is boiled down to the implementation of a standard Binary Search Tree that serves as the _bucket_ in the HashSet.\n\n**Algorithm**\n\nOne could build upon the implementation of first approach for our second approach, by applying the [Fa\u00e7ade design pattern](https://en.wikipedia.org/wiki/Facade_pattern).\n\n>We have already defined a fa\u00e7ade class (_i.e._ `bucket`) with three interfaces (`exists`, `insert` and `delete`), which hides all the underlying details from its users (_i.e._ HashSet).\n\nSo we can keep the bulk of the code, and simply modify the implementation of `bucket` class with BST. For each of the interfaces in `bucket`, it corresponds exactly to an operation in BST.\n\n!?!../Documents/705_LIS.json:1000,456!?!\n\nActually, we have each of the BST operations listed as an independent problem in LeetCode, as follows:\n\n- [Article 700. Search in a BST](https://leetcode.com/articles/search-in-a-bst/)\n- [Article 701. Insert in a BST](https://leetcode.com/articles/insert-into-a-bst/)\n- [Article 450. Delete in a BST](https://leetcode.com/articles/delete-node-in-a-bst)\n\nOne could try these exercises first, and then combine them together to get a full implementation of BST. \n\n<iframe src=\"https://leetcode.com/playground/YUYiqfQR/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"YUYiqfQR\"></iframe>\n\n\n\n**Complexity Analysis**\n\n- Time Complexity: $$\\mathcal{O}(\\log{\\frac{N}{K}})$$ where $$N$$ is the number of all possible values and $$K$$ is the number of predefined buckets, which is `769`.\n\n    - Assuming that the values are evenly distributed, we could consider that the average size of bucket is $$\\frac{N}{K}$$. \n\n    - When we traverse the BST, we are conducting binary search, as a result, the final time complexity of each operation is $$\\mathcal{O}(\\log{\\frac{N}{K}})$$.\n\n- Space Complexity: $$\\mathcal{O}(K+M)$$ where $$K$$ is the number of predefined buckets, and $$M$$ is the number of unique values that have been inserted into the HashSet.\n<br/>\n<br/>\n\n---\n#### Notes on Hash Function\n\nIn all the above approaches, the range of address is fixed, since the base of modulo operator is fixed.\n\nSometimes, it might be more desirable to have a __*dynamic space*__ that goes with the increase of elements in the HashSet. One could set up a threshold on the _load factor_ (_i.e._ ratio between the number of elements and the size of space) of the HashSet, and double the range of address, once the load factor exceeds the threshold.\n\nThe increase of address space could potentially **_reduce_** the collisions, therefore improve the overall performance of HashSet.\nHowever, one should also take into account the cost of **_rehashing_** and redistributing the existing values. \n\nIn another scenario, one could adopt the **_2-choice hashing_** as we mentioned at the beginning, which could help the values to be more _**evenly**_ distributed in the address space.\n<br/>\n<br/>",
        "contentTypeId": "107",
        "canSeeDetail": true,
        "paidOnly": true,
        "hasVideoSolution": false,
        "paidOnlyVideo": true,
        "rating": {
            "id": "810",
            "count": 81,
            "average": "4.741",
            "userRating": null,
            "__typename": "RatingNode"
        },
        "__typename": "ArticleNode"
    },
    "questionCode": "design-hashset",
    "playgroundData": {
        "9dmmFzE2": {
            "playground": {
                "testcaseInput": "",
                "name": "design-hashset-1",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        },
        "YUYiqfQR": {
            "playground": {
                "testcaseInput": "",
                "name": "design-hashset-0",
                "isUserOwner": false,
                "isLive": false,
                "showRunCode": false,
                "showOpenInPlayground": false,
                "selectedLangSlug": "cpp",
                "isShared": true,
                "__typename": "PlaygroundNode"
            },
            "allPlaygroundCodes": [
                {
                    "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
                    "langSlug": "java",
                    "__typename": "PlaygroundCodeNode"
                },
                {
                    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]",
                    "langSlug": "python3",
                    "__typename": "PlaygroundCodeNode"
                }
            ]
        }
    }
}